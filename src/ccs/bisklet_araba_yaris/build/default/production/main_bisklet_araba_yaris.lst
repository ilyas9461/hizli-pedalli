CCS PCH C Compiler, Version 5.015, 5967               12-Mar-19 15:27

               Filename:   D:\EasyPICV6\Arduino\bisiklet_araba_yaris\ccs\bisklet_araba_yaris\build\default\production\main_bisklet_araba_yaris.lst

               ROM used:   23234 bytes (71%)
                           Largest free fragment is 9530
               RAM used:   176 (11%) at main() level
                           296 (19%) worst case
               Stack used: 9 locations (7 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   55C8
*
0008:  GOTO   00CA
000C:  NOP   
000E:  NOP   
0010:  NOP   
0012:  NOP   
0014:  NOP   
0016:  NOP   
0018:  MOVWF  04
001A:  MOVFF  FD8,05
001E:  MOVFF  FE0,06
0022:  MOVLB  0
0024:  MOVFF  FE9,0C
0028:  MOVFF  FEA,07
002C:  MOVFF  FE1,08
0030:  MOVFF  FE2,09
0034:  MOVFF  FD9,0A
0038:  MOVFF  FDA,0B
003C:  MOVFF  FF3,12
0040:  MOVFF  FF4,13
0044:  MOVFF  FFA,14
0048:  MOVFF  00,0E
004C:  MOVFF  01,0F
0050:  MOVFF  02,10
0054:  MOVFF  03,11
0058:  BTFSS  FF2.5
005A:  GOTO   0064
005E:  BTFSC  FF2.2
0060:  GOTO   017C
0064:  BTFSS  FF0.3
0066:  GOTO   0070
006A:  BTFSC  FF0.0
006C:  GOTO   07AC
0070:  BTFSS  FF0.4
0072:  GOTO   007C
0076:  BTFSC  FF0.1
0078:  GOTO   07C8
007C:  BTFSS  FF2.3
007E:  GOTO   0088
0082:  BTFSC  FF2.0
0084:  GOTO   07E4
0088:  MOVFF  0E,00
008C:  MOVFF  0F,01
0090:  MOVFF  10,02
0094:  MOVFF  11,03
0098:  MOVFF  0C,FE9
009C:  MOVFF  07,FEA
00A0:  BSF    07.7
00A2:  MOVFF  08,FE1
00A6:  MOVFF  09,FE2
00AA:  MOVFF  0A,FD9
00AE:  MOVFF  0B,FDA
00B2:  MOVFF  12,FF3
00B6:  MOVFF  13,FF4
00BA:  MOVFF  14,FFA
00BE:  MOVF   04,W
00C0:  MOVFF  06,FE0
00C4:  MOVFF  05,FD8
00C8:  RETFIE 0
00CA:  MOVWF  17
00CC:  MOVFF  FD8,18
00D0:  MOVFF  FE0,19
00D4:  MOVLB  0
00D6:  MOVFF  FE9,1F
00DA:  MOVFF  FEA,1A
00DE:  MOVFF  FE1,1B
00E2:  MOVFF  FE2,1C
00E6:  MOVFF  FD9,1D
00EA:  MOVFF  FDA,1E
00EE:  MOVFF  FF3,25
00F2:  MOVFF  FF4,26
00F6:  MOVFF  FFA,27
00FA:  MOVFF  00,21
00FE:  MOVFF  01,22
0102:  MOVFF  02,23
0106:  MOVFF  03,24
010A:  BTFSS  FF2.4
010C:  GOTO   0116
0110:  BTFSC  FF2.1
0112:  GOTO   0770
0116:  MOVFF  21,00
011A:  MOVFF  22,01
011E:  MOVFF  23,02
0122:  MOVFF  24,03
0126:  MOVFF  1F,FE9
012A:  MOVFF  1A,FEA
012E:  BSF    1A.7
0130:  MOVFF  1B,FE1
0134:  MOVFF  1C,FE2
0138:  MOVFF  1D,FD9
013C:  MOVFF  1E,FDA
0140:  MOVFF  25,FF3
0144:  MOVFF  26,FF4
0148:  MOVFF  27,FFA
014C:  MOVF   17,W
014E:  MOVFF  19,FE0
0152:  MOVFF  18,FD8
0156:  RETFIE 0
.................... /*  
....................  * File:   main_bisklet_araba_yaris.c 
....................  * Author: ilyas 
....................  * 
....................  * Created on 21 Þubat 2019 Perþembe, 17:05 
....................  */ 
.................... #include "main_bisklet_araba_yaris.h" 
.................... /*  
....................  * File:   main_bisklet_araba_yaris.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 21 Þubat 2019 Perþembe, 17:05 
....................  */ 
....................  
.................... #ifndef MAIN_BISKLET_ARABA_YARIS_H 
.................... #define	MAIN_BISKLET_ARABA_YARIS_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................      #include <18F45K22.h> 
.................... //////////// Standard Header file for the PIC18F45K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F45K22 
0158:  MOVFF  FF2,0D
015C:  BCF    FF2.6
015E:  BCF    FF2.7
0160:  CLRF   FF7
0162:  ADDLW  78
0164:  MOVWF  FF6
0166:  MOVLW  01
0168:  ADDWFC FF7,F
016A:  TBLRD*+
016C:  MOVF   FF5,W
016E:  BTFSC  0D.6
0170:  BSF    FF2.6
0172:  BTFSC  0D.7
0174:  BSF    FF2.7
0176:  RETURN 0
0178:  DATA 28,0C
017A:  DATA 01,06
*
01B2:  DATA 0C,54
01B4:  DATA 4F,50
01B6:  DATA 4C,41
01B8:  DATA 4D,20
01BA:  DATA 4A,45
01BC:  DATA 54,4F
01BE:  DATA 4E,20
01C0:  DATA 3A,00
01C2:  DATA 0C,4F
01C4:  DATA 59,55
01C6:  DATA 4E,20
01C8:  DATA 53,55
01CA:  DATA 52,45
01CC:  DATA 20,3A
01CE:  DATA 00,00
01D0:  DATA 0C,42
01D2:  DATA 49,53
01D4:  DATA 2E,20
01D6:  DATA 53,45
01D8:  DATA 43,4D
01DA:  DATA 45,20
01DC:  DATA 53,55
01DE:  DATA 52,45
01E0:  DATA 3A,00
01E2:  DATA 0C,4D
01E4:  DATA 41,58
01E6:  DATA 20,48
01E8:  DATA 49,5A
01EA:  DATA 3A,00
01EC:  DATA 0C,4D
01EE:  DATA 50,33
01F0:  DATA 20,53
01F2:  DATA 65,73
01F4:  DATA 3A,00
01F6:  DATA 0C,43
01F8:  DATA 41,4C
01FA:  DATA 49,53
01FC:  DATA 4D,41
01FE:  DATA 20,4A
0200:  DATA 45,54
0202:  DATA 4F,4E
0204:  DATA 3A,00
0206:  DATA 0C,20
0208:  DATA 20,20
020A:  DATA 20,3C
020C:  DATA 20,4D
020E:  DATA 45,4E
0210:  DATA 55,20
0212:  DATA 3E,00
0214:  DATA 0A,20
0216:  DATA 20,20
0218:  DATA 20,3C
021A:  DATA 3C,20
021C:  DATA 3C,3E
021E:  DATA 20,3E
0220:  DATA 3E,00
0222:  DATA 0C,20
0224:  DATA 31,2D
0226:  DATA 4F,59
0228:  DATA 55,4E
022A:  DATA 20,53
022C:  DATA 75,72
022E:  DATA 65,00
0230:  DATA 0A,20
0232:  DATA 20,20
0234:  DATA 20,3C
0236:  DATA 3C,20
0238:  DATA 3C,3E
023A:  DATA 20,3E
023C:  DATA 3E,00
023E:  DATA 0C,20
0240:  DATA 32,2D
0242:  DATA 53,65
0244:  DATA 63,6D
0246:  DATA 65,20
0248:  DATA 53,75
024A:  DATA 72,65
024C:  DATA 73,69
024E:  DATA 00,00
0250:  DATA 0A,20
0252:  DATA 20,20
0254:  DATA 20,3C
0256:  DATA 3C,20
0258:  DATA 3C,3E
025A:  DATA 20,3E
025C:  DATA 3E,00
025E:  DATA 0C,20
0260:  DATA 33,2D
0262:  DATA 4D,6F
0264:  DATA 74,6F
0266:  DATA 72,20
0268:  DATA 54,45
026A:  DATA 53,54
026C:  DATA 00,00
026E:  DATA 0A,20
0270:  DATA 20,20
0272:  DATA 20,3C
0274:  DATA 3C,20
0276:  DATA 3C,3E
0278:  DATA 20,3E
027A:  DATA 3E,00
027C:  DATA 0C,20
027E:  DATA 34,2D
0280:  DATA 53,65
0282:  DATA 6E,73
0284:  DATA 6F,72
0286:  DATA 20,54
0288:  DATA 45,53
028A:  DATA 54,00
028C:  DATA 0A,20
028E:  DATA 20,20
0290:  DATA 20,3C
0292:  DATA 3C,20
0294:  DATA 3C,3E
0296:  DATA 20,3E
0298:  DATA 3E,00
029A:  DATA 0C,20
029C:  DATA 35,2D
029E:  DATA 53,45
02A0:  DATA 53,00
02A2:  DATA 0A,20
02A4:  DATA 20,20
02A6:  DATA 20,3C
02A8:  DATA 3C,20
02AA:  DATA 3C,3E
02AC:  DATA 20,3E
02AE:  DATA 3E,00
02B0:  DATA 0C,20
02B2:  DATA 36,2D
02B4:  DATA 4A,45
02B6:  DATA 54,4F
02B8:  DATA 4E,20
02BA:  DATA 53,61
02BC:  DATA 79,69
02BE:  DATA 73,69
02C0:  DATA 00,00
02C2:  DATA 0A,20
02C4:  DATA 20,20
02C6:  DATA 20,3C
02C8:  DATA 3C,20
02CA:  DATA 3C,3E
02CC:  DATA 20,3E
02CE:  DATA 3E,00
02D0:  DATA 0C,20
02D2:  DATA 37,2D
02D4:  DATA 52,45
02D6:  DATA 53,45
02D8:  DATA 54,00
02DA:  DATA 0A,20
02DC:  DATA 20,20
02DE:  DATA 20,3C
02E0:  DATA 3C,20
02E2:  DATA 3C,3E
02E4:  DATA 20,3E
02E6:  DATA 3E,00
02E8:  DATA 0C,20
02EA:  DATA 38,2D
02EC:  DATA 43,49
02EE:  DATA 4B,49
02F0:  DATA 53,00
02F2:  DATA 0A,20
02F4:  DATA 20,20
02F6:  DATA 20,3C
02F8:  DATA 3C,20
02FA:  DATA 3C,3E
02FC:  DATA 20,3E
02FE:  DATA 3E,00
0300:  DATA 0C,53
0302:  DATA 75,72
0304:  DATA 65,20
0306:  DATA 3A,20
0308:  DATA 25,66
030A:  DATA 20,64
030C:  DATA 6B,2E
030E:  DATA 00,00
0310:  DATA 0A,20
0312:  DATA 20,20
0314:  DATA 20,3C
0316:  DATA 3C,20
0318:  DATA 3C,3E
031A:  DATA 20,3E
031C:  DATA 3E,00
031E:  DATA 0C,53
0320:  DATA 75,72
0322:  DATA 65,20
0324:  DATA 3A,20
0326:  DATA 25,66
0328:  DATA 20,64
032A:  DATA 6B,2E
032C:  DATA 00,00
032E:  DATA 0A,20
0330:  DATA 20,20
0332:  DATA 20,3C
0334:  DATA 3C,20
0336:  DATA 3C,3E
0338:  DATA 20,3E
033A:  DATA 3E,00
033C:  DATA 0C,20
033E:  DATA 21,20
0340:  DATA 4B,41
0342:  DATA 59,44
0344:  DATA 45,44
0346:  DATA 49,4C
0348:  DATA 44,49
034A:  DATA 20,21
034C:  DATA 00,00
034E:  DATA 0A,54
0350:  DATA 3A,25
0352:  DATA 6C,75
0354:  DATA 00,00
0356:  DATA 0C,53
0358:  DATA 75,72
035A:  DATA 65,20
035C:  DATA 3A,20
035E:  DATA 25,75
0360:  DATA 20,53
0362:  DATA 2E,00
0364:  DATA 0A,20
0366:  DATA 20,20
0368:  DATA 20,3C
036A:  DATA 3C,20
036C:  DATA 3C,3E
036E:  DATA 20,3E
0370:  DATA 3E,00
0372:  DATA 0C,20
0374:  DATA 21,20
0376:  DATA 4B,41
0378:  DATA 59,44
037A:  DATA 45,44
037C:  DATA 49,4C
037E:  DATA 44,49
0380:  DATA 20,21
0382:  DATA 00,00
0384:  DATA 0C,4D
0386:  DATA 31,20
0388:  DATA 79,6F
038A:  DATA 6B,20
038C:  DATA 21,21
038E:  DATA 21,00
0390:  DATA 0A,49
0392:  DATA 31,3A
0394:  DATA 25,4C
0396:  DATA 75,00
0398:  DATA 0C,4D
039A:  DATA 32,20
039C:  DATA 79,6F
039E:  DATA 6B,20
03A0:  DATA 21,21
03A2:  DATA 21,00
03A4:  DATA 0A,49
03A6:  DATA 32,3A
03A8:  DATA 25,4C
03AA:  DATA 75,00
03AC:  DATA 0C,21
03AE:  DATA 20,41
03B0:  DATA 53,49
03B2:  DATA 52,49
03B4:  DATA 20,41
03B6:  DATA 4B,49
03B8:  DATA 4D,20
03BA:  DATA 21,00
03BC:  DATA 0A,20
03BE:  DATA 20,20
03C0:  DATA 20,3C
03C2:  DATA 3C,20
03C4:  DATA 3C,3E
03C6:  DATA 20,3E
03C8:  DATA 3E,00
03CA:  DATA 0C,48
03CC:  DATA 49,5A
03CE:  DATA 20,3A
03D0:  DATA 20,25
03D2:  DATA 4C,75
03D4:  DATA 20,00
03D6:  DATA 0A,49
03D8:  DATA 31,3A
03DA:  DATA 25,6C
03DC:  DATA 75,20
03DE:  DATA 49,32
03E0:  DATA 3A,25
03E2:  DATA 6C,75
03E4:  DATA 00,00
03E6:  DATA 0C,20
03E8:  DATA 21,20
03EA:  DATA 4B,41
03EC:  DATA 59,44
03EE:  DATA 45,44
03F0:  DATA 49,4C
03F2:  DATA 44,49
03F4:  DATA 20,21
03F6:  DATA 00,00
03F8:  DATA 0C,53
03FA:  DATA 65,6E
03FC:  DATA 73,3A
03FE:  DATA 20,4A
0400:  DATA 45,54
0402:  DATA 4F,4E
0404:  DATA 00,00
0406:  DATA 0A,20
0408:  DATA 20,20
040A:  DATA 20,3C
040C:  DATA 3C,20
040E:  DATA 3C,3E
0410:  DATA 20,3E
0412:  DATA 3E,00
0414:  DATA 0C,53
0416:  DATA 65,6E
0418:  DATA 73,3A
041A:  DATA 20,4A
041C:  DATA 45,54
041E:  DATA 4F,4E
0420:  DATA 32,00
0422:  DATA 0A,20
0424:  DATA 20,20
0426:  DATA 20,3C
0428:  DATA 3C,20
042A:  DATA 3C,3E
042C:  DATA 20,3E
042E:  DATA 3E,00
0430:  DATA 0C,53
0432:  DATA 65,6E
0434:  DATA 73,3A
0436:  DATA 20,48
0438:  DATA 49,5A
043A:  DATA 31,20
043C:  DATA 00,00
043E:  DATA 0A,20
0440:  DATA 20,20
0442:  DATA 20,3C
0444:  DATA 3C,20
0446:  DATA 3C,3E
0448:  DATA 20,3E
044A:  DATA 3E,00
044C:  DATA 0C,53
044E:  DATA 65,6E
0450:  DATA 73,3A
0452:  DATA 20,48
0454:  DATA 49,5A
0456:  DATA 32,20
0458:  DATA 00,00
045A:  DATA 0A,20
045C:  DATA 20,20
045E:  DATA 20,3C
0460:  DATA 3C,20
0462:  DATA 3C,3E
0464:  DATA 20,3E
0466:  DATA 3E,00
0468:  DATA 0C,53
046A:  DATA 65,6E
046C:  DATA 73,3A
046E:  DATA 20,54
0470:  DATA 55,52
0472:  DATA 31,20
0474:  DATA 00,00
0476:  DATA 0A,20
0478:  DATA 20,20
047A:  DATA 20,3C
047C:  DATA 3C,20
047E:  DATA 3C,3E
0480:  DATA 20,3E
0482:  DATA 3E,00
0484:  DATA 0C,53
0486:  DATA 65,6E
0488:  DATA 73,3A
048A:  DATA 20,54
048C:  DATA 55,52
048E:  DATA 32,20
0490:  DATA 00,00
0492:  DATA 0A,20
0494:  DATA 20,20
0496:  DATA 20,3C
0498:  DATA 3C,20
049A:  DATA 3C,3E
049C:  DATA 20,3E
049E:  DATA 3E,00
04A0:  DATA 0C,53
04A2:  DATA 65,6E
04A4:  DATA 73,3A
04A6:  DATA 20,42
04A8:  DATA 49,53
04AA:  DATA 20,42
04AC:  DATA 54,4E
04AE:  DATA 31,20
04B0:  DATA 00,00
04B2:  DATA 0A,20
04B4:  DATA 20,20
04B6:  DATA 20,3C
04B8:  DATA 3C,20
04BA:  DATA 3C,3E
04BC:  DATA 20,3E
04BE:  DATA 3E,00
04C0:  DATA 0C,53
04C2:  DATA 65,6E
04C4:  DATA 73,3A
04C6:  DATA 20,42
04C8:  DATA 49,53
04CA:  DATA 20,42
04CC:  DATA 54,4E
04CE:  DATA 32,20
04D0:  DATA 00,00
04D2:  DATA 0A,20
04D4:  DATA 20,20
04D6:  DATA 20,3C
04D8:  DATA 3C,20
04DA:  DATA 3C,3E
04DC:  DATA 20,3E
04DE:  DATA 3E,00
04E0:  DATA 0C,53
04E2:  DATA 45,53
04E4:  DATA 3A,20
04E6:  DATA 25,75
04E8:  DATA 20,00
04EA:  DATA 0A,20
04EC:  DATA 20,20
04EE:  DATA 20,3C
04F0:  DATA 3C,20
04F2:  DATA 3C,3E
04F4:  DATA 20,3E
04F6:  DATA 3E,00
04F8:  DATA 0C,20
04FA:  DATA 21,20
04FC:  DATA 4B,41
04FE:  DATA 59,44
0500:  DATA 45,44
0502:  DATA 49,4C
0504:  DATA 44,49
0506:  DATA 20,21
0508:  DATA 00,00
050A:  DATA 0C,44
050C:  DATA 49,4B
050E:  DATA 4B,41
0510:  DATA 54,20
0512:  DATA 21,21
0514:  DATA 21,00
0516:  DATA 0A,4B
0518:  DATA 61,72
051A:  DATA 74,6C
051C:  DATA 69,20
051E:  DATA 73,69
0520:  DATA 73,2E
0522:  DATA 20,64
0524:  DATA 65,2C
0526:  DATA 00,00
0528:  DATA 0A,6A
052A:  DATA 65,74
052C:  DATA 6F,6E
052E:  DATA 3D,30
0530:  DATA 20,6F
0532:  DATA 6C,6D
0534:  DATA 61,6C
0536:  DATA 69,2E
0538:  DATA 2E,00
053A:  DATA 0C,4A
053C:  DATA 65,74
053E:  DATA 6F,6E
0540:  DATA 3A,20
0542:  DATA 25,64
0544:  DATA 20,00
0546:  DATA 0A,20
0548:  DATA 20,20
054A:  DATA 20,3C
054C:  DATA 3C,20
054E:  DATA 3C,3E
0550:  DATA 20,3E
0552:  DATA 3E,00
0554:  DATA 0C,20
0556:  DATA 21,20
0558:  DATA 4B,41
055A:  DATA 59,44
055C:  DATA 45,44
055E:  DATA 49,4C
0560:  DATA 44,49
0562:  DATA 20,21
0564:  DATA 00,00
0566:  DATA 0C,52
0568:  DATA 45,53
056A:  DATA 45,54
056C:  DATA 20,3F
056E:  DATA 00,00
0570:  DATA 0A,20
0572:  DATA 20,20
0574:  DATA 3C,45
0576:  DATA 3E,20
0578:  DATA 3C,3E
057A:  DATA 20,3C
057C:  DATA 48,3E
057E:  DATA 00,00
0580:  DATA 0C,54
0582:  DATA 4F,50
0584:  DATA 2E,4A
0586:  DATA 65,74
0588:  DATA 6F,6E
058A:  DATA 53,61
058C:  DATA 79,69
058E:  DATA 73,69
0590:  DATA 3A,00
0592:  DATA 0A,20
0594:  DATA 20,20
0596:  DATA 30,00
0598:  DATA 0C,4F
059A:  DATA 59,55
059C:  DATA 4E,20
059E:  DATA 53,55
05A0:  DATA 52,45
05A2:  DATA 3A,00
05A4:  DATA 0A,20
05A6:  DATA 20,20
05A8:  DATA 32,2E
05AA:  DATA 35,20
05AC:  DATA 64,6B
05AE:  DATA 2E,00
05B0:  DATA 0C,42
05B2:  DATA 49,53
05B4:  DATA 2E,20
05B6:  DATA 53,45
05B8:  DATA 43,4D
05BA:  DATA 45,20
05BC:  DATA 53,55
05BE:  DATA 52,45
05C0:  DATA 3A,00
05C2:  DATA 0A,20
05C4:  DATA 20,20
05C6:  DATA 35,20
05C8:  DATA 53,2E
05CA:  DATA 00,00
05CC:  DATA 0C,48
05CE:  DATA 49,5A
05D0:  DATA 20,3A
05D2:  DATA 00,00
05D4:  DATA 0A,20
05D6:  DATA 20,20
05D8:  DATA 34,30
05DA:  DATA 30,00
05DC:  DATA 0C,43
05DE:  DATA 41,4C
05E0:  DATA 49,53
05E2:  DATA 4D,41
05E4:  DATA 20,4A
05E6:  DATA 45,54
05E8:  DATA 4F,4E
05EA:  DATA 3A,00
05EC:  DATA 0A,20
05EE:  DATA 20,20
05F0:  DATA 30,00
05F2:  DATA 0C,20
05F4:  DATA 20,20
05F6:  DATA 20,59
05F8:  DATA 4F,59
05FA:  DATA 55,4E
05FC:  DATA 43,41
05FE:  DATA 4B,00
0600:  DATA 0A,20
0602:  DATA 48,49
0604:  DATA 5A,4C
0606:  DATA 49,20
0608:  DATA 26,20
060A:  DATA 50,45
060C:  DATA 44,41
060E:  DATA 4C,4C
0610:  DATA 49,00
0612:  DATA 0C,20
0614:  DATA 20,20
0616:  DATA 20,59
0618:  DATA 4F,59
061A:  DATA 55,4E
061C:  DATA 43,41
061E:  DATA 4B,00
0620:  DATA 0A,20
0622:  DATA 48,49
0624:  DATA 5A,4C
0626:  DATA 49,20
0628:  DATA 26,20
062A:  DATA 50,45
062C:  DATA 44,41
062E:  DATA 4C,4C
0630:  DATA 49,00
0632:  DATA 30,31
0634:  DATA 30,31
0636:  DATA 30,31
0638:  DATA 30,31
063A:  DATA 63,00
063C:  DATA 30,31
063E:  DATA 30,31
0640:  DATA 30,31
0642:  DATA 30,31
0644:  DATA 63,00
0646:  DATA 0C,20
0648:  DATA 20,20
064A:  DATA 20,59
064C:  DATA 4F,59
064E:  DATA 55,4E
0650:  DATA 43,41
0652:  DATA 4B,00
0654:  DATA 0A,20
0656:  DATA 48,49
0658:  DATA 5A,4C
065A:  DATA 49,20
065C:  DATA 26,20
065E:  DATA 50,45
0660:  DATA 44,41
0662:  DATA 4C,4C
0664:  DATA 49,00
0666:  DATA 30,31
0668:  DATA 30,31
066A:  DATA 30,31
066C:  DATA 30,31
066E:  DATA 63,00
0670:  DATA 30,31
0672:  DATA 30,31
0674:  DATA 30,31
0676:  DATA 30,31
0678:  DATA 63,00
067A:  DATA 0C,54
067C:  DATA 4F,50
067E:  DATA 4C,41
0680:  DATA 4D,20
0682:  DATA 4A,45
0684:  DATA 54,4F
0686:  DATA 4E,20
0688:  DATA 3A,00
068A:  DATA 0C,20
068C:  DATA 48,49
068E:  DATA 5A,4C
0690:  DATA 49,20
0692:  DATA 26,20
0694:  DATA 50,45
0696:  DATA 44,41
0698:  DATA 4C,4C
069A:  DATA 49,00
069C:  DATA 0A,20
069E:  DATA 20,20
06A0:  DATA 3A,3A
06A2:  DATA 20,20
06A4:  DATA 25,75
06A6:  DATA 20,20
06A8:  DATA 3A,3A
06AA:  DATA 00,00
06AC:  DATA 30,31
06AE:  DATA 30,31
06B0:  DATA 30,31
06B2:  DATA 30,31
06B4:  DATA 63,00
06B6:  DATA 30,31
06B8:  DATA 30,31
06BA:  DATA 30,31
06BC:  DATA 30,31
06BE:  DATA 63,00
06C0:  DATA 0C,4F
06C2:  DATA 59,55
06C4:  DATA 4E,20
06C6:  DATA 2D,3E
06C8:  DATA 00,00
06CA:  DATA 0A,6D
06CC:  DATA 31,3A
06CE:  DATA 25,63
06D0:  DATA 2C,6D
06D2:  DATA 32,3A
06D4:  DATA 25,63
06D6:  DATA 00,00
06D8:  DATA 30,31
06DA:  DATA 30,31
06DC:  DATA 30,31
06DE:  DATA 30,31
06E0:  DATA 63,00
06E2:  DATA 30,31
06E4:  DATA 30,31
06E6:  DATA 30,31
06E8:  DATA 30,31
06EA:  DATA 63,00
06EC:  DATA 0C,21
06EE:  DATA 20,41
06F0:  DATA 53,49
06F2:  DATA 52,49
06F4:  DATA 20,41
06F6:  DATA 4B,49
06F8:  DATA 4D,20
06FA:  DATA 21,00
06FC:  DATA 0A,20
06FE:  DATA 20,20
0700:  DATA 20,3C
0702:  DATA 3C,20
0704:  DATA 3C,3E
0706:  DATA 20,3E
0708:  DATA 3E,00
070A:  DATA 0C,56
070C:  DATA 31,3A
070E:  DATA 25,32
0710:  DATA 2E,31
0712:  DATA 66,20
0714:  DATA 56,32
0716:  DATA 3A,25
0718:  DATA 32,2E
071A:  DATA 31,66
071C:  DATA 00,00
071E:  DATA 0C,73
0720:  DATA 75,72
0722:  DATA 65,3A
0724:  DATA 25,4C
0726:  DATA 75,00
0728:  DATA 0C,20
072A:  DATA 20,20
072C:  DATA 20,59
072E:  DATA 4F,59
0730:  DATA 55,4E
0732:  DATA 43,41
0734:  DATA 4B,00
0736:  DATA 0A,20
0738:  DATA 48,49
073A:  DATA 5A,4C
073C:  DATA 49,20
073E:  DATA 26,20
0740:  DATA 50,45
0742:  DATA 44,41
0744:  DATA 4C,4C
0746:  DATA 49,00
*
0A06:  TBLRD*+
0A08:  MOVF   FF5,F
0A0A:  BZ    0A24
0A0C:  MOVFF  FF6,FE
0A10:  MOVFF  FF7,FF
0A14:  MOVFF  FF5,10E
0A18:  RCALL  0996
0A1A:  MOVFF  FE,FF6
0A1E:  MOVFF  FF,FF7
0A22:  BRA    0A06
0A24:  RETURN 0
0A26:  BTFSC  FD8.1
0A28:  BRA    0A32
0A2A:  MOVLW  01
0A2C:  MOVWF  FEA
0A2E:  MOVLW  16
0A30:  MOVWF  FE9
0A32:  CLRF   00
0A34:  CLRF   01
0A36:  CLRF   02
0A38:  CLRF   03
0A3A:  MOVLB  1
0A3C:  CLRF   x16
0A3E:  CLRF   x17
0A40:  CLRF   x18
0A42:  CLRF   x19
0A44:  MOVF   x15,W
0A46:  IORWF  x14,W
0A48:  IORWF  x13,W
0A4A:  IORWF  x12,W
0A4C:  BZ    0AA6
0A4E:  MOVLW  20
0A50:  MOVWF  x1A
0A52:  BCF    FD8.0
0A54:  RLCF   x0E,F
0A56:  RLCF   x0F,F
0A58:  RLCF   x10,F
0A5A:  RLCF   x11,F
0A5C:  RLCF   x16,F
0A5E:  RLCF   x17,F
0A60:  RLCF   x18,F
0A62:  RLCF   x19,F
0A64:  MOVF   x15,W
0A66:  SUBWF  x19,W
0A68:  BNZ   0A7A
0A6A:  MOVF   x14,W
0A6C:  SUBWF  x18,W
0A6E:  BNZ   0A7A
0A70:  MOVF   x13,W
0A72:  SUBWF  x17,W
0A74:  BNZ   0A7A
0A76:  MOVF   x12,W
0A78:  SUBWF  x16,W
0A7A:  BNC   0A9A
0A7C:  MOVF   x12,W
0A7E:  SUBWF  x16,F
0A80:  MOVF   x13,W
0A82:  BTFSS  FD8.0
0A84:  INCFSZ x13,W
0A86:  SUBWF  x17,F
0A88:  MOVF   x14,W
0A8A:  BTFSS  FD8.0
0A8C:  INCFSZ x14,W
0A8E:  SUBWF  x18,F
0A90:  MOVF   x15,W
0A92:  BTFSS  FD8.0
0A94:  INCFSZ x15,W
0A96:  SUBWF  x19,F
0A98:  BSF    FD8.0
0A9A:  RLCF   00,F
0A9C:  RLCF   01,F
0A9E:  RLCF   02,F
0AA0:  RLCF   03,F
0AA2:  DECFSZ x1A,F
0AA4:  BRA    0A52
0AA6:  MOVFF  116,FEF
0AAA:  MOVFF  117,FEC
0AAE:  MOVFF  118,FEC
0AB2:  MOVFF  119,FEC
0AB6:  MOVLB  0
0AB8:  RETURN 0
0ABA:  MOVF   FE9,W
0ABC:  MOVLB  1
0ABE:  MOVWF  x06
0AC0:  MOVLW  3B
0AC2:  MOVWF  x0D
0AC4:  MOVLW  9A
0AC6:  MOVWF  x0C
0AC8:  MOVLW  CA
0ACA:  MOVWF  x0B
0ACC:  CLRF   x0A
0ACE:  MOVLW  0A
0AD0:  MOVWF  x08
0AD2:  BSF    FD8.1
0AD4:  MOVLW  01
0AD6:  MOVWF  FEA
0AD8:  MOVLW  02
0ADA:  MOVWF  FE9
0ADC:  MOVFF  105,111
0AE0:  MOVFF  104,110
0AE4:  MOVFF  103,10F
0AE8:  MOVFF  102,10E
0AEC:  MOVFF  10D,115
0AF0:  MOVFF  10C,114
0AF4:  MOVFF  10B,113
0AF8:  MOVFF  10A,112
0AFC:  MOVLB  0
0AFE:  RCALL  0A26
0B00:  MOVF   01,W
0B02:  MOVF   00,F
0B04:  BNZ   0B2C
0B06:  MOVLB  1
0B08:  MOVF   x08,W
0B0A:  XORLW  01
0B0C:  BTFSS  FD8.2
0B0E:  BRA    0B14
0B10:  MOVLB  0
0B12:  BRA    0B2C
0B14:  MOVF   x06,W
0B16:  BZ    0B30
0B18:  ANDLW  0F
0B1A:  SUBWF  x08,W
0B1C:  BZ    0B20
0B1E:  BC    0B3E
0B20:  BTFSC  x06.7
0B22:  BRA    0B3E
0B24:  BTFSC  x06.6
0B26:  BRA    0B30
0B28:  MOVLW  20
0B2A:  BRA    0B32
0B2C:  MOVLB  1
0B2E:  CLRF   x06
0B30:  MOVLW  30
0B32:  ADDWF  00,F
0B34:  MOVFF  00,10E
0B38:  MOVLB  0
0B3A:  RCALL  0996
0B3C:  MOVLB  1
0B3E:  BCF    FD8.1
0B40:  MOVFF  10D,111
0B44:  MOVFF  10C,110
0B48:  MOVFF  10B,10F
0B4C:  MOVFF  10A,10E
0B50:  CLRF   x15
0B52:  CLRF   x14
0B54:  CLRF   x13
0B56:  MOVLW  0A
0B58:  MOVWF  x12
0B5A:  MOVLB  0
0B5C:  RCALL  0A26
0B5E:  MOVFF  03,10D
0B62:  MOVFF  02,10C
0B66:  MOVFF  01,10B
0B6A:  MOVFF  00,10A
0B6E:  MOVLB  1
0B70:  DECFSZ x08,F
0B72:  BRA    0AD2
0B74:  MOVLB  0
0B76:  RETURN 0
0B78:  MOVF   xB8,W
0B7A:  MULWF  xBA
0B7C:  MOVFF  FF3,00
0B80:  MOVFF  FF4,01
0B84:  CLRF   02
0B86:  CLRF   03
0B88:  MULWF  xBB
0B8A:  MOVF   FF3,W
0B8C:  ADDWF  01,F
0B8E:  MOVF   FF4,W
0B90:  ADDWFC 02,F
0B92:  MOVLW  00
0B94:  ADDWFC 03,F
0B96:  MOVF   xB9,W
0B98:  MULWF  xBA
0B9A:  MOVF   FF3,W
0B9C:  ADDWF  01,F
0B9E:  MOVF   FF4,W
0BA0:  ADDWFC 02,F
0BA2:  MOVLW  00
0BA4:  ADDWFC 03,F
0BA6:  MOVF   xB9,W
0BA8:  MULWF  xBB
0BAA:  MOVF   FF3,W
0BAC:  ADDWF  02,F
0BAE:  MOVF   FF4,W
0BB0:  ADDWFC 03,F
0BB2:  RETURN 0
0BB4:  MOVFF  FEA,CB
0BB8:  MOVFF  FE9,CA
0BBC:  SWAPF  xC4,W
0BBE:  IORLW  F0
0BC0:  MOVWF  xC6
0BC2:  ADDWF  xC6,F
0BC4:  ADDLW  E2
0BC6:  MOVWF  xC7
0BC8:  ADDLW  32
0BCA:  MOVWF  xC9
0BCC:  MOVF   xC4,W
0BCE:  ANDLW  0F
0BD0:  ADDWF  xC7,F
0BD2:  ADDWF  xC7,F
0BD4:  ADDWF  xC9,F
0BD6:  ADDLW  E9
0BD8:  MOVWF  xC8
0BDA:  ADDWF  xC8,F
0BDC:  ADDWF  xC8,F
0BDE:  SWAPF  xC3,W
0BE0:  ANDLW  0F
0BE2:  ADDWF  xC8,F
0BE4:  ADDWF  xC9,F
0BE6:  RLCF   xC8,F
0BE8:  RLCF   xC9,F
0BEA:  COMF   xC9,F
0BEC:  RLCF   xC9,F
0BEE:  MOVF   xC3,W
0BF0:  ANDLW  0F
0BF2:  ADDWF  xC9,F
0BF4:  RLCF   xC6,F
0BF6:  MOVLW  07
0BF8:  MOVWF  xC5
0BFA:  MOVLW  0A
0BFC:  DECF   xC8,F
0BFE:  ADDWF  xC9,F
0C00:  BNC   0BFC
0C02:  DECF   xC7,F
0C04:  ADDWF  xC8,F
0C06:  BNC   0C02
0C08:  DECF   xC6,F
0C0A:  ADDWF  xC7,F
0C0C:  BNC   0C08
0C0E:  DECF   xC5,F
0C10:  ADDWF  xC6,F
0C12:  BNC   0C0E
0C14:  CLRF   FEA
0C16:  MOVLW  C5
0C18:  MOVWF  FE9
0C1A:  MOVLW  07
0C1C:  ANDWF  xCA,W
0C1E:  BCF    xCA.6
0C20:  ADDWF  FE9,F
0C22:  MOVLW  00
0C24:  ADDWFC FEA,F
0C26:  MOVF   FE9,W
0C28:  SUBLW  C9
0C2A:  BNZ   0C32
0C2C:  MOVF   FEA,F
0C2E:  BNZ   0C32
0C30:  BSF    xCA.6
0C32:  MOVF   FEF,W
0C34:  MOVWF  00
0C36:  BNZ   0C48
0C38:  BTFSC  xCA.6
0C3A:  BRA    0C48
0C3C:  BTFSC  xCA.4
0C3E:  BRA    0C66
0C40:  BTFSC  xCA.3
0C42:  BRA    0C48
0C44:  MOVLW  20
0C46:  BRA    0C4E
0C48:  BSF    xCA.3
0C4A:  BCF    xCA.4
0C4C:  MOVLW  30
0C4E:  ADDWF  00,F
0C50:  MOVFF  FEA,C4
0C54:  MOVFF  FE9,C3
0C58:  MOVFF  00,10E
0C5C:  RCALL  0996
0C5E:  MOVFF  C4,FEA
0C62:  MOVFF  C3,FE9
0C66:  MOVF   FEE,W
0C68:  BTFSS  xCA.6
0C6A:  BRA    0C26
0C6C:  RETURN 0
0C6E:  MOVLB  1
0C70:  MOVF   x05,W
0C72:  CLRF   01
0C74:  SUBWF  x04,W
0C76:  BC    0C7E
0C78:  MOVFF  104,00
0C7C:  BRA    0C96
0C7E:  CLRF   00
0C80:  MOVLW  08
0C82:  MOVWF  x06
0C84:  RLCF   x04,F
0C86:  RLCF   00,F
0C88:  MOVF   x05,W
0C8A:  SUBWF  00,W
0C8C:  BTFSC  FD8.0
0C8E:  MOVWF  00
0C90:  RLCF   01,F
0C92:  DECFSZ x06,F
0C94:  BRA    0C84
0C96:  MOVLB  0
0C98:  RETURN 0
0C9A:  MOVF   01,W
0C9C:  MOVFF  B5,104
0CA0:  MOVLW  64
0CA2:  MOVLB  1
0CA4:  MOVWF  x05
0CA6:  MOVLB  0
0CA8:  RCALL  0C6E
0CAA:  MOVFF  00,B5
0CAE:  MOVF   01,W
0CB0:  MOVLW  30
0CB2:  BNZ   0CC2
0CB4:  BTFSS  xB6.1
0CB6:  BRA    0CD0
0CB8:  BTFSC  xB6.3
0CBA:  BRA    0CD0
0CBC:  BTFSC  xB6.4
0CBE:  MOVLW  20
0CC0:  BRA    0CC8
0CC2:  BCF    xB6.3
0CC4:  BCF    xB6.4
0CC6:  BSF    xB6.0
0CC8:  ADDWF  01,F
0CCA:  MOVFF  01,10E
0CCE:  RCALL  0996
0CD0:  MOVFF  B5,104
0CD4:  MOVLW  0A
0CD6:  MOVLB  1
0CD8:  MOVWF  x05
0CDA:  MOVLB  0
0CDC:  RCALL  0C6E
0CDE:  MOVFF  00,B5
0CE2:  MOVF   01,W
0CE4:  MOVLW  30
0CE6:  BNZ   0CF4
0CE8:  BTFSC  xB6.3
0CEA:  BRA    0CFC
0CEC:  BTFSS  xB6.0
0CEE:  BRA    0CFC
0CF0:  BTFSC  xB6.4
0CF2:  MOVLW  20
0CF4:  ADDWF  01,F
0CF6:  MOVFF  01,10E
0CFA:  RCALL  0996
0CFC:  MOVLW  30
0CFE:  ADDWF  xB5,F
0D00:  MOVFF  B5,10E
0D04:  RCALL  0996
0D06:  RETURN 0
*
141C:  TBLRD*+
141E:  MOVF   FF5,F
1420:  BZ    143A
1422:  MOVFF  FF6,FE
1426:  MOVFF  FF7,FF
142A:  MOVFF  FF5,100
142E:  RCALL  13BA
1430:  MOVFF  FE,FF6
1434:  MOVFF  FF,FF7
1438:  BRA    141C
143A:  RETURN 0
*
149E:  TBLRD*+
14A0:  MOVF   FF5,F
14A2:  BZ    14BC
14A4:  MOVFF  FF6,FE
14A8:  MOVFF  FF7,FF
14AC:  MOVFF  FF5,100
14B0:  RCALL  143C
14B2:  MOVFF  FE,FF6
14B6:  MOVFF  FF,FF7
14BA:  BRA    149E
14BC:  RETURN 0
*
14D2:  TSTFSZ 01
14D4:  BRA    14DC
14D6:  TSTFSZ 02
14D8:  BRA    14DE
14DA:  BRA    14EA
14DC:  INCF   02,F
14DE:  MOVFF  00,FEE
14E2:  DECFSZ 01,F
14E4:  BRA    14DE
14E6:  DECFSZ 02,F
14E8:  BRA    14DE
14EA:  GOTO   16B0 (RETURN)
*
151E:  MOVLB  1
1520:  CLRF   x08
1522:  CLRF   x09
1524:  MOVLW  01
1526:  MOVWF  x0A
1528:  CLRF   FDA
152A:  CLRF   FD9
152C:  MOVWF  x0D
152E:  CLRF   x0C
1530:  MOVLW  01
1532:  MOVWF  FEA
1534:  MOVLW  04
1536:  MOVWF  FE9
1538:  MOVFF  10D,FE2
153C:  MOVFF  10C,FE1
1540:  MOVFF  10A,10B
1544:  BCF    FD8.0
1546:  MOVF   FE5,W
1548:  MULWF  FEE
154A:  MOVF   FF3,W
154C:  ADDWFC x08,F
154E:  MOVF   FF4,W
1550:  ADDWFC x09,F
1552:  DECFSZ x0B,F
1554:  BRA    1544
1556:  MOVFF  108,FDE
155A:  MOVFF  109,108
155E:  CLRF   x09
1560:  BTFSC  FD8.0
1562:  INCF   x09,F
1564:  INCF   x0C,F
1566:  BTFSC  FD8.2
1568:  INCF   x0D,F
156A:  INCF   x0A,F
156C:  MOVF   x0A,W
156E:  SUBLW  05
1570:  BNZ   1530
1572:  MOVLB  0
1574:  GOTO   15E4 (RETURN)
1578:  CLRF   01
157A:  CLRF   02
157C:  CLRF   00
157E:  CLRF   03
1580:  MOVLB  1
1582:  MOVF   x11,W
1584:  BNZ   158A
1586:  MOVF   x10,W
1588:  BZ    15BA
158A:  MOVLW  10
158C:  MOVWF  x12
158E:  BCF    FD8.0
1590:  RLCF   x0E,F
1592:  RLCF   x0F,F
1594:  RLCF   00,F
1596:  RLCF   03,F
1598:  MOVF   x11,W
159A:  SUBWF  03,W
159C:  BNZ   15A2
159E:  MOVF   x10,W
15A0:  SUBWF  00,W
15A2:  BNC   15B2
15A4:  MOVF   x10,W
15A6:  SUBWF  00,F
15A8:  BTFSS  FD8.0
15AA:  DECF   03,F
15AC:  MOVF   x11,W
15AE:  SUBWF  03,F
15B0:  BSF    FD8.0
15B2:  RLCF   01,F
15B4:  RLCF   02,F
15B6:  DECFSZ x12,F
15B8:  BRA    158E
15BA:  MOVLB  0
15BC:  RETURN 0
*
162E:  TBLRD*+
1630:  MOVFF  FF6,103
1634:  MOVFF  FF7,104
1638:  MOVFF  FF5,10E
163C:  CALL   0996
1640:  MOVFF  103,FF6
1644:  MOVFF  104,FF7
1648:  MOVLB  1
164A:  DECFSZ x02,F
164C:  BRA    1650
164E:  BRA    1654
1650:  MOVLB  0
1652:  BRA    162E
1654:  MOVLB  0
1656:  RETURN 0
*
1742:  MOVF   01,W
1744:  MOVFF  AF,104
1748:  MOVLW  64
174A:  MOVLB  1
174C:  MOVWF  x05
174E:  MOVLB  0
1750:  CALL   0C6E
1754:  MOVFF  00,AF
1758:  MOVF   01,W
175A:  MOVLW  30
175C:  BNZ   176C
175E:  BTFSS  xB0.1
1760:  BRA    177A
1762:  BTFSC  xB0.3
1764:  BRA    177A
1766:  BTFSC  xB0.4
1768:  MOVLW  20
176A:  BRA    1772
176C:  BCF    xB0.3
176E:  BCF    xB0.4
1770:  BSF    xB0.0
1772:  ADDWF  01,F
1774:  MOVFF  01,100
1778:  RCALL  13BA
177A:  MOVFF  AF,104
177E:  MOVLW  0A
1780:  MOVLB  1
1782:  MOVWF  x05
1784:  MOVLB  0
1786:  CALL   0C6E
178A:  MOVFF  00,AF
178E:  MOVF   01,W
1790:  MOVLW  30
1792:  BNZ   17A0
1794:  BTFSC  xB0.3
1796:  BRA    17A8
1798:  BTFSS  xB0.0
179A:  BRA    17A8
179C:  BTFSC  xB0.4
179E:  MOVLW  20
17A0:  ADDWF  01,F
17A2:  MOVFF  01,100
17A6:  RCALL  13BA
17A8:  MOVLW  30
17AA:  ADDWF  xAF,F
17AC:  MOVFF  AF,100
17B0:  RCALL  13BA
17B2:  GOTO   3986 (RETURN)
17B6:  MOVF   01,W
17B8:  MOVFF  AF,104
17BC:  MOVLW  64
17BE:  MOVLB  1
17C0:  MOVWF  x05
17C2:  MOVLB  0
17C4:  CALL   0C6E
17C8:  MOVFF  00,AF
17CC:  MOVF   01,W
17CE:  MOVLW  30
17D0:  BNZ   17E0
17D2:  BTFSS  xB0.1
17D4:  BRA    17EE
17D6:  BTFSC  xB0.3
17D8:  BRA    17EE
17DA:  BTFSC  xB0.4
17DC:  MOVLW  20
17DE:  BRA    17E6
17E0:  BCF    xB0.3
17E2:  BCF    xB0.4
17E4:  BSF    xB0.0
17E6:  ADDWF  01,F
17E8:  MOVFF  01,100
17EC:  RCALL  143C
17EE:  MOVFF  AF,104
17F2:  MOVLW  0A
17F4:  MOVLB  1
17F6:  MOVWF  x05
17F8:  MOVLB  0
17FA:  CALL   0C6E
17FE:  MOVFF  00,AF
1802:  MOVF   01,W
1804:  MOVLW  30
1806:  BNZ   1814
1808:  BTFSC  xB0.3
180A:  BRA    181C
180C:  BTFSS  xB0.0
180E:  BRA    181C
1810:  BTFSC  xB0.4
1812:  MOVLW  20
1814:  ADDWF  01,F
1816:  MOVFF  01,100
181A:  RCALL  143C
181C:  MOVLW  30
181E:  ADDWF  xAF,F
1820:  MOVFF  AF,100
1824:  RCALL  143C
1826:  GOTO   39D2 (RETURN)
182A:  MOVLW  8E
182C:  MOVWF  00
182E:  MOVLB  1
1830:  MOVF   x00,W
1832:  SUBWF  00,F
1834:  MOVFF  101,02
1838:  MOVFF  102,01
183C:  BSF    02.7
183E:  MOVF   00,F
1840:  BZ    1854
1842:  BCF    FD8.0
1844:  MOVF   02,F
1846:  BNZ   184C
1848:  MOVF   01,F
184A:  BZ    1854
184C:  RRCF   02,F
184E:  RRCF   01,F
1850:  DECFSZ 00,F
1852:  BRA    1842
1854:  BTFSS  x01.7
1856:  BRA    1862
1858:  COMF   01,F
185A:  COMF   02,F
185C:  INCF   01,F
185E:  BTFSC  FD8.2
1860:  INCF   02,F
1862:  MOVLB  0
1864:  RETURN 0
1866:  MOVLB  1
1868:  MOVF   x0E,W
186A:  MULWF  x10
186C:  MOVFF  FF3,01
1870:  MOVFF  FF4,00
1874:  MULWF  x11
1876:  MOVF   FF3,W
1878:  ADDWF  00,F
187A:  MOVF   x0F,W
187C:  MULWF  x10
187E:  MOVF   FF3,W
1880:  ADDWFC 00,W
1882:  MOVWF  02
1884:  MOVLB  0
1886:  RETURN 0
1888:  MOVLW  8E
188A:  MOVWF  00
188C:  MOVFF  101,01
1890:  MOVFF  100,02
1894:  CLRF   03
1896:  MOVF   01,F
1898:  BNZ   18AC
189A:  MOVFF  02,01
189E:  CLRF   02
18A0:  MOVLW  08
18A2:  SUBWF  00,F
18A4:  MOVF   01,F
18A6:  BNZ   18AC
18A8:  CLRF   00
18AA:  BRA    18BC
18AC:  BCF    FD8.0
18AE:  BTFSC  01.7
18B0:  BRA    18BA
18B2:  RLCF   02,F
18B4:  RLCF   01,F
18B6:  DECF   00,F
18B8:  BRA    18AC
18BA:  BCF    01.7
18BC:  RETURN 0
18BE:  MOVLB  1
18C0:  MOVF   x0D,W
18C2:  BTFSC  FD8.2
18C4:  BRA    19A8
18C6:  MOVWF  00
18C8:  MOVF   x11,W
18CA:  BTFSC  FD8.2
18CC:  BRA    19A8
18CE:  ADDWF  00,F
18D0:  BNC   18DA
18D2:  MOVLW  81
18D4:  ADDWF  00,F
18D6:  BC    19A8
18D8:  BRA    18E2
18DA:  MOVLW  7F
18DC:  SUBWF  00,F
18DE:  BNC   19A8
18E0:  BZ    19A8
18E2:  MOVFF  10E,115
18E6:  MOVF   x12,W
18E8:  XORWF  x15,F
18EA:  BSF    x0E.7
18EC:  BSF    x12.7
18EE:  MOVF   x10,W
18F0:  MULWF  x14
18F2:  MOVFF  FF4,117
18F6:  MOVF   x0F,W
18F8:  MULWF  x13
18FA:  MOVFF  FF4,03
18FE:  MOVFF  FF3,116
1902:  MULWF  x14
1904:  MOVF   FF3,W
1906:  ADDWF  x17,F
1908:  MOVF   FF4,W
190A:  ADDWFC x16,F
190C:  MOVLW  00
190E:  ADDWFC 03,F
1910:  MOVF   x10,W
1912:  MULWF  x13
1914:  MOVF   FF3,W
1916:  ADDWF  x17,F
1918:  MOVF   FF4,W
191A:  ADDWFC x16,F
191C:  MOVLW  00
191E:  CLRF   02
1920:  ADDWFC 03,F
1922:  ADDWFC 02,F
1924:  MOVF   x0E,W
1926:  MULWF  x14
1928:  MOVF   FF3,W
192A:  ADDWF  x16,F
192C:  MOVF   FF4,W
192E:  ADDWFC 03,F
1930:  MOVLW  00
1932:  ADDWFC 02,F
1934:  MOVF   x0E,W
1936:  MULWF  x13
1938:  MOVF   FF3,W
193A:  ADDWF  03,F
193C:  MOVF   FF4,W
193E:  ADDWFC 02,F
1940:  MOVLW  00
1942:  CLRF   01
1944:  ADDWFC 01,F
1946:  MOVF   x10,W
1948:  MULWF  x12
194A:  MOVF   FF3,W
194C:  ADDWF  x16,F
194E:  MOVF   FF4,W
1950:  ADDWFC 03,F
1952:  MOVLW  00
1954:  ADDWFC 02,F
1956:  ADDWFC 01,F
1958:  MOVF   x0F,W
195A:  MULWF  x12
195C:  MOVF   FF3,W
195E:  ADDWF  03,F
1960:  MOVF   FF4,W
1962:  ADDWFC 02,F
1964:  MOVLW  00
1966:  ADDWFC 01,F
1968:  MOVF   x0E,W
196A:  MULWF  x12
196C:  MOVF   FF3,W
196E:  ADDWF  02,F
1970:  MOVF   FF4,W
1972:  ADDWFC 01,F
1974:  INCF   00,F
1976:  BTFSC  01.7
1978:  BRA    1984
197A:  RLCF   x16,F
197C:  RLCF   03,F
197E:  RLCF   02,F
1980:  RLCF   01,F
1982:  DECF   00,F
1984:  MOVLW  00
1986:  BTFSS  x16.7
1988:  BRA    199E
198A:  INCF   03,F
198C:  ADDWFC 02,F
198E:  ADDWFC 01,F
1990:  MOVF   01,W
1992:  BNZ   199E
1994:  MOVF   02,W
1996:  BNZ   199E
1998:  MOVF   03,W
199A:  BNZ   199E
199C:  INCF   00,F
199E:  BTFSC  x15.7
19A0:  BSF    01.7
19A2:  BTFSS  x15.7
19A4:  BCF    01.7
19A6:  BRA    19B0
19A8:  CLRF   00
19AA:  CLRF   01
19AC:  CLRF   02
19AE:  CLRF   03
19B0:  MOVLB  0
19B2:  RETURN 0
*
1D84:  MOVFF  FF,106
1D88:  MOVLB  1
1D8A:  MOVF   x03,W
1D8C:  XORWF  x06,F
1D8E:  BTFSS  x06.7
1D90:  BRA    1D9E
1D92:  BCF    FD8.2
1D94:  BCF    FD8.0
1D96:  MOVLB  0
1D98:  BTFSC  xFF.7
1D9A:  BSF    FD8.0
1D9C:  BRA    1E24
1D9E:  MOVFF  FF,106
1DA2:  MOVFF  102,107
1DA6:  MOVLB  0
1DA8:  MOVF   xFE,W
1DAA:  MOVLB  1
1DAC:  SUBWF  x07,F
1DAE:  BZ    1DC2
1DB0:  BTFSC  x06.7
1DB2:  BRA    1DB8
1DB4:  MOVLB  0
1DB6:  BRA    1E24
1DB8:  MOVF   FD8,W
1DBA:  XORLW  01
1DBC:  MOVWF  FD8
1DBE:  MOVLB  0
1DC0:  BRA    1E24
1DC2:  MOVFF  103,107
1DC6:  MOVLB  0
1DC8:  MOVF   xFF,W
1DCA:  MOVLB  1
1DCC:  SUBWF  x07,F
1DCE:  BZ    1DE4
1DD0:  BTFSC  x06.7
1DD2:  BRA    1DD8
1DD4:  MOVLB  0
1DD6:  BRA    1E24
1DD8:  MOVF   FD8,W
1DDA:  XORLW  01
1DDC:  MOVWF  FD8
1DDE:  MOVLB  0
1DE0:  BRA    1E24
1DE2:  MOVLB  1
1DE4:  MOVFF  104,107
1DE8:  MOVF   x00,W
1DEA:  SUBWF  x07,F
1DEC:  BZ    1E02
1DEE:  BTFSC  x06.7
1DF0:  BRA    1DF6
1DF2:  MOVLB  0
1DF4:  BRA    1E24
1DF6:  MOVF   FD8,W
1DF8:  XORLW  01
1DFA:  MOVWF  FD8
1DFC:  MOVLB  0
1DFE:  BRA    1E24
1E00:  MOVLB  1
1E02:  MOVFF  105,107
1E06:  MOVF   x01,W
1E08:  SUBWF  x07,F
1E0A:  BZ    1E20
1E0C:  BTFSC  x06.7
1E0E:  BRA    1E14
1E10:  MOVLB  0
1E12:  BRA    1E24
1E14:  MOVF   FD8,W
1E16:  XORLW  01
1E18:  MOVWF  FD8
1E1A:  MOVLB  0
1E1C:  BRA    1E24
1E1E:  MOVLB  1
1E20:  BCF    FD8.0
1E22:  MOVLB  0
1E24:  RETURN 0
1E26:  MOVLB  1
1E28:  MOVF   x02,W
1E2A:  BTFSC  FD8.2
1E2C:  BRA    1F78
1E2E:  MOVWF  x0E
1E30:  MOVF   x06,W
1E32:  BTFSC  FD8.2
1E34:  BRA    1F78
1E36:  SUBWF  x0E,F
1E38:  BNC   1E44
1E3A:  MOVLW  7F
1E3C:  ADDWF  x0E,F
1E3E:  BTFSC  FD8.0
1E40:  BRA    1F78
1E42:  BRA    1E50
1E44:  MOVLW  81
1E46:  SUBWF  x0E,F
1E48:  BTFSS  FD8.0
1E4A:  BRA    1F78
1E4C:  BTFSC  FD8.2
1E4E:  BRA    1F78
1E50:  MOVFF  10E,00
1E54:  CLRF   01
1E56:  CLRF   02
1E58:  CLRF   03
1E5A:  CLRF   x0D
1E5C:  MOVFF  103,10C
1E60:  BSF    x0C.7
1E62:  MOVFF  104,10B
1E66:  MOVFF  105,10A
1E6A:  MOVLW  19
1E6C:  MOVWF  x0E
1E6E:  MOVF   x09,W
1E70:  SUBWF  x0A,F
1E72:  BC    1E8E
1E74:  MOVLW  01
1E76:  SUBWF  x0B,F
1E78:  BC    1E8E
1E7A:  SUBWF  x0C,F
1E7C:  BC    1E8E
1E7E:  SUBWF  x0D,F
1E80:  BC    1E8E
1E82:  INCF   x0D,F
1E84:  INCF   x0C,F
1E86:  INCF   x0B,F
1E88:  MOVF   x09,W
1E8A:  ADDWF  x0A,F
1E8C:  BRA    1EDE
1E8E:  MOVF   x08,W
1E90:  SUBWF  x0B,F
1E92:  BC    1EB8
1E94:  MOVLW  01
1E96:  SUBWF  x0C,F
1E98:  BC    1EB8
1E9A:  SUBWF  x0D,F
1E9C:  BC    1EB8
1E9E:  INCF   x0D,F
1EA0:  INCF   x0C,F
1EA2:  MOVF   x08,W
1EA4:  ADDWF  x0B,F
1EA6:  MOVF   x09,W
1EA8:  ADDWF  x0A,F
1EAA:  BNC   1EDE
1EAC:  INCF   x0B,F
1EAE:  BNZ   1EDE
1EB0:  INCF   x0C,F
1EB2:  BNZ   1EDE
1EB4:  INCF   x0D,F
1EB6:  BRA    1EDE
1EB8:  MOVF   x07,W
1EBA:  IORLW  80
1EBC:  SUBWF  x0C,F
1EBE:  BC    1EDC
1EC0:  MOVLW  01
1EC2:  SUBWF  x0D,F
1EC4:  BC    1EDC
1EC6:  INCF   x0D,F
1EC8:  MOVF   x07,W
1ECA:  IORLW  80
1ECC:  ADDWF  x0C,F
1ECE:  MOVF   x08,W
1ED0:  ADDWF  x0B,F
1ED2:  BNC   1EA6
1ED4:  INCF   x0C,F
1ED6:  BNZ   1EA6
1ED8:  INCF   x0D,F
1EDA:  BRA    1EA6
1EDC:  BSF    03.0
1EDE:  DECFSZ x0E,F
1EE0:  BRA    1EE4
1EE2:  BRA    1EFA
1EE4:  BCF    FD8.0
1EE6:  RLCF   x0A,F
1EE8:  RLCF   x0B,F
1EEA:  RLCF   x0C,F
1EEC:  RLCF   x0D,F
1EEE:  BCF    FD8.0
1EF0:  RLCF   03,F
1EF2:  RLCF   02,F
1EF4:  RLCF   01,F
1EF6:  RLCF   x0F,F
1EF8:  BRA    1E6E
1EFA:  BTFSS  x0F.0
1EFC:  BRA    1F0A
1EFE:  BCF    FD8.0
1F00:  RRCF   01,F
1F02:  RRCF   02,F
1F04:  RRCF   03,F
1F06:  RRCF   x0F,F
1F08:  BRA    1F0E
1F0A:  DECF   00,F
1F0C:  BZ    1F78
1F0E:  BTFSC  x0F.7
1F10:  BRA    1F4E
1F12:  BCF    FD8.0
1F14:  RLCF   x0A,F
1F16:  RLCF   x0B,F
1F18:  RLCF   x0C,F
1F1A:  RLCF   x0D,F
1F1C:  MOVF   x09,W
1F1E:  SUBWF  x0A,F
1F20:  BC    1F30
1F22:  MOVLW  01
1F24:  SUBWF  x0B,F
1F26:  BC    1F30
1F28:  SUBWF  x0C,F
1F2A:  BC    1F30
1F2C:  SUBWF  x0D,F
1F2E:  BNC   1F64
1F30:  MOVF   x08,W
1F32:  SUBWF  x0B,F
1F34:  BC    1F40
1F36:  MOVLW  01
1F38:  SUBWF  x0C,F
1F3A:  BC    1F40
1F3C:  SUBWF  x0D,F
1F3E:  BNC   1F64
1F40:  MOVF   x07,W
1F42:  IORLW  80
1F44:  SUBWF  x0C,F
1F46:  BC    1F4E
1F48:  MOVLW  01
1F4A:  SUBWF  x0D,F
1F4C:  BNC   1F64
1F4E:  INCF   03,F
1F50:  BNZ   1F64
1F52:  INCF   02,F
1F54:  BNZ   1F64
1F56:  INCF   01,F
1F58:  BNZ   1F64
1F5A:  INCF   00,F
1F5C:  BZ    1F78
1F5E:  RRCF   01,F
1F60:  RRCF   02,F
1F62:  RRCF   03,F
1F64:  MOVFF  103,10E
1F68:  MOVF   x07,W
1F6A:  XORWF  x0E,F
1F6C:  BTFSS  x0E.7
1F6E:  BRA    1F74
1F70:  BSF    01.7
1F72:  BRA    1F80
1F74:  BCF    01.7
1F76:  BRA    1F80
1F78:  CLRF   00
1F7A:  CLRF   01
1F7C:  CLRF   02
1F7E:  CLRF   03
1F80:  MOVLB  0
1F82:  RETURN 0
*
2040:  MOVLW  80
2042:  BTFSS  FD8.1
2044:  BRA    204A
2046:  MOVLB  1
2048:  XORWF  x03,F
204A:  MOVLB  1
204C:  CLRF   x08
204E:  CLRF   x09
2050:  MOVFF  FF,107
2054:  MOVF   x03,W
2056:  XORWF  x07,F
2058:  MOVLB  0
205A:  MOVF   xFE,W
205C:  BTFSC  FD8.2
205E:  BRA    2220
2060:  MOVLB  1
2062:  MOVWF  x06
2064:  MOVWF  00
2066:  MOVF   x02,W
2068:  BTFSC  FD8.2
206A:  BRA    2234
206C:  SUBWF  x06,F
206E:  BTFSC  FD8.2
2070:  BRA    217A
2072:  BNC   20EE
2074:  MOVFF  103,10C
2078:  BSF    x0C.7
207A:  MOVFF  104,10B
207E:  MOVFF  105,10A
2082:  CLRF   x09
2084:  BCF    FD8.0
2086:  RRCF   x0C,F
2088:  RRCF   x0B,F
208A:  RRCF   x0A,F
208C:  RRCF   x09,F
208E:  DECFSZ x06,F
2090:  BRA    2082
2092:  BTFSS  x07.7
2094:  BRA    209C
2096:  BSF    x08.0
2098:  BRA    225C
209A:  BCF    x08.0
209C:  BCF    x06.0
209E:  BSF    x08.4
20A0:  MOVLW  01
20A2:  MOVWF  FEA
20A4:  MOVWF  FE9
20A6:  BRA    2282
20A8:  BCF    x08.4
20AA:  BTFSC  x07.7
20AC:  BRA    20C2
20AE:  BTFSS  x06.0
20B0:  BRA    20D8
20B2:  RRCF   x0C,F
20B4:  RRCF   x0B,F
20B6:  RRCF   x0A,F
20B8:  RRCF   x09,F
20BA:  INCF   00,F
20BC:  BTFSC  FD8.2
20BE:  BRA    2252
20C0:  BRA    20D8
20C2:  BTFSC  x0C.7
20C4:  BRA    20DE
20C6:  BCF    FD8.0
20C8:  RLCF   x09,F
20CA:  RLCF   x0A,F
20CC:  RLCF   x0B,F
20CE:  RLCF   x0C,F
20D0:  DECF   00,F
20D2:  BTFSC  FD8.2
20D4:  BRA    2252
20D6:  BRA    20C2
20D8:  BSF    x08.6
20DA:  BRA    21B8
20DC:  BCF    x08.6
20DE:  MOVFF  FF,107
20E2:  BTFSS  x07.7
20E4:  BRA    20EA
20E6:  BSF    x0C.7
20E8:  BRA    2244
20EA:  BCF    x0C.7
20EC:  BRA    2244
20EE:  MOVFF  102,106
20F2:  MOVFF  102,00
20F6:  MOVLB  0
20F8:  MOVF   xFE,W
20FA:  MOVLB  1
20FC:  SUBWF  x06,F
20FE:  MOVFF  FF,10C
2102:  BSF    x0C.7
2104:  MOVFF  100,10B
2108:  MOVFF  101,10A
210C:  CLRF   x09
210E:  BCF    FD8.0
2110:  RRCF   x0C,F
2112:  RRCF   x0B,F
2114:  RRCF   x0A,F
2116:  RRCF   x09,F
2118:  DECFSZ x06,F
211A:  BRA    210C
211C:  BTFSS  x07.7
211E:  BRA    2126
2120:  BSF    x08.1
2122:  BRA    225C
2124:  BCF    x08.1
2126:  BCF    x06.0
2128:  BSF    x08.5
212A:  MOVLW  01
212C:  MOVWF  FEA
212E:  MOVLW  05
2130:  MOVWF  FE9
2132:  BRA    2282
2134:  BCF    x08.5
2136:  BTFSC  x07.7
2138:  BRA    214E
213A:  BTFSS  x06.0
213C:  BRA    2164
213E:  RRCF   x0C,F
2140:  RRCF   x0B,F
2142:  RRCF   x0A,F
2144:  RRCF   x09,F
2146:  INCF   00,F
2148:  BTFSC  FD8.2
214A:  BRA    2252
214C:  BRA    2164
214E:  BTFSC  x0C.7
2150:  BRA    216A
2152:  BCF    FD8.0
2154:  RLCF   x09,F
2156:  RLCF   x0A,F
2158:  RLCF   x0B,F
215A:  RLCF   x0C,F
215C:  DECF   00,F
215E:  BTFSC  FD8.2
2160:  BRA    2252
2162:  BRA    214E
2164:  BSF    x08.7
2166:  BRA    21B8
2168:  BCF    x08.7
216A:  MOVFF  103,107
216E:  BTFSS  x03.7
2170:  BRA    2176
2172:  BSF    x0C.7
2174:  BRA    2244
2176:  BCF    x0C.7
2178:  BRA    2244
217A:  MOVFF  103,10C
217E:  BSF    x0C.7
2180:  MOVFF  104,10B
2184:  MOVFF  105,10A
2188:  BTFSS  x07.7
218A:  BRA    2194
218C:  BCF    x0C.7
218E:  BSF    x08.2
2190:  BRA    225C
2192:  BCF    x08.2
2194:  CLRF   x09
2196:  BCF    x06.0
2198:  MOVLW  01
219A:  MOVWF  FEA
219C:  MOVWF  FE9
219E:  BRA    2282
21A0:  BTFSC  x07.7
21A2:  BRA    21DC
21A4:  MOVFF  FF,107
21A8:  BTFSS  x06.0
21AA:  BRA    21B8
21AC:  RRCF   x0C,F
21AE:  RRCF   x0B,F
21B0:  RRCF   x0A,F
21B2:  RRCF   x09,F
21B4:  INCF   00,F
21B6:  BZ    2252
21B8:  BTFSS  x09.7
21BA:  BRA    21D2
21BC:  INCF   x0A,F
21BE:  BNZ   21D2
21C0:  INCF   x0B,F
21C2:  BNZ   21D2
21C4:  INCF   x0C,F
21C6:  BNZ   21D2
21C8:  RRCF   x0C,F
21CA:  RRCF   x0B,F
21CC:  RRCF   x0A,F
21CE:  INCF   00,F
21D0:  BZ    2252
21D2:  BTFSC  x08.6
21D4:  BRA    20DC
21D6:  BTFSC  x08.7
21D8:  BRA    2168
21DA:  BRA    2214
21DC:  MOVLW  80
21DE:  XORWF  x0C,F
21E0:  BTFSS  x0C.7
21E2:  BRA    21EC
21E4:  BRA    225C
21E6:  MOVFF  103,107
21EA:  BRA    2200
21EC:  MOVFF  FF,107
21F0:  MOVF   x0C,F
21F2:  BNZ   2200
21F4:  MOVF   x0B,F
21F6:  BNZ   2200
21F8:  MOVF   x0A,F
21FA:  BNZ   2200
21FC:  CLRF   00
21FE:  BRA    2244
2200:  BTFSC  x0C.7
2202:  BRA    2214
2204:  BCF    FD8.0
2206:  RLCF   x09,F
2208:  RLCF   x0A,F
220A:  RLCF   x0B,F
220C:  RLCF   x0C,F
220E:  DECFSZ 00,F
2210:  BRA    2200
2212:  BRA    2252
2214:  BTFSS  x07.7
2216:  BRA    221C
2218:  BSF    x0C.7
221A:  BRA    2244
221C:  BCF    x0C.7
221E:  BRA    2244
2220:  MOVFF  102,00
2224:  MOVFF  103,10C
2228:  MOVFF  104,10B
222C:  MOVFF  105,10A
2230:  MOVLB  1
2232:  BRA    2244
2234:  MOVFF  FE,00
2238:  MOVFF  FF,10C
223C:  MOVFF  100,10B
2240:  MOVFF  101,10A
2244:  MOVFF  10C,01
2248:  MOVFF  10B,02
224C:  MOVFF  10A,03
2250:  BRA    22BA
2252:  CLRF   00
2254:  CLRF   01
2256:  CLRF   02
2258:  CLRF   03
225A:  BRA    22BA
225C:  CLRF   x09
225E:  COMF   x0A,F
2260:  COMF   x0B,F
2262:  COMF   x0C,F
2264:  COMF   x09,F
2266:  INCF   x09,F
2268:  BNZ   2274
226A:  INCF   x0A,F
226C:  BNZ   2274
226E:  INCF   x0B,F
2270:  BNZ   2274
2272:  INCF   x0C,F
2274:  BTFSC  x08.0
2276:  BRA    209A
2278:  BTFSC  x08.1
227A:  BRA    2124
227C:  BTFSC  x08.2
227E:  BRA    2192
2280:  BRA    21E6
2282:  MOVF   FEF,W
2284:  ADDWF  x0A,F
2286:  BNC   2292
2288:  INCF   x0B,F
228A:  BNZ   2292
228C:  INCF   x0C,F
228E:  BTFSC  FD8.2
2290:  BSF    x06.0
2292:  MOVF   FED,F
2294:  MOVF   FEF,W
2296:  ADDWF  x0B,F
2298:  BNC   22A0
229A:  INCF   x0C,F
229C:  BTFSC  FD8.2
229E:  BSF    x06.0
22A0:  MOVF   FED,F
22A2:  MOVF   FEF,W
22A4:  BTFSC  FEF.7
22A6:  BRA    22AA
22A8:  XORLW  80
22AA:  ADDWF  x0C,F
22AC:  BTFSC  FD8.0
22AE:  BSF    x06.0
22B0:  BTFSC  x08.4
22B2:  BRA    20A8
22B4:  BTFSC  x08.5
22B6:  BRA    2134
22B8:  BRA    21A0
22BA:  MOVLB  0
22BC:  RETURN 0
22BE:  MOVFF  AE,FEA
22C2:  MOVFF  AD,FE9
22C6:  MOVLB  1
22C8:  MOVFF  10B,FEF
22CC:  INCF   FE9,F
22CE:  BTFSC  FD8.2
22D0:  INCF   FEA,F
22D2:  CLRF   FEF
22D4:  MOVLB  0
22D6:  INCF   xAD,F
22D8:  BTFSC  FD8.2
22DA:  INCF   xAE,F
22DC:  RETURN 0
22DE:  MOVFF  FEA,10A
22E2:  MOVFF  FE9,109
22E6:  MOVLB  1
22E8:  SWAPF  x03,W
22EA:  IORLW  F0
22EC:  MOVWF  x05
22EE:  ADDWF  x05,F
22F0:  ADDLW  E2
22F2:  MOVWF  x06
22F4:  ADDLW  32
22F6:  MOVWF  x08
22F8:  MOVF   x03,W
22FA:  ANDLW  0F
22FC:  ADDWF  x06,F
22FE:  ADDWF  x06,F
2300:  ADDWF  x08,F
2302:  ADDLW  E9
2304:  MOVWF  x07
2306:  ADDWF  x07,F
2308:  ADDWF  x07,F
230A:  SWAPF  x02,W
230C:  ANDLW  0F
230E:  ADDWF  x07,F
2310:  ADDWF  x08,F
2312:  RLCF   x07,F
2314:  RLCF   x08,F
2316:  COMF   x08,F
2318:  RLCF   x08,F
231A:  MOVF   x02,W
231C:  ANDLW  0F
231E:  ADDWF  x08,F
2320:  RLCF   x05,F
2322:  MOVLW  07
2324:  MOVWF  x04
2326:  MOVLW  0A
2328:  DECF   x07,F
232A:  ADDWF  x08,F
232C:  BNC   2328
232E:  DECF   x06,F
2330:  ADDWF  x07,F
2332:  BNC   232E
2334:  DECF   x05,F
2336:  ADDWF  x06,F
2338:  BNC   2334
233A:  DECF   x04,F
233C:  ADDWF  x05,F
233E:  BNC   233A
2340:  MOVLW  01
2342:  MOVWF  FEA
2344:  MOVLW  04
2346:  MOVWF  FE9
2348:  MOVLW  07
234A:  ANDWF  x09,W
234C:  BCF    x09.6
234E:  ADDWF  FE9,F
2350:  MOVLW  00
2352:  ADDWFC FEA,F
2354:  MOVF   FE9,W
2356:  SUBLW  08
2358:  BNZ   2360
235A:  DECFSZ FEA,W
235C:  BRA    2360
235E:  BSF    x09.6
2360:  MOVF   FEF,W
2362:  MOVWF  00
2364:  BNZ   2376
2366:  BTFSC  x09.6
2368:  BRA    2376
236A:  BTFSC  x09.4
236C:  BRA    2398
236E:  BTFSC  x09.3
2370:  BRA    2376
2372:  MOVLW  20
2374:  BRA    237C
2376:  BSF    x09.3
2378:  BCF    x09.4
237A:  MOVLW  30
237C:  ADDWF  00,F
237E:  MOVFF  FEA,103
2382:  MOVFF  FE9,102
2386:  MOVFF  00,10B
238A:  MOVLB  0
238C:  RCALL  22BE
238E:  MOVFF  103,FEA
2392:  MOVFF  102,FE9
2396:  MOVLB  1
2398:  MOVF   FEE,W
239A:  BTFSS  x09.6
239C:  BRA    2354
239E:  MOVLB  0
23A0:  RETURN 0
23A2:  MOVF   01,W
23A4:  MOVFF  102,104
23A8:  MOVLW  64
23AA:  MOVLB  1
23AC:  MOVWF  x05
23AE:  MOVLB  0
23B0:  CALL   0C6E
23B4:  MOVFF  00,102
23B8:  MOVF   01,W
23BA:  MOVLW  30
23BC:  BNZ   23CE
23BE:  MOVLB  1
23C0:  BTFSS  x03.1
23C2:  BRA    23E2
23C4:  BTFSC  x03.3
23C6:  BRA    23E2
23C8:  BTFSC  x03.4
23CA:  MOVLW  20
23CC:  BRA    23D6
23CE:  MOVLB  1
23D0:  BCF    x03.3
23D2:  BCF    x03.4
23D4:  BSF    x03.0
23D6:  ADDWF  01,F
23D8:  MOVFF  01,10B
23DC:  MOVLB  0
23DE:  RCALL  22BE
23E0:  MOVLB  1
23E2:  MOVFF  102,104
23E6:  MOVLW  0A
23E8:  MOVWF  x05
23EA:  MOVLB  0
23EC:  CALL   0C6E
23F0:  MOVFF  00,102
23F4:  MOVF   01,W
23F6:  MOVLW  30
23F8:  BNZ   240A
23FA:  MOVLB  1
23FC:  BTFSC  x03.3
23FE:  BRA    2414
2400:  BTFSS  x03.0
2402:  BRA    2414
2404:  BTFSC  x03.4
2406:  MOVLW  20
2408:  MOVLB  0
240A:  ADDWF  01,F
240C:  MOVFF  01,10B
2410:  RCALL  22BE
2412:  MOVLB  1
2414:  MOVLW  30
2416:  ADDWF  x02,F
2418:  MOVFF  102,10B
241C:  MOVLB  0
241E:  RCALL  22BE
2420:  RETURN 0
2422:  MOVF   FEF,F
2424:  BZ    2446
2426:  MOVFF  FEA,FF
242A:  MOVFF  FE9,FE
242E:  MOVFF  FEF,100
2432:  CALL   13BA
2436:  MOVFF  FF,FEA
243A:  MOVFF  FE,FE9
243E:  INCF   FE9,F
2440:  BTFSC  FD8.2
2442:  INCF   FEA,F
2444:  BRA    2422
2446:  GOTO   31F2 (RETURN)
244A:  MOVF   FEF,F
244C:  BZ    246E
244E:  MOVFF  FEA,FF
2452:  MOVFF  FE9,FE
2456:  MOVFF  FEF,100
245A:  CALL   143C
245E:  MOVFF  FF,FEA
2462:  MOVFF  FE,FE9
2466:  INCF   FE9,F
2468:  BTFSC  FD8.2
246A:  INCF   FEA,F
246C:  BRA    244A
246E:  GOTO   331A (RETURN)
2472:  MOVLB  1
2474:  MOVF   x0D,W
2476:  SUBLW  B6
2478:  MOVWF  x0D
247A:  CLRF   03
247C:  MOVFF  10E,111
2480:  BSF    x0E.7
2482:  BCF    FD8.0
2484:  RRCF   x0E,F
2486:  RRCF   x0F,F
2488:  RRCF   x10,F
248A:  RRCF   03,F
248C:  RRCF   02,F
248E:  RRCF   01,F
2490:  RRCF   00,F
2492:  DECFSZ x0D,F
2494:  BRA    2482
2496:  BTFSS  x11.7
2498:  BRA    24B0
249A:  COMF   00,F
249C:  COMF   01,F
249E:  COMF   02,F
24A0:  COMF   03,F
24A2:  INCF   00,F
24A4:  BTFSC  FD8.2
24A6:  INCF   01,F
24A8:  BTFSC  FD8.2
24AA:  INCF   02,F
24AC:  BTFSC  FD8.2
24AE:  INCF   03,F
24B0:  MOVLB  0
24B2:  RETURN 0
24B4:  MOVF   FE9,W
24B6:  MOVLB  1
24B8:  MOVWF  x03
24BA:  MOVF   x02,W
24BC:  MOVWF  x05
24BE:  BZ    24F8
24C0:  MOVFF  101,110
24C4:  MOVFF  100,10F
24C8:  MOVFF  FF,10E
24CC:  MOVFF  FE,10D
24D0:  CLRF   x14
24D2:  CLRF   x13
24D4:  MOVLW  20
24D6:  MOVWF  x12
24D8:  MOVLW  82
24DA:  MOVWF  x11
24DC:  MOVLB  0
24DE:  CALL   18BE
24E2:  MOVFF  03,101
24E6:  MOVFF  02,100
24EA:  MOVFF  01,FF
24EE:  MOVFF  00,FE
24F2:  MOVLB  1
24F4:  DECFSZ x05,F
24F6:  BRA    24C0
24F8:  MOVFF  101,110
24FC:  MOVFF  100,10F
2500:  MOVFF  FF,10E
2504:  MOVFF  FE,10D
2508:  MOVLB  0
250A:  RCALL  2472
250C:  MOVFF  03,101
2510:  MOVFF  02,100
2514:  MOVFF  01,FF
2518:  MOVFF  00,FE
251C:  MOVLB  1
251E:  BTFSS  x01.7
2520:  BRA    254E
2522:  DECF   x03,F
2524:  BSF    x03.5
2526:  MOVLB  0
2528:  COMF   xFE,F
252A:  COMF   xFF,F
252C:  MOVLB  1
252E:  COMF   x00,F
2530:  COMF   x01,F
2532:  MOVLB  0
2534:  INCF   xFE,F
2536:  BTFSC  FD8.2
2538:  INCF   xFF,F
253A:  BTFSS  FD8.2
253C:  BRA    2544
253E:  MOVLB  1
2540:  INCF   x00,F
2542:  MOVLB  0
2544:  BTFSS  FD8.2
2546:  BRA    254C
2548:  MOVLB  1
254A:  INCF   x01,F
254C:  MOVLB  1
254E:  MOVLW  3B
2550:  MOVWF  x0A
2552:  MOVLW  9A
2554:  MOVWF  x09
2556:  MOVLW  CA
2558:  MOVWF  x08
255A:  CLRF   x07
255C:  MOVLW  0A
255E:  MOVWF  x05
2560:  MOVF   x02,W
2562:  BTFSC  FD8.2
2564:  INCF   x03,F
2566:  BSF    FD8.1
2568:  CLRF   FEA
256A:  MOVLW  FE
256C:  MOVWF  FE9
256E:  MOVFF  101,111
2572:  MOVFF  100,110
2576:  MOVFF  FF,10F
257A:  MOVFF  FE,10E
257E:  MOVFF  10A,115
2582:  MOVFF  109,114
2586:  MOVFF  108,113
258A:  MOVFF  107,112
258E:  MOVLB  0
2590:  CALL   0A26
2594:  MOVF   01,W
2596:  MOVF   00,F
2598:  BNZ   25C0
259A:  MOVLB  1
259C:  INCF   x02,W
259E:  SUBWF  x05,W
25A0:  BTFSS  FD8.2
25A2:  BRA    25A8
25A4:  MOVLB  0
25A6:  BRA    25C0
25A8:  MOVF   x03,W
25AA:  BZ    25C6
25AC:  ANDLW  0F
25AE:  SUBWF  x05,W
25B0:  BZ    25B4
25B2:  BC    263C
25B4:  BTFSC  x03.7
25B6:  BRA    263C
25B8:  BTFSC  x03.6
25BA:  BRA    25C6
25BC:  MOVLW  20
25BE:  BRA    262E
25C0:  MOVLW  20
25C2:  MOVLB  1
25C4:  ANDWF  x03,F
25C6:  BTFSS  x03.5
25C8:  BRA    25E8
25CA:  BCF    x03.5
25CC:  MOVF   x02,W
25CE:  BTFSS  FD8.2
25D0:  DECF   x03,F
25D2:  MOVF   00,W
25D4:  MOVWF  x03
25D6:  MOVLW  2D
25D8:  MOVWF  x0E
25DA:  MOVLB  0
25DC:  CALL   0996
25E0:  MOVLB  1
25E2:  MOVF   x03,W
25E4:  MOVWF  00
25E6:  CLRF   x03
25E8:  MOVF   x02,W
25EA:  SUBWF  x05,W
25EC:  BNZ   2608
25EE:  MOVF   00,W
25F0:  MOVWF  x03
25F2:  MOVLW  2E
25F4:  MOVWF  x0E
25F6:  MOVLB  0
25F8:  CALL   0996
25FC:  MOVLB  1
25FE:  MOVF   x03,W
2600:  MOVWF  00
2602:  MOVLW  20
2604:  ANDWF  x03,F
2606:  MOVLW  00
2608:  MOVLW  30
260A:  BTFSS  x03.5
260C:  BRA    262E
260E:  BCF    x03.5
2610:  MOVF   x02,W
2612:  BTFSS  FD8.2
2614:  DECF   x03,F
2616:  MOVF   00,W
2618:  MOVWF  x03
261A:  MOVLW  2D
261C:  MOVWF  x0E
261E:  MOVLB  0
2620:  CALL   0996
2624:  MOVLB  1
2626:  MOVF   x03,W
2628:  MOVWF  00
262A:  CLRF   x03
262C:  MOVLW  30
262E:  ADDWF  00,F
2630:  MOVFF  00,10E
2634:  MOVLB  0
2636:  CALL   0996
263A:  MOVLB  1
263C:  BCF    FD8.1
263E:  MOVFF  10A,111
2642:  MOVFF  109,110
2646:  MOVFF  108,10F
264A:  MOVFF  107,10E
264E:  CLRF   x15
2650:  CLRF   x14
2652:  CLRF   x13
2654:  MOVLW  0A
2656:  MOVWF  x12
2658:  MOVLB  0
265A:  CALL   0A26
265E:  MOVFF  03,10A
2662:  MOVFF  02,109
2666:  MOVFF  01,108
266A:  MOVFF  00,107
266E:  MOVLB  1
2670:  DECFSZ x05,F
2672:  BRA    2566
2674:  MOVLB  0
2676:  RETURN 0
*
3BC0:  MOVF   xB5,W
3BC2:  ANDLW  07
3BC4:  MOVWF  00
3BC6:  RRCF   xB5,W
3BC8:  MOVWF  01
3BCA:  RRCF   01,F
3BCC:  RRCF   01,F
3BCE:  MOVLW  1F
3BD0:  ANDWF  01,F
3BD2:  MOVF   01,W
3BD4:  ADDWF  xB6,W
3BD6:  MOVWF  FE9
3BD8:  MOVLW  00
3BDA:  ADDWFC xB7,W
3BDC:  MOVWF  FEA
3BDE:  MOVFF  FEF,01
3BE2:  INCF   00,F
3BE4:  BRA    3BE8
3BE6:  RRCF   01,F
3BE8:  DECFSZ 00,F
3BEA:  BRA    3BE6
3BEC:  RETURN 0
*
3F06:  MOVFF  FF2,0D
3F0A:  BCF    FF2.6
3F0C:  BCF    FF2.7
3F0E:  ADDWF  FE8,W
3F10:  CLRF   FF7
3F12:  RLCF   FF7,F
3F14:  ADDLW  31
3F16:  MOVWF  FF6
3F18:  MOVLW  3F
3F1A:  ADDWFC FF7,F
3F1C:  TBLRD*-
3F1E:  MOVF   FF5,W
3F20:  MOVWF  FFA
3F22:  TBLRD*
3F24:  MOVF   FF5,W
3F26:  BTFSC  0D.6
3F28:  BSF    FF2.6
3F2A:  BTFSC  0D.7
3F2C:  BSF    FF2.7
3F2E:  MOVWF  FF9
3F30:  DATA 1A,3E
3F32:  DATA 34,3E
3F34:  DATA 4E,3E
3F36:  DATA 68,3E
3F38:  DATA 82,3E
3F3A:  DATA 9C,3E
3F3C:  DATA B6,3E
3F3E:  DATA D0,3E
3F40:  DATA EA,3E
*
4EE2:  MOVLW  20
4EE4:  BTFSS  xB6.4
4EE6:  MOVLW  30
4EE8:  MOVWF  xB7
4EEA:  MOVFF  B5,00
4EEE:  BTFSS  xB5.7
4EF0:  BRA    4F02
4EF2:  COMF   00,F
4EF4:  INCF   00,F
4EF6:  MOVFF  00,B5
4EFA:  MOVLW  2D
4EFC:  MOVWF  xB7
4EFE:  BSF    xB6.7
4F00:  BSF    xB6.0
4F02:  MOVF   01,W
4F04:  MOVFF  B5,104
4F08:  MOVLW  64
4F0A:  MOVLB  1
4F0C:  MOVWF  x05
4F0E:  MOVLB  0
4F10:  CALL   0C6E
4F14:  MOVFF  00,B5
4F18:  MOVLW  30
4F1A:  ADDWF  01,W
4F1C:  MOVWF  xB8
4F1E:  MOVFF  B5,104
4F22:  MOVLW  0A
4F24:  MOVLB  1
4F26:  MOVWF  x05
4F28:  MOVLB  0
4F2A:  CALL   0C6E
4F2E:  MOVLW  30
4F30:  ADDWF  00,W
4F32:  MOVWF  xBA
4F34:  MOVLW  30
4F36:  ADDWF  01,W
4F38:  MOVWF  xB9
4F3A:  MOVFF  B7,00
4F3E:  MOVLW  30
4F40:  SUBWF  xB8,W
4F42:  BZ    4F4C
4F44:  BSF    xB6.1
4F46:  BTFSC  xB6.7
4F48:  BSF    xB6.2
4F4A:  BRA    4F70
4F4C:  MOVFF  B7,B8
4F50:  MOVLW  20
4F52:  MOVWF  xB7
4F54:  MOVLW  30
4F56:  SUBWF  xB9,W
4F58:  BZ    4F62
4F5A:  BSF    xB6.0
4F5C:  BTFSC  xB6.7
4F5E:  BSF    xB6.1
4F60:  BRA    4F70
4F62:  BTFSS  FD8.2
4F64:  BSF    xB6.0
4F66:  BNZ   4F70
4F68:  MOVFF  B8,B9
4F6C:  MOVLW  20
4F6E:  MOVWF  xB8
4F70:  BTFSC  xB6.2
4F72:  BRA    4F7E
4F74:  BTFSC  xB6.1
4F76:  BRA    4F86
4F78:  BTFSC  xB6.0
4F7A:  BRA    4F8E
4F7C:  BRA    4F96
4F7E:  MOVFF  B7,10E
4F82:  CALL   0996
4F86:  MOVFF  B8,10E
4F8A:  CALL   0996
4F8E:  MOVFF  B9,10E
4F92:  CALL   0996
4F96:  MOVFF  BA,10E
4F9A:  CALL   0996
4F9E:  GOTO   5092 (RETURN)
*
558E:  MOVFF  FF2,0D
5592:  BCF    FF2.6
5594:  BCF    FF2.7
5596:  ADDWF  FE8,W
5598:  CLRF   FF7
559A:  RLCF   FF7,F
559C:  ADDLW  B9
559E:  MOVWF  FF6
55A0:  MOVLW  55
55A2:  ADDWFC FF7,F
55A4:  TBLRD*-
55A6:  MOVF   FF5,W
55A8:  MOVWF  FFA
55AA:  TBLRD*
55AC:  MOVF   FF5,W
55AE:  BTFSC  0D.6
55B0:  BSF    FF2.6
55B2:  BTFSC  0D.7
55B4:  BSF    FF2.7
55B6:  MOVWF  FF9
55B8:  DATA C8,54
55BA:  DATA D6,54
55BC:  DATA E4,54
55BE:  DATA F2,54
55C0:  DATA 00,55
55C2:  DATA 0C,55
55C4:  DATA 18,55
55C6:  DATA 24,55
....................  
.................... #list 
....................  
....................     //#include <18F4520.h> 
....................     #device adc=10 
....................     #device HIGH_INTS=TRUE  
....................     #device PASS_STRINGS=IN_RAM   
....................  
....................     #FUSES NOWDT                    //No Watch Dog Timer 
....................     #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
....................     #FUSES INTRC_IO                 //Internal RC Osc, no CLKOUT 
....................     #FUSES PLLEN                  //4X HW PLL disabled, 4X PLL enabled in software 
....................     #FUSES NOPUT                      //Power Up Timer 
....................     #FUSES NOBROWNOUT               //No brownout reset 
....................     #FUSES WDT_SW                   //No Watch Dog Timer, enabled in Software 
....................     #FUSES NOPBADEN                 //PORTB pins are configured as digital I/O on RESET 
....................     #FUSES MCLR                   //Master Clear pin used for I/O 
....................     #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................     #FUSES PROTECT                  //Code protected from reads 
....................     //#FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................     #FUSES NOFCMEN 
....................     #FUSES NOHFOFST      
....................  
....................     #use delay(internal=32MHz) // çalýþtý 4MHZ çaýþtý 
*
0748:  MOVLW  01
074A:  MOVWF  FEA
074C:  MOVLW  27
074E:  MOVWF  FE9
0750:  MOVF   FEF,W
0752:  BZ    076E
0754:  MOVLW  0A
0756:  MOVWF  01
0758:  CLRF   00
075A:  DECFSZ 00,F
075C:  BRA    075A
075E:  DECFSZ 01,F
0760:  BRA    0758
0762:  MOVLW  5F
0764:  MOVWF  00
0766:  DECFSZ 00,F
0768:  BRA    0766
076A:  DECFSZ FEF,F
076C:  BRA    0754
076E:  RETURN 0
....................  
....................     //#use rs232(baud=9600,parity=N,UART1,bits=8,stream=serial_usb)  //uart1 
....................    // #use rs232(baud=9600,parity=N,UART2,bits=8,stream=serial_dfPlayer)  
....................      
....................     #use rs232(baud=9600,parity=N, xmit=PIN_D6, rcv=PIN_D7,bits=8,DISABLE_INTS,STREAM=dfPlayerSerial)   //seri port pin tanýmlama 
*
122C:  BTFSS  FA4.4
122E:  BRA    122C
1230:  MOVLB  1
1232:  MOVFF  115,F73
1236:  MOVLB  0
1238:  GOTO   12C6 (RETURN)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_C6, rcv=PIN_C7,bits=8,DISABLE_INTS,STREAM=usbSerial)   //seri port pin tanýmlama 
....................  
....................     #use rs232(baud=4800,parity=N, xmit=PIN_C4, rcv=PIN_C5,bits=8,DISABLE_INTS, STREAM=Panel1Serial) 
*
13BA:  MOVFF  FF2,03
13BE:  BCF    FF2.6
13C0:  BCF    FF2.7
13C2:  BCF    F94.4
13C4:  BCF    F8B.4
13C6:  MOVLW  08
13C8:  MOVWF  01
13CA:  BRA    13CC
13CC:  NOP   
13CE:  BSF    01.7
13D0:  BRA    13F2
13D2:  BCF    01.7
13D4:  MOVLB  1
13D6:  RRCF   x00,F
13D8:  MOVLB  0
13DA:  BTFSC  FD8.0
13DC:  BSF    F8B.4
13DE:  BTFSS  FD8.0
13E0:  BCF    F8B.4
13E2:  BSF    01.6
13E4:  BRA    13F2
13E6:  BCF    01.6
13E8:  DECFSZ 01,F
13EA:  BRA    13D4
13EC:  BRA    13EE
13EE:  NOP   
13F0:  BSF    F8B.4
13F2:  MOVLW  02
13F4:  MOVWF  00
13F6:  CLRF   FE9
13F8:  DECFSZ FE9,F
13FA:  BRA    13F8
13FC:  DECFSZ 00,F
13FE:  BRA    13F6
1400:  MOVLW  23
1402:  MOVWF  FE9
1404:  DECFSZ FE9,F
1406:  BRA    1404
1408:  NOP   
140A:  BTFSC  01.7
140C:  BRA    13D2
140E:  BTFSC  01.6
1410:  BRA    13E6
1412:  BTFSC  03.6
1414:  BSF    FF2.6
1416:  BTFSC  03.7
1418:  BSF    FF2.7
141A:  RETURN 0
....................  
....................     #use rs232(baud=4800,parity=N, xmit=PIN_E1, rcv=PIN_E0,bits=8,DISABLE_INTS, STREAM=Panel2Serial) 
*
143C:  MOVFF  FF2,03
1440:  BCF    FF2.6
1442:  BCF    FF2.7
1444:  BCF    F96.1
1446:  BCF    F8D.1
1448:  MOVLW  08
144A:  MOVWF  01
144C:  BRA    144E
144E:  NOP   
1450:  BSF    01.7
1452:  BRA    1474
1454:  BCF    01.7
1456:  MOVLB  1
1458:  RRCF   x00,F
145A:  MOVLB  0
145C:  BTFSC  FD8.0
145E:  BSF    F8D.1
1460:  BTFSS  FD8.0
1462:  BCF    F8D.1
1464:  BSF    01.6
1466:  BRA    1474
1468:  BCF    01.6
146A:  DECFSZ 01,F
146C:  BRA    1456
146E:  BRA    1470
1470:  NOP   
1472:  BSF    F8D.1
1474:  MOVLW  02
1476:  MOVWF  00
1478:  CLRF   FE9
147A:  DECFSZ FE9,F
147C:  BRA    147A
147E:  DECFSZ 00,F
1480:  BRA    1478
1482:  MOVLW  23
1484:  MOVWF  FE9
1486:  DECFSZ FE9,F
1488:  BRA    1486
148A:  NOP   
148C:  BTFSC  01.7
148E:  BRA    1454
1490:  BTFSC  01.6
1492:  BRA    1468
1494:  BTFSC  03.6
1496:  BSF    FF2.6
1498:  BTFSC  03.7
149A:  BSF    FF2.7
149C:  RETURN 0
....................  
....................     //#use rs232(uart1,baud =9600,DISABLE_INTS,STREAM=dfPlayerSerial)  
....................     //#use rs232(uart2,baud =9600,DISABLE_INTS,STREAM=softSerial) 
....................  
....................     //spi modes  
....................     #define SPI_MODE_0  (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
....................     #define SPI_MODE_1  (SPI_L_TO_H)  
....................     #define SPI_MODE_2  (SPI_H_TO_L)  
....................     #define SPI_MODE_3  (SPI_H_TO_L | SPI_XMIT_L_TO_H)  
....................  
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=0, BITS=8)  
....................                              //9600 
....................     //#use spi(MASTER, SPI1, BAUD = 1000000, MODE=0, BITS=8, MSB_FIRST, STREAM=SPI_RC522)  
....................    // #use spi(MASTER, SPI1, FORCE_HW, BAUD = 115200, MODE=0, BITS=8, MSB_FIRST, STREAM=SPI_RC522) 
....................    // #use spi(MASTER, SPI1, FORCE_HW, MODE=0, BITS=8, MSB_FIRST, STREAM=SPI_RC522) 
....................  
....................     #use fast_io(A) 
....................     //#use fast_io(B) 
....................     #use fast_io(C) 
....................     #use fast_io(E) 
....................  
....................     extern unsigned int32 timerIntSay; 
....................      
....................     //#define millis() timerIntSay 
....................     //#define setMillis(x) timerIntSay=x 
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MAIN_BISKLET_ARABA_YARIS_H */ 
....................  
....................  
.................... #include "tanimlamalar.h" 
.................... /*  
....................  * File:   tanimlamalar.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 22 Þubat 2019 Cuma, 08:43 
....................  */ 
....................  
.................... #ifndef TANIMLAMALAR_H 
.................... #define	TANIMLAMALAR_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................     #define led0 PIN_B3 
....................     #define JTN_PIN PIN_B0 
....................     #define JTN2_PIN PIN_B7 
....................  
....................     #define HIZ1_SENS_PIN PIN_B1 
....................     #define HIZ2_SENS_PIN PIN_B2 
....................  
....................     #define TUR1_SENS_PIN PIN_B5 
....................     #define TUR2_SENS_PIN PIN_B4 
....................  
....................     #define BTN1_PIN PIN_A4 
....................     #define BTN2_PIN PIN_A5 
....................     #define BTN3_PIN PIN_E2 
....................  
....................     #define BIS_BTN1_PIN PIN_A2 
....................     #define BIS_BTN2_PIN PIN_A3 
....................  
....................     #define ADC_KANAL_M2 0  //SENS_B 
....................     #define ADC_KANAL_M1 1  //SENS_A 
....................  
....................     #define PWM_DUTY_MAX_4_KHZ      500 
....................     #define PWM_DUTY_MAX_2B5_KHZ    800 
....................  
....................     #define F_MAX 10   //saniyedeki max tur sayýsý, buþekildse max 100Hz olur 
....................     //#define DELAY_OLCUM ((1/F_MAX)*1000)/10  // mS/10  F_MAX=100Hz iken delay=1mS 
....................     #define DELAY_OLCUM 10 
....................  
....................      
....................     #define panel1_komut(komut)fprintf(Panel1Serial,"%cc",komut) 
....................     #define panel2_komut(komut)fprintf(Panel2Serial,"%cc",komut) 
....................  
....................     #define M1_PWM  10 
....................     #define M2_PWM  11 
....................  
....................     #define analogWrite(_pwm_pin, _pwm_deger)                           \ 
....................                         if(_pwm_pin==M1_PWM) set_pwm1_duty(_pwm_deger); \ 
....................                         if(_pwm_pin==M2_PWM) set_pwm2_duty(_pwm_deger); \ 
....................  
....................     #define jetonKontrol(pin) if(!input(pin)){                    \ 
....................                                                                   \ 
....................                             delay_ms(500);                        \ 
....................                             calismaJetonSay++;                    \ 
....................                            }                                      \ 
....................                                                                   \ 
....................                            if((calisma_jeton_sayisi>0 && calismaJetonSay>=calisma_jeton_sayisi)) \ 
....................                            {                                            \ 
....................                                 jetonAtildi=TRUE;                       \ 
....................                                 calismaJetonSay=0;                      \ 
....................                                 jetonSay++;                             \ 
....................                            }                                            \ 
....................                            else{                                        \ 
....................                                 jetonAtildi=TRUE;                       \ 
....................                                 jetonSay++;                             \ 
....................                                 }                                       \ 
....................  
....................     #define JETON 'J' 
....................  
....................     #define OYUNCU_MOD_SECIMI 'M' 
.................... 	#define OYUNCU_MOD_SECIM_SONU 'm' 
....................  
.................... 	#define OYUNCU_HIZ_VERI 'V' 
.................... 	#define OYUNCU2_HIZ_VERI 'v' 
....................  
.................... 	#define OYUNCU_TEKERLEK_DONME_SAYISI 'D' 
.................... 	#define OYUNCU2_TEKERLEK_DONME_SAYISI 'd' 
....................  
.................... 	#define OYUNCU_TUR_SAYISI 'T' 
....................  
.................... 	#define OYUNCU_YARIS_SIRA1 '1' 
.................... 	#define OYUNCU_YARIS_SIRA2 '2' 
.................... 	#define OYUNCU_YARIS_SIRA0 '0' 
....................  
.................... 	#define OYUNCU1 '3' 
.................... 	#define OYUNCU2 '4' 
.................... 	#define SISTEM '5' 
....................  
.................... 	#define OYUNCU_BISIKLET_SECIMI 'B' 
....................     #define OYUNCU1_SISTEM 'X' 
....................     #define OYUNCU1_OYUNCU2'x' 
....................  
.................... 	#define JETON_CHAR 'J' 
.................... 	#define JETON_AT 'A' 
....................  
.................... 	#define OYUN_MOD_SECME_SURESI 5000 
....................     //#define BISIKLET_SECME_SURESI 10000 
....................     #define MOD_SECILMEDI (-1) 
.................... 	#define BAY_MOD 0 
.................... 	#define BAYAN_MOD 1 
.................... 	#define COCUK_MOD 2 
....................  
.................... 	#define OYUN_OYNANAN_SURE 'O' 
.................... 	#define OYUN_BITTI 'E' 
....................  
.................... 	#define BOS_ANIM_EKRANI 'K' 
....................  
....................     #define ZAMAN_SAY 'Z' 
....................     #define MOTOR_YOK 'Q' 
....................     #define MOTOR_VAR 'q' 
....................  
....................  
.................... 	#define BISIKLET_MAX_HIZ    71 
.................... 	//#define PWM_MAX_DEGER       400 
....................     #define PIST_UZUNLUK        8.51f 
....................                             
.................... /// mp3-wav index 
.................... 	#define wav_atKisnemesi     1 
.................... 	#define wav_atKosmasi       2 
.................... 	#define wav_suDamlasi       3 
.................... 	#define wav_heySesi         4 
.................... 	#define wav_alkisSesi       5 
.................... 	#define wav_oyunBitti       6 
.................... 	#define wav_getReady        7 
.................... 	#define wav_whoosh          8 
.................... 	#define wav_jeton           9 
.................... 	#define wav_remix           10 
.................... 	#define wav_remix2          11 
.................... 	#define wav_waterDrop       12 
.................... 	#define mp3_adele_Rolling   14 
.................... 	#define wav_duduk_basla     15 
.................... 	#define wav_ding            16 
.................... 	#define mp3_mars            17 
.................... 	#define mp3_getlowve_araba	18 
....................     #define mp3_beep_uyari      19 
....................  
....................      //// bosta rastgele mp3 müzik 
....................      
....................     #define mp3_adele_Rolling   20 
....................     #define mp3_anitta          21 
....................     #define mp3_love_lo         22 
....................     #define mp3_remix           23 
....................     #define mp3_dejavu          24 
....................     #define mp3_rain            25 
....................     #define mp3_aweli           26 
....................     ///// 
....................     #define mp3_buton           27 
....................     #define mp3_buton2          28 
....................      
.................... 	#define wav_remix_sure 200000 //(3*60+20)*1000  //3:20 mS degeri.... 
.................... 	#define wav_atKisnemesi_sure  1500 
.................... 	#define wav_atKosmasi_sure    2000 
.................... 	#define wav_whoosh_sure  300//350 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TANIMLAMALAR_H */ 
....................  
....................  
.................... //#include <stdio.h> 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
15BE:  MOVFF  33,103
15C2:  MOVFF  32,102
15C6:  MOVFF  31,101
15CA:  MOVFF  30,100
15CE:  MOVLW  41
15D0:  MOVLB  1
15D2:  MOVWF  x07
15D4:  MOVLW  C6
15D6:  MOVWF  x06
15D8:  MOVLW  4E
15DA:  MOVWF  x05
15DC:  MOVLW  6D
15DE:  MOVWF  x04
15E0:  MOVLB  0
15E2:  BRA    151E
15E4:  MOVLW  39
15E6:  MOVLB  1
15E8:  ADDWF  00,W
15EA:  MOVWF  30
15EC:  MOVLW  30
15EE:  ADDWFC 01,W
15F0:  MOVWF  31
15F2:  MOVLW  00
15F4:  ADDWFC 02,W
15F6:  MOVWF  32
15F8:  MOVLW  00
15FA:  ADDWFC 03,W
15FC:  MOVWF  33
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
15FE:  MOVFF  32,00
1602:  MOVFF  33,01
1606:  CLRF   02
1608:  CLRF   03
160A:  MOVFF  33,102
160E:  MOVFF  32,101
1612:  MOVFF  33,10F
1616:  MOVFF  32,10E
161A:  MOVLW  7F
161C:  MOVWF  x11
161E:  SETF   x10
1620:  MOVLB  0
1622:  RCALL  1578
1624:  MOVFF  00,01
1628:  MOVFF  03,02
162C:  RETURN 0
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
14BE:  MOVFF  B2,33
14C2:  MOVFF  B1,32
14C6:  MOVFF  B0,31
14CA:  MOVFF  AF,30
14CE:  GOTO   5876 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "flex_lcd.c" 
.................... // flex_lcd.c  
....................  
.................... // These pins are for the Microchip PicDem2-Plus board,  
.................... // which is what I used to test the driver.  Change these  
.................... // pins to fit your own board.  
....................  
.................... #define LCD_DB4   PIN_D0    //PIN_A0      
.................... #define LCD_DB5   PIN_D1    //PIN_A1     
.................... #define LCD_DB6   PIN_D2    //PIN_A2     
.................... #define LCD_DB7   PIN_D3    //PIN_A3  
....................  
.................... #define LCD_E     PIN_D5   //PIN_D5  
.................... #define LCD_RS    PIN_D4  
....................  
.................... //#define LCD_RW    PIN_A2  
....................  
.................... // If you only want a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  
....................  
.................... //#define USE_LCD_RW   0//1       
....................  
.................... //========================================  
....................  
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines  
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line  
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................     0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots  
....................     0xc,                    // Display on  
....................     1,                      // Clear display  
....................     6                       // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
....................     // Note:  !! converts an integer expression  
....................     // to a boolean (1 or 0).  
....................      output_bit(LCD_DB4, !!(nibble & 1));  
*
0814:  MOVLB  1
0816:  BTFSC  x16.0
0818:  BRA    081E
081A:  BCF    F8C.0
081C:  BRA    0820
081E:  BSF    F8C.0
0820:  BCF    F95.0
....................      output_bit(LCD_DB5, !!(nibble & 2));   
0822:  BTFSC  x16.1
0824:  BRA    082A
0826:  BCF    F8C.1
0828:  BRA    082C
082A:  BSF    F8C.1
082C:  BCF    F95.1
....................      output_bit(LCD_DB6, !!(nibble & 4));     
082E:  BTFSC  x16.2
0830:  BRA    0836
0832:  BCF    F8C.2
0834:  BRA    0838
0836:  BSF    F8C.2
0838:  BCF    F95.2
....................      output_bit(LCD_DB7, !!(nibble & 8));     
083A:  BTFSC  x16.3
083C:  BRA    0842
083E:  BCF    F8C.3
0840:  BRA    0844
0842:  BSF    F8C.3
0844:  BCF    F95.3
....................  
....................      delay_cycles(1);  
0846:  NOP   
....................      output_high(LCD_E);  
0848:  BCF    F95.5
084A:  BSF    F8C.5
....................      delay_us(2);  
084C:  MOVLW  04
084E:  MOVWF  00
0850:  DECFSZ 00,F
0852:  BRA    0850
0854:  BRA    0856
0856:  NOP   
....................      output_low(LCD_E);  
0858:  BCF    F95.5
085A:  BCF    F8C.5
085C:  MOVLB  0
085E:  RETURN 0
.................... }  
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_LCD_RW  
....................     int8 lcd_read_nibble(void)  
....................     {  
....................         int8 retval;  
....................         // Create bit variables so that we can easily set  
....................         // individual bits in the retval variable.  
....................         #bit retval_0 = retval.0  
....................         #bit retval_1 = retval.1  
....................         #bit retval_2 = retval.2  
....................         #bit retval_3 = retval.3  
....................  
....................         retval = 0;  
....................  
....................         output_high(LCD_E);  
....................         delay_cycles(1);  
....................  
....................         retval_0 = input(LCD_DB4);  
....................         retval_1 = input(LCD_DB5);  
....................         retval_2 = input(LCD_DB6);  
....................         retval_3 = input(LCD_DB7);  
....................  
....................         output_low(LCD_E);  
....................  
....................         return(retval);     
....................     }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_LCD_RW  
....................     int8 lcd_read_byte(void)  
....................     {  
....................         int8 low;  
....................         int8 high;  
....................  
....................         output_high(LCD_RW);  
....................         delay_cycles(1);  
....................  
....................         high = lcd_read_nibble();  
....................  
....................         low = lcd_read_nibble();  
....................  
....................         return( (high<<4) | low);  
....................     }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
....................     output_low(LCD_RS);  
0860:  BCF    F95.4
0862:  BCF    F8C.4
....................  
....................     #ifdef USE_LCD_RW  
....................         while(bit_test(lcd_read_byte(),7)) ;  
....................     #else  
....................         delay_us(60);   
0864:  MOVLW  9F
0866:  MOVWF  00
0868:  DECFSZ 00,F
086A:  BRA    0868
086C:  BRA    086E
....................     #endif  
....................  
....................     if(address)  
086E:  MOVLB  1
0870:  MOVF   x13,F
0872:  BZ    087A
....................        output_high(LCD_RS);  
0874:  BCF    F95.4
0876:  BSF    F8C.4
0878:  BRA    087E
....................     else  
....................        output_low(LCD_RS);  
087A:  BCF    F95.4
087C:  BCF    F8C.4
....................  
....................      delay_cycles(1);  
087E:  NOP   
....................  
....................     #ifdef USE_LCD_RW  
....................         output_low(LCD_RW);  
....................         delay_cycles(1);  
....................     #endif  
....................  
....................     output_low(LCD_E);  
0880:  BCF    F95.5
0882:  BCF    F8C.5
....................  
....................     lcd_send_nibble(n >> 4);  
0884:  SWAPF  x14,W
0886:  MOVWF  x15
0888:  MOVLW  0F
088A:  ANDWF  x15,F
088C:  MOVFF  115,116
0890:  MOVLB  0
0892:  RCALL  0814
....................     lcd_send_nibble(n & 0xf);  
0894:  MOVLB  1
0896:  MOVF   x14,W
0898:  ANDLW  0F
089A:  MOVWF  x15
089C:  MOVWF  x16
089E:  MOVLB  0
08A0:  RCALL  0814
08A2:  RETURN 0
.................... }  
....................  
.................... //----------------------------  
.................... void lcd_init(void)  
.................... {  
....................     int8 i;  
....................  
....................     output_low(LCD_RS);  
08A4:  BCF    F95.4
08A6:  BCF    F8C.4
....................  
....................     #ifdef USE_LCD_RW  
....................         output_low(LCD_RW);  
....................     #endif  
....................  
....................     output_low(LCD_E);  
08A8:  BCF    F95.5
08AA:  BCF    F8C.5
08AC:  CLRF   16
08AE:  BTFSC  FF2.6
08B0:  BSF    16.6
08B2:  BCF    FF2.6
08B4:  BTFSC  FF2.7
08B6:  BSF    16.7
08B8:  BCF    FF2.7
....................  
....................     delay_ms(15);  
08BA:  MOVLW  0F
08BC:  MOVLB  1
08BE:  MOVWF  x27
08C0:  MOVLB  0
08C2:  RCALL  0748
08C4:  BTFSC  16.6
08C6:  BSF    FF2.6
08C8:  BTFSC  16.7
08CA:  BSF    FF2.7
....................  
....................     for(i=0 ;i < 3; i++)  
08CC:  CLRF   xAF
08CE:  MOVF   xAF,W
08D0:  SUBLW  02
08D2:  BNC   0902
....................     {  
....................         lcd_send_nibble(0x03);  
08D4:  MOVLW  03
08D6:  MOVLB  1
08D8:  MOVWF  x16
08DA:  MOVLB  0
08DC:  RCALL  0814
08DE:  CLRF   16
08E0:  BTFSC  FF2.6
08E2:  BSF    16.6
08E4:  BCF    FF2.6
08E6:  BTFSC  FF2.7
08E8:  BSF    16.7
08EA:  BCF    FF2.7
....................         delay_ms(5);  
08EC:  MOVLW  05
08EE:  MOVLB  1
08F0:  MOVWF  x27
08F2:  MOVLB  0
08F4:  RCALL  0748
08F6:  BTFSC  16.6
08F8:  BSF    FF2.6
08FA:  BTFSC  16.7
08FC:  BSF    FF2.7
08FE:  INCF   xAF,F
0900:  BRA    08CE
....................     }  
....................  
....................     lcd_send_nibble(0x02);  
0902:  MOVLW  02
0904:  MOVLB  1
0906:  MOVWF  x16
0908:  MOVLB  0
090A:  RCALL  0814
....................  
....................     for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
090C:  CLRF   xAF
090E:  MOVF   xAF,W
0910:  SUBLW  03
0912:  BNC   095A
....................        {  
....................         lcd_send_byte(0, LCD_INIT_STRING[i]);  
0914:  CLRF   03
0916:  MOVF   xAF,W
0918:  MOVFF  FF2,B0
091C:  BCF    FF2.6
091E:  BCF    FF2.7
0920:  RCALL  0158
0922:  BTFSC  xB0.6
0924:  BSF    FF2.6
0926:  BTFSC  xB0.7
0928:  BSF    FF2.7
092A:  MOVWF  xB0
092C:  MOVLB  1
092E:  CLRF   x13
0930:  MOVWF  x14
0932:  MOVLB  0
0934:  RCALL  0860
0936:  CLRF   16
0938:  BTFSC  FF2.6
093A:  BSF    16.6
093C:  BCF    FF2.6
093E:  BTFSC  FF2.7
0940:  BSF    16.7
0942:  BCF    FF2.7
....................  
....................         // If the R/W signal is not used, then  
....................         // the busy bit can't be polled.  One of  
....................         // the init commands takes longer than  
....................         // the hard-coded delay of 60 us, so in  
....................         // that case, lets just do a 5 ms delay  
....................         // after all four of them.  
....................         #ifndef USE_LCD_RW  
....................             delay_ms(5);  
0944:  MOVLW  05
0946:  MOVLB  1
0948:  MOVWF  x27
094A:  MOVLB  0
094C:  RCALL  0748
094E:  BTFSC  16.6
0950:  BSF    FF2.6
0952:  BTFSC  16.7
0954:  BSF    FF2.7
....................         #endif  
0956:  INCF   xAF,F
0958:  BRA    090E
....................        }  
095A:  GOTO   57B2 (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
....................     int8 address;  
....................  
....................     if(y != 1)  
*
096E:  MOVLB  1
0970:  DECFSZ x10,W
0972:  BRA    0976
0974:  BRA    097C
....................        address = lcd_line_two;  
0976:  MOVLW  40
0978:  MOVWF  x11
097A:  BRA    097E
....................     else  
....................        address=0;  
097C:  CLRF   x11
....................  
....................     address += x-1;  
097E:  MOVLW  01
0980:  SUBWF  x0F,W
0982:  ADDWF  x11,F
....................     lcd_send_byte(0, 0x80 | address);  
0984:  MOVF   x11,W
0986:  IORLW  80
0988:  MOVWF  x12
098A:  CLRF   x13
098C:  MOVWF  x14
098E:  MOVLB  0
0990:  RCALL  0860
0992:  GOTO   0A04 (RETURN)
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................     switch(c)  
0996:  MOVLB  1
0998:  MOVF   x0E,W
099A:  XORLW  0C
099C:  MOVLB  0
099E:  BZ    09AA
09A0:  XORLW  06
09A2:  BZ    09D8
09A4:  XORLW  02
09A6:  BZ    09E8
09A8:  BRA    09F6
....................       {  
....................        case '\f':               //LCD temizle 
....................          lcd_send_byte(0,1);  
09AA:  MOVLB  1
09AC:  CLRF   x13
09AE:  MOVLW  01
09B0:  MOVWF  x14
09B2:  MOVLB  0
09B4:  RCALL  0860
09B6:  CLRF   16
09B8:  BTFSC  FF2.6
09BA:  BSF    16.6
09BC:  BCF    FF2.6
09BE:  BTFSC  FF2.7
09C0:  BSF    16.7
09C2:  BCF    FF2.7
....................          delay_ms(2);  
09C4:  MOVLW  02
09C6:  MOVLB  1
09C8:  MOVWF  x27
09CA:  MOVLB  0
09CC:  RCALL  0748
09CE:  BTFSC  16.6
09D0:  BSF    FF2.6
09D2:  BTFSC  16.7
09D4:  BSF    FF2.7
....................          break;  
09D6:  BRA    0A04
....................  
....................        case '\n':               //LCD ikinci satýra geçir 
....................           lcd_gotoxy(1,2);  
09D8:  MOVLW  01
09DA:  MOVLB  1
09DC:  MOVWF  x0F
09DE:  MOVLW  02
09E0:  MOVWF  x10
09E2:  MOVLB  0
09E4:  BRA    096E
....................           break;  
09E6:  BRA    0A04
....................  
....................        case '\b':               //  Move back one position 
....................           lcd_send_byte(0,0x10);  
09E8:  MOVLB  1
09EA:  CLRF   x13
09EC:  MOVLW  10
09EE:  MOVWF  x14
09F0:  MOVLB  0
09F2:  RCALL  0860
....................           break;  
09F4:  BRA    0A04
....................  
....................        default:  
....................           lcd_send_byte(1,c);  
09F6:  MOVLW  01
09F8:  MOVLB  1
09FA:  MOVWF  x13
09FC:  MOVFF  10E,114
0A00:  MOVLB  0
0A02:  RCALL  0860
....................           break;  
....................       }  
0A04:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_LCD_RW  
....................     char lcd_getc(int8 x, int8 y)  
....................     {  
....................         char value;  
....................  
....................         lcd_gotoxy(x,y);  
....................  
....................         // Wait until busy flag is low.  
....................         while(bit_test(lcd_read_byte(),7));   
....................  
....................         output_high(LCD_RS);  
....................         value = lcd_read_byte();  
....................         output_low(lcd_RS);  
....................  
....................         return(value);  
....................     }  
.................... #endif 
....................      
.................... #define lcd_clear()    lcd_send_byte(0,1); ;delay_ms(25) 
....................  
.................... #include "timer.h" 
.................... /*  
....................  * File:   timer.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 25 Aralýk 2018 Salý, 08:35 
....................  */ 
....................  
.................... #ifndef TIMER_H 
.................... #define	TIMER_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................     unsigned int32 timerIntSay=0; 
....................      
....................     #define millis() timerIntSay 
....................     #define setMillis(x) timerIntSay=x 
....................  
....................     void timer_kur(); 
....................     void Timer0_int(); 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TIMER_H */ 
....................  
....................  
.................... #include "timer.c" 
.................... #include "timer.h" 
.................... /*  
....................  * File:   timer.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 25 Aralýk 2018 Salý, 08:35 
....................  */ 
....................  
.................... #ifndef TIMER_H 
.................... #define	TIMER_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................     unsigned int32 timerIntSay=0; 
....................      
....................     #define millis() timerIntSay 
....................     #define setMillis(x) timerIntSay=x 
....................  
....................     void timer_kur(); 
....................     void Timer0_int(); 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TIMER_H */ 
....................  
....................  
.................... void timer_kur(){ 
....................      
....................     setup_timer_0(T0_INTERNAl | T0_8_BIT | T0_DIV_64);    // clock 48Mhz,32MHz 
*
095E:  MOVLW  C5
0960:  MOVWF  FD5
....................     //set_timer0(0x43);            //1000uS    clock 48Mhz 
....................     set_timer0(0x82);            //1000uS 32MHZ 
0962:  CLRF   FD7
0964:  MOVLW  82
0966:  MOVWF  FD6
....................     //set_timer0(0x05);            //1000uS 64MHZ 
.................... //    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
.................... //    set_timer1(0xFB1D);   //64285 1000uS div_8 ile kesme    
.................... //    setup_timer_3(T3_INTERNAL|T3_DIV_BY_8); 
.................... //    set_timer3(0xFB1D); 
.................... //    clear_interrupt(INT_TIMER3); 
.................... //    enable_interrupts(INT_TIMER3);  
.................... //    disable_interrupts(INT_TIMER3); 
.................... //    enable_interrupts(PERIPH); 
.................... //    enable_interrupts(INT_TIMER1); 
....................      
....................     enable_interrupts(INT_TIMER0); 
0968:  BSF    FF2.5
096A:  GOTO   57E8 (RETURN)
....................    // enable_interrupts(GLOBAL); 
....................       
.................... } 
.................... long say=0; 
.................... #INT_TIMER0 //HIGH                    //Timer0 Kesmesi 
.................... void Timer0_int(){ 
....................    // set_timer0(0x43);            //1000uS 16Mhz 
....................    set_timer0(0x82);            //1000uS 32MHZ 
*
017C:  CLRF   FD7
017E:  MOVLW  82
0180:  MOVWF  FD6
....................    // set_timer0(0x05);            //1000uS 64MHZ 
....................     
....................    say++; 
0182:  INCF   34,F
0184:  BTFSC  FD8.2
0186:  INCF   35,F
....................    if(say>=100){ 
0188:  MOVF   35,F
018A:  BNZ   0192
018C:  MOVF   34,W
018E:  SUBLW  63
0190:  BC    019A
....................        output_toggle(PIN_B3); 
0192:  BCF    F93.3
0194:  BTG    F8A.3
....................        say=0; 
0196:  CLRF   35
0198:  CLRF   34
....................    } 
....................     timerIntSay++; 
019A:  MOVLW  01
019C:  ADDWF  2A,F
019E:  BTFSC  FD8.0
01A0:  INCF   2B,F
01A2:  BTFSC  FD8.2
01A4:  INCF   2C,F
01A6:  BTFSC  FD8.2
01A8:  INCF   2D,F
....................     clear_interrupt(INT_TIMER0 ) ; 
01AA:  BCF    FF2.2
.................... } 
....................  
.................... #include "dfPlayer.c" 
.................... #include "dfPlayer.h" 
.................... /*  
....................  * File:   dfPlayer.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 28 Þubat 2018 Çarþamba, 16:11 
....................  */ 
....................  
.................... /* 
....................  *	name:				DFPlayer_Mini_Mp3 
....................  *	version:			1.0 
....................  *	Author:				lisper <lisper.li@dfrobot.com> 
....................  *	Date:				2014-05-22 
....................  *	official website:		http://www.dfrobot.com 
....................  *	Products page:			http://www.dfrobot.com/index.php?route=product/product&product_id=1121#.U5Z_RYbUN8E 
....................  *	Description:			mp3 library for DFPlayer mini board 
....................  *					        note: mp3 file must put into mp3 folder in your tf card 
....................  */ 
....................  
.................... #ifndef DFPLAYER_H 
.................... #define	DFPLAYER_H 
....................  
01AC:  BCF    FF2.2
01AE:  GOTO   0088
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................     typedef unsigned char mbyte; 
....................      
....................     #define startByte 0x7E 
....................     #define endByte 0xEF 
....................     #define versionByte 0xFF 
....................     #define dataLength 0x06 
....................     #define infoReq 0x01        //0x01 
....................     #define isDebug false 
....................     #define dfPlayerMaxSes 30 // dec30:0x1E 
....................  
....................     #define DF_BUSY_PIN  PIN_C3 //PIN_B3 
....................  
....................     void sendCommand(mbyte Command, mbyte Param1, mbyte Param2); 
....................     void mp3_set_volume (char vol); 
....................     void mp3_set_equalizer(char eq); 
....................     void mp3_play_physical(unsigned int16 fileNum); 
....................     void mp3_get_error (); 
....................     void mp3_single_loop (unsigned int16 fileNum) ; 
....................     void mp3_enableLoopAll(); 
....................     void mp3_disbleLoopAll(); 
....................     void mp3_getData(*dizi); 
....................     void mp3_DataSeriGonder(*dizi,char len); 
....................     void mp3_stop(); 
....................     void mp3_reset(); 
....................     void mp3_baslangic(); 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* DFPLAYER_H */ 
....................  
....................  
....................  
.................... //Bu haliyle SD kart ana klasörüne mp3 yada vaw dosya atýlmasý 
.................... // fark etmiyor her ikisinide çalýþtýrýyor.. Ýsimler ayný olmayacak... 
....................  
....................  
.................... void sendCommand(mbyte Command, mbyte Param1, mbyte Param2) { 
*
123C:  MOVLW  05
123E:  MOVLB  1
1240:  ADDWF  x02,W
1242:  MOVWF  x14
1244:  MOVLW  01
1246:  MOVWF  x15
1248:  BTFSC  FD8.0
124A:  INCF   x15,F
124C:  MOVLW  01
124E:  ADDWF  x14,F
1250:  MOVLW  00
1252:  ADDWFC x15,F
1254:  MOVF   x03,W
1256:  ADDWF  x14,F
1258:  MOVLW  00
125A:  ADDWFC x15,F
125C:  MOVF   x04,W
125E:  ADDWF  x14,W
1260:  MOVWF  01
1262:  MOVLW  00
1264:  ADDWFC x15,W
1266:  MOVWF  03
1268:  MOVF   01,W
126A:  XORLW  FF
126C:  ADDLW  01
126E:  MOVWF  x0F
1270:  MOVLW  00
1272:  SUBFWB 03,W
1274:  MOVWF  x10
1276:  MOVFF  10F,111
127A:  MOVFF  110,112
....................      
....................   //  disable_interrupts(GLOBAL); 
.................... // Calculate the checksum 
....................   mbyte commandBuffer[10]; 
....................   unsigned int16 checkSum = -(versionByte + dataLength + Command + infoReq + Param1 + Param2); 
....................   mbyte low_cSum=make8(checkSum,0); 
....................   mbyte high_cSum=make8(checkSum,1); 
....................   // Construct the command line 
....................   //mbyte commandBuffer[10] ={startByte, versionByte, dataLength, Command, infoReq, Param1, Param2,high_cSum,low_cSum, endByte}; 
....................    
....................   commandBuffer[0]=startByte; 
127E:  MOVLW  7E
1280:  MOVWF  x05
....................   commandBuffer[1]=versionByte; 
1282:  SETF   x06
....................   commandBuffer[2]=dataLength; 
1284:  MOVLW  06
1286:  MOVWF  x07
....................   commandBuffer[3]=Command; 
1288:  MOVFF  102,108
....................   commandBuffer[4]=infoReq; 
128C:  MOVLW  01
128E:  MOVWF  x09
....................   commandBuffer[5]=Param1; 
1290:  MOVFF  103,10A
....................   commandBuffer[6]=Param2; 
1294:  MOVFF  104,10B
....................   commandBuffer[7]=high_cSum; 
1298:  MOVFF  112,10C
....................   commandBuffer[8]=low_cSum; 
129C:  MOVFF  111,10D
....................   commandBuffer[9]=endByte; 
12A0:  MOVLW  EF
12A2:  MOVWF  x0E
.................... // 
....................   for (int cnt = 0; cnt < 10; cnt++) { 
12A4:  CLRF   x13
12A6:  MOVF   x13,W
12A8:  SUBLW  09
12AA:  BNC   12CC
....................     //mp3.write(commandBuffer[cnt]); 
....................       //putc(commandBuffer[cnt]); 
....................       fputc(commandBuffer[cnt],dfPlayerSerial); 
12AC:  CLRF   03
12AE:  MOVF   x13,W
12B0:  ADDLW  05
12B2:  MOVWF  FE9
12B4:  MOVLW  01
12B6:  ADDWFC 03,W
12B8:  MOVWF  FEA
12BA:  MOVFF  FEF,114
12BE:  MOVFF  114,115
12C2:  MOVLB  0
12C4:  BRA    122C
12C6:  MOVLB  1
12C8:  INCF   x13,F
12CA:  BRA    12A6
12CC:  CLRF   16
12CE:  BTFSC  FF2.6
12D0:  BSF    16.6
12D2:  BCF    FF2.6
12D4:  BTFSC  FF2.7
12D6:  BSF    16.7
12D8:  BCF    FF2.7
....................   } 
....................  
....................   // Delay needed between successive commands 
....................   delay_ms(30); 
12DA:  MOVLW  1E
12DC:  MOVWF  x27
12DE:  MOVLB  0
12E0:  CALL   0748
12E4:  BTFSC  16.6
12E6:  BSF    FF2.6
12E8:  BTFSC  16.7
12EA:  BSF    FF2.7
12EC:  RETURN 0
....................  // enable_interrupts(GLOBAL); 
....................    
.................... } 
....................  
.................... // Set volume (otherwise full blast!) command code 0x06 followed by high byte / low byte 
.................... // sendCommand(0x06, 0, 30); 
.................... void mp3_set_volume (char vol){ 
....................     sendCommand(0x06, 0, vol); 
*
1312:  MOVLW  06
1314:  MOVLB  1
1316:  MOVWF  x02
1318:  CLRF   x03
131A:  MOVFF  B5,104
131E:  MOVLB  0
1320:  RCALL  123C
1322:  RETURN 0
.................... } 
.................... // Equaliser setting 
.................... //  sendCommand(0x07, 0, 5); 
.................... void mp3_set_equalizer(char eq){ 
....................     sendCommand(0x07, 0, eq); 
*
12EE:  MOVLW  07
12F0:  MOVLB  1
12F2:  MOVWF  x02
12F4:  CLRF   x03
12F6:  MOVFF  B0,104
12FA:  MOVLB  0
12FC:  RCALL  123C
12FE:  GOTO   1368 (RETURN)
.................... } 
.................... // Specify track to play (0 = first track) 
.................... //  sendCommand(0x03, 0, 0); 
.................... void mp3_play_physical(unsigned int16 fileNum){ 
....................   sendCommand(0x03, make8(fileNum,1), make8(fileNum,0));   
....................   //sendCommand(0x03, 0, 1); 
.................... } 
.................... // 
.................... void mp3_single_loop (unsigned int16 fileNum) { 
.................... 	sendCommand(0x08, make8(fileNum,1), make8(fileNum,0)); 
.................... }   
.................... void mp3_enableLoopAll(){ 
....................     sendCommand(0x11, 0x00,0x01 );         
*
1324:  MOVLW  11
1326:  MOVLB  1
1328:  MOVWF  x02
132A:  CLRF   x03
132C:  MOVLW  01
132E:  MOVWF  x04
1330:  MOVLB  0
1332:  RCALL  123C
1334:  GOTO   13B6 (RETURN)
.................... } 
.................... void mp3_disbleLoopAll(){ 
....................     sendCommand(0x11, 0x00,0x00 );         
.................... } 
.................... // Play 
....................   //sendCommand(0x0D, 0, 0); 
.................... void mp3_play (){ 
....................    sendCommand(0x0D, 0, 0);  
.................... } 
....................  
.................... void mp3_play (unsigned int16 fileNum)  
.................... { 
.................... 	//mp3_send_cmd (0x12, num); 
....................     sendCommand(0x12, make8(fileNum,1), make8(fileNum,0));   
*
1658:  MOVFF  FF,100
165C:  MOVFF  FE,101
1660:  MOVLW  12
1662:  MOVLB  1
1664:  MOVWF  x02
1666:  MOVFF  FF,103
166A:  MOVFF  FE,104
166E:  MOVLB  0
1670:  RCALL  123C
1672:  RETURN 0
.................... } 
.................... void mp3_stop(){ 
....................    sendCommand(0x16, 0, 0);      
*
1302:  MOVLW  16
1304:  MOVLB  1
1306:  MOVWF  x02
1308:  CLRF   x03
130A:  CLRF   x04
130C:  MOVLB  0
130E:  RCALL  123C
1310:  RETURN 0
.................... } 
.................... void mp3_reset(){ 
....................     sendCommand(0x0C, 0, 0);  
.................... } 
....................  
.................... void mp3_get_error () { 
....................     sendCommand(0x40, 0, 0);  
....................      
.................... } 
.................... void mp3_getData(*dizi){        //kilitlendi ..... 
....................     char i=0; 
....................      
....................     while(i<10){ 
....................         if(kbhit(dfPlayerSerial)){ 
....................             dizi[i]=fgetc(dfPlayerSerial); 
....................             i++; 
....................         }   
....................     } 
.................... } 
....................  
.................... void mp3_DataSeriGonder(*dizi,char len){  
....................    int k=0;   
....................    fprintf(usbSerial,"\r\n"); 
....................    for( k=0;k<len;k++){ 
....................            fprintf(usbSerial,"%x ",dizi[k]);     
....................    }  
....................    fprintf(usbSerial,"\r\n"); 
.................... } 
.................... void mp3_baslangic(unsigned int ses){ 
....................      
....................     delay_ms(500); /// Mp3  player donaným kurulumndan belli bir süre sonra çalýþtýrmalý.... 
*
1338:  MOVLW  02
133A:  MOVWF  xB0
133C:  CLRF   16
133E:  BTFSC  FF2.6
1340:  BSF    16.6
1342:  BCF    FF2.6
1344:  BTFSC  FF2.7
1346:  BSF    16.7
1348:  BCF    FF2.7
134A:  MOVLW  FA
134C:  MOVLB  1
134E:  MOVWF  x27
1350:  MOVLB  0
1352:  CALL   0748
1356:  BTFSC  16.6
1358:  BSF    FF2.6
135A:  BTFSC  16.7
135C:  BSF    FF2.7
135E:  DECFSZ xB0,F
1360:  BRA    133C
....................     mp3_set_equalizer(5); 
1362:  MOVLW  05
1364:  MOVWF  xB0
1366:  BRA    12EE
1368:  CLRF   16
136A:  BTFSC  FF2.6
136C:  BSF    16.6
136E:  BCF    FF2.6
1370:  BTFSC  FF2.7
1372:  BSF    16.7
1374:  BCF    FF2.7
....................     delay_ms(100); 
1376:  MOVLW  64
1378:  MOVLB  1
137A:  MOVWF  x27
137C:  MOVLB  0
137E:  CALL   0748
1382:  BTFSC  16.6
1384:  BSF    FF2.6
1386:  BTFSC  16.7
1388:  BSF    FF2.7
....................     //mp3_set_volume(15);//48 e kadar olabiliyor denendi... 
....................     //dfPlayer_ses= map(read_adc(),0,1023,0,dfPlayerMaxSes); 
....................     mp3_stop(); 
138A:  RCALL  1302
....................     mp3_set_volume (ses);       //20 
138C:  MOVFF  AF,B5
1390:  RCALL  1312
1392:  CLRF   16
1394:  BTFSC  FF2.6
1396:  BSF    16.6
1398:  BCF    FF2.6
139A:  BTFSC  FF2.7
139C:  BSF    16.7
139E:  BCF    FF2.7
....................     delay_ms(100); 
13A0:  MOVLW  64
13A2:  MOVLB  1
13A4:  MOVWF  x27
13A6:  MOVLB  0
13A8:  CALL   0748
13AC:  BTFSC  16.6
13AE:  BSF    FF2.6
13B0:  BTFSC  16.7
13B2:  BSF    FF2.7
....................     mp3_enableLoopAll(); 
13B4:  BRA    1324
13B6:  GOTO   583E (RETURN)
....................    // mp3_single_loop(18); 
....................    // mp3_play(18); 
....................    // delay_ms(500); 
....................      
.................... } 
....................  
.................... #include "dfPlayer.h" 
.................... /*  
....................  * File:   dfPlayer.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 28 Þubat 2018 Çarþamba, 16:11 
....................  */ 
....................  
.................... /* 
....................  *	name:				DFPlayer_Mini_Mp3 
....................  *	version:			1.0 
....................  *	Author:				lisper <lisper.li@dfrobot.com> 
....................  *	Date:				2014-05-22 
....................  *	official website:		http://www.dfrobot.com 
....................  *	Products page:			http://www.dfrobot.com/index.php?route=product/product&product_id=1121#.U5Z_RYbUN8E 
....................  *	Description:			mp3 library for DFPlayer mini board 
....................  *					        note: mp3 file must put into mp3 folder in your tf card 
....................  */ 
....................  
.................... #ifndef DFPLAYER_H 
.................... #define	DFPLAYER_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................     typedef unsigned char mbyte; 
....................      
....................     #define startByte 0x7E 
....................     #define endByte 0xEF 
....................     #define versionByte 0xFF 
....................     #define dataLength 0x06 
....................     #define infoReq 0x01        //0x01 
....................     #define isDebug false 
....................     #define dfPlayerMaxSes 30 // dec30:0x1E 
....................  
....................     #define DF_BUSY_PIN  PIN_C3 //PIN_B3 
....................  
....................     void sendCommand(mbyte Command, mbyte Param1, mbyte Param2); 
....................     void mp3_set_volume (char vol); 
....................     void mp3_set_equalizer(char eq); 
....................     void mp3_play_physical(unsigned int16 fileNum); 
....................     void mp3_get_error (); 
....................     void mp3_single_loop (unsigned int16 fileNum) ; 
....................     void mp3_enableLoopAll(); 
....................     void mp3_disbleLoopAll(); 
....................     void mp3_getData(*dizi); 
....................     void mp3_DataSeriGonder(*dizi,char len); 
....................     void mp3_stop(); 
....................     void mp3_reset(); 
....................     void mp3_baslangic(); 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* DFPLAYER_H */ 
....................  
....................  
....................  
.................... int8 jetonSay=0,calismaJetonSay=0; 
.................... BOOLEAN jetonAtildi=FALSE; 
.................... BOOLEAN b1=0, b2=0; 
.................... int o1_mod_say=MOD_SECILMEDI, o2_mod_say=MOD_SECILMEDI,o1_mod=SISTEM, o2_mod=SISTEM; 
....................  
.................... unsigned int32 time=0;           
.................... unsigned int32 toplam_jeton_sayisi;           // Oyuncak çalýþmaya baþladýðý andan itibaren kullanýlan jeton sayýsý 
....................  
....................  
.................... unsigned int16 pwm_max_deger=400,v1_pwm=0,v2_pwm=0; 
.................... unsigned int16 akim_adc_deger1=0, akim_adc_deger2=0; 
....................  
.................... const float tekerlek_yari_cap =0.45f;  // 45 cm 
.................... //const float pi=3.14159f; 
....................  
.................... unsigned int16  rpm1=0, rpm2=0, rps1=0, rps2=0;	//  rotate per minute(rpm), rotate per second(rps)) 
.................... //geçen zaman, devir/dak,  ölü zaman: sensorden gelen verinin son zamanýný okur ms 
.................... unsigned long long pevtime1=0, pevtime2=0, dtime1=0, dtime2=0; 
.................... unsigned long timetaken1=0, timetaken2=0; 
.................... float v1 = 0, v2 = 0;						//hýz 
.................... volatile BYTE rotation1=0,rotation2=0; 
.................... volatile unsigned int16 tekerlek_tur1 = 0, tekerlek_tur2 = 0; 
.................... unsigned int16 pist_tur1 = 0, pist_tur2=0; 
.................... int sira1=0, sira2=0; 
....................  
.................... float yol1 = 0, yol2 = 0; 
....................  
.................... unsigned long long time_mod_sec=0; 
.................... unsigned long long time_bis_sec=0; 
.................... unsigned long long time_oyun=90000LL; 
.................... unsigned long long time_oyun_sure_say = 0; 
....................  
.................... unsigned long bisiklet_secme_suresi=10000L; 
....................  
.................... unsigned int zmn_say1=0,zmn_say2=0; 
.................... unsigned int dfPlayer_ses=20, calisma_jeton_sayisi=0; 
....................  
.................... BOOLEAN oyun_basladi=FALSE, bis_sec_sure_bitti=FALSE, bis_sec_sure_baslat=FALSE; 
....................  
.................... unsigned long m1_pwm_deger = 0; 
.................... unsigned long m2_pwm_deger = 0; 
....................  
.................... struct bisikletVeri 
.................... { 
.................... 	BYTE komut; 
.................... 	BYTE veri_low; 
.................... 	BYTE veri_high; 
.................... } panel; 
....................  
.................... void oyun_giris_islemler(); 
.................... void oyun_islemler(); 
.................... void o1_akim_olc(); 
.................... void o2_akim_olc(); 
.................... void o1_hiz_olcum(); 
.................... void o2_hiz_olcum(); 
.................... void ISR_RB0(); 
.................... void ISR_RB1(); 
.................... void ISR_RB2(); 
.................... void ISR_RB_Change(); 
....................  void mp3_rastgele(); 
....................  
.................... long map(long x, long in_min, long in_max, long out_min, long out_max); 
....................  
.................... #include "eeprom_islem.c" 
.................... #define EE_ADR_TOP_JTN_SYS  0    //32 bit 0-3 
.................... #define EE_ADR_OYUN_SURE    4    // 8bit dk*10 þeklinde kaydediliyor. 
.................... #define EE_ADR_BIS_SEC_SURE 5    // 8 bit saniye  
.................... #define EE_ADR_JTN_SYS      6    // 8 bit. RFID çalýþmayacaksa çalýþma jeton sayýsý 
.................... #define EE_ADR_MAX_SES      7    // 8 bit . DF player ses seviyesi 
.................... #define EE_ADR_MAX_PWM      8    // 16 bit 8-9. PWM max deðeri 
....................  
.................... //unsigned int32 toplam_jeton_sayisi=0; 
....................  
.................... void ee_ilk_baslama_degerleri_oku(){ 
....................      
....................     if(read_eeprom(EE_ADR_TOP_JTN_SYS)!=0xFF && read_eeprom(EE_ADR_TOP_JTN_SYS+1)!=0xFF && 
....................       read_eeprom(EE_ADR_TOP_JTN_SYS+2)!=0xFF && read_eeprom(EE_ADR_TOP_JTN_SYS+3)!=0xFF){ 
*
0D08:  MOVFF  FF2,AF
0D0C:  BCF    FF2.6
0D0E:  BCF    FF2.7
0D10:  CLRF   FA9
0D12:  BCF    FA6.6
0D14:  BCF    FA6.7
0D16:  BSF    FA6.0
0D18:  MOVF   FA8,W
0D1A:  BTFSC  xAF.6
0D1C:  BSF    FF2.6
0D1E:  BTFSC  xAF.7
0D20:  BSF    FF2.7
0D22:  SUBLW  FF
0D24:  BZ    0E0E
0D26:  MOVFF  FF2,B0
0D2A:  BCF    FF2.6
0D2C:  BCF    FF2.7
0D2E:  MOVLW  01
0D30:  MOVWF  FA9
0D32:  BCF    FA6.6
0D34:  BCF    FA6.7
0D36:  BSF    FA6.0
0D38:  MOVF   FA8,W
0D3A:  BTFSC  xB0.6
0D3C:  BSF    FF2.6
0D3E:  BTFSC  xB0.7
0D40:  BSF    FF2.7
0D42:  SUBLW  FF
0D44:  BZ    0E0E
0D46:  MOVFF  FF2,B1
0D4A:  BCF    FF2.6
0D4C:  BCF    FF2.7
0D4E:  MOVLW  02
0D50:  MOVWF  FA9
0D52:  BCF    FA6.6
0D54:  BCF    FA6.7
0D56:  BSF    FA6.0
0D58:  MOVF   FA8,W
0D5A:  BTFSC  xB1.6
0D5C:  BSF    FF2.6
0D5E:  BTFSC  xB1.7
0D60:  BSF    FF2.7
0D62:  SUBLW  FF
0D64:  BZ    0E0E
0D66:  MOVFF  FF2,B2
0D6A:  BCF    FF2.6
0D6C:  BCF    FF2.7
0D6E:  MOVLW  03
0D70:  MOVWF  FA9
0D72:  BCF    FA6.6
0D74:  BCF    FA6.7
0D76:  BSF    FA6.0
0D78:  MOVF   FA8,W
0D7A:  BTFSC  xB2.6
0D7C:  BSF    FF2.6
0D7E:  BTFSC  xB2.7
0D80:  BSF    FF2.7
0D82:  SUBLW  FF
0D84:  BZ    0E0E
....................                             //MSB first  
....................         toplam_jeton_sayisi=make32(read_eeprom(EE_ADR_TOP_JTN_SYS+3),read_eeprom(EE_ADR_TOP_JTN_SYS+2), 
....................                                    read_eeprom(EE_ADR_TOP_JTN_SYS+1),read_eeprom(EE_ADR_TOP_JTN_SYS)); //LSB 
0D86:  MOVFF  FF2,AF
0D8A:  BCF    FF2.6
0D8C:  BCF    FF2.7
0D8E:  MOVLW  03
0D90:  MOVWF  FA9
0D92:  BCF    FA6.6
0D94:  BCF    FA6.7
0D96:  BSF    FA6.0
0D98:  MOVF   FA8,W
0D9A:  BTFSC  xAF.6
0D9C:  BSF    FF2.6
0D9E:  BTFSC  xAF.7
0DA0:  BSF    FF2.7
0DA2:  MOVWF  xB0
0DA4:  MOVFF  FF2,B1
0DA8:  BCF    FF2.6
0DAA:  BCF    FF2.7
0DAC:  MOVLW  02
0DAE:  MOVWF  FA9
0DB0:  BCF    FA6.6
0DB2:  BCF    FA6.7
0DB4:  BSF    FA6.0
0DB6:  MOVF   FA8,W
0DB8:  BTFSC  xB1.6
0DBA:  BSF    FF2.6
0DBC:  BTFSC  xB1.7
0DBE:  BSF    FF2.7
0DC0:  MOVWF  xB2
0DC2:  MOVFF  FF2,B3
0DC6:  BCF    FF2.6
0DC8:  BCF    FF2.7
0DCA:  MOVLW  01
0DCC:  MOVWF  FA9
0DCE:  BCF    FA6.6
0DD0:  BCF    FA6.7
0DD2:  BSF    FA6.0
0DD4:  MOVF   FA8,W
0DD6:  BTFSC  xB3.6
0DD8:  BSF    FF2.6
0DDA:  BTFSC  xB3.7
0DDC:  BSF    FF2.7
0DDE:  MOVWF  xB4
0DE0:  MOVFF  FF2,B5
0DE4:  BCF    FF2.6
0DE6:  BCF    FF2.7
0DE8:  CLRF   FA9
0DEA:  BCF    FA6.6
0DEC:  BCF    FA6.7
0DEE:  BSF    FA6.0
0DF0:  MOVF   FA8,W
0DF2:  BTFSC  xB5.6
0DF4:  BSF    FF2.6
0DF6:  BTFSC  xB5.7
0DF8:  BSF    FF2.7
0DFA:  MOVWF  xB6
0DFC:  MOVFF  B0,44
0E00:  MOVFF  B2,43
0E04:  MOVFF  B4,42
0E08:  MOVFF  B6,41
....................     }else{ 
0E0C:  BRA    0E16
....................        toplam_jeton_sayisi=0; 
0E0E:  CLRF   44
0E10:  CLRF   43
0E12:  CLRF   42
0E14:  CLRF   41
....................     } 
....................     printf(lcd_putc,"\fTOPLAM JETON :"); 
0E16:  MOVLW  B2
0E18:  MOVWF  FF6
0E1A:  MOVLW  01
0E1C:  MOVWF  FF7
0E1E:  RCALL  0A06
....................     printf(lcd_putc,"\n%Lu", toplam_jeton_sayisi); 
0E20:  MOVLW  0A
0E22:  MOVLB  1
0E24:  MOVWF  x0E
0E26:  MOVLB  0
0E28:  RCALL  0996
0E2A:  MOVLW  41
0E2C:  MOVWF  FE9
0E2E:  MOVFF  44,105
0E32:  MOVFF  43,104
0E36:  MOVFF  42,103
0E3A:  MOVFF  41,102
0E3E:  RCALL  0ABA
....................     delay_ms(1250); 
0E40:  MOVLW  05
0E42:  MOVWF  xAF
0E44:  CLRF   16
0E46:  BTFSC  FF2.6
0E48:  BSF    16.6
0E4A:  BCF    FF2.6
0E4C:  BTFSC  FF2.7
0E4E:  BSF    16.7
0E50:  BCF    FF2.7
0E52:  MOVLW  FA
0E54:  MOVLB  1
0E56:  MOVWF  x27
0E58:  MOVLB  0
0E5A:  RCALL  0748
0E5C:  BTFSC  16.6
0E5E:  BSF    FF2.6
0E60:  BTFSC  16.7
0E62:  BSF    FF2.7
0E64:  DECFSZ xAF,F
0E66:  BRA    0E44
....................      
....................     if(read_eeprom(EE_ADR_OYUN_SURE)!=0xFF){ 
0E68:  MOVFF  FF2,AF
0E6C:  BCF    FF2.6
0E6E:  BCF    FF2.7
0E70:  MOVLW  04
0E72:  MOVWF  FA9
0E74:  BCF    FA6.6
0E76:  BCF    FA6.7
0E78:  BSF    FA6.0
0E7A:  MOVF   FA8,W
0E7C:  BTFSC  xAF.6
0E7E:  BSF    FF2.6
0E80:  BTFSC  xAF.7
0E82:  BSF    FF2.7
0E84:  SUBLW  FF
0E86:  BZ    0F26
....................         time_oyun=(read_eeprom(EE_ADR_OYUN_SURE));//*60*1000; 
0E88:  MOVFF  FF2,AF
0E8C:  BCF    FF2.6
0E8E:  BCF    FF2.7
0E90:  MOVLW  04
0E92:  MOVWF  FA9
0E94:  BCF    FA6.6
0E96:  BCF    FA6.7
0E98:  BSF    FA6.0
0E9A:  MOVF   FA8,W
0E9C:  BTFSC  xAF.6
0E9E:  BSF    FF2.6
0EA0:  BTFSC  xAF.7
0EA2:  BSF    FF2.7
0EA4:  CLRF   x92
0EA6:  CLRF   x91
0EA8:  CLRF   x90
0EAA:  MOVWF  x8F
....................         time_oyun= _mul(time_oyun,60)/10; 
0EAC:  MOVFF  90,B9
0EB0:  MOVFF  8F,B8
0EB4:  CLRF   xBB
0EB6:  MOVLW  3C
0EB8:  MOVWF  xBA
0EBA:  RCALL  0B78
0EBC:  MOVF   01,W
0EBE:  MOVFF  03,B2
0EC2:  MOVFF  02,B1
0EC6:  MOVFF  01,B0
0ECA:  MOVFF  00,AF
0ECE:  BCF    FD8.1
0ED0:  MOVFF  03,111
0ED4:  MOVFF  02,110
0ED8:  MOVFF  01,10F
0EDC:  MOVFF  00,10E
0EE0:  MOVLB  1
0EE2:  CLRF   x15
0EE4:  CLRF   x14
0EE6:  CLRF   x13
0EE8:  MOVLW  0A
0EEA:  MOVWF  x12
0EEC:  MOVLB  0
0EEE:  RCALL  0A26
0EF0:  MOVFF  03,92
0EF4:  MOVFF  02,91
0EF8:  MOVFF  01,90
0EFC:  MOVFF  00,8F
....................         time_oyun= _mul(time_oyun,1000); 
0F00:  MOVFF  90,B9
0F04:  MOVFF  8F,B8
0F08:  MOVLW  03
0F0A:  MOVWF  xBB
0F0C:  MOVLW  E8
0F0E:  MOVWF  xBA
0F10:  RCALL  0B78
0F12:  MOVF   01,W
0F14:  MOVFF  03,92
0F18:  MOVFF  02,91
0F1C:  MOVFF  01,90
0F20:  MOVFF  00,8F
....................     }else{ 
0F24:  BRA    0F34
....................         time_oyun=150000LL;  //2.5 dk 
0F26:  CLRF   x92
0F28:  MOVLW  02
0F2A:  MOVWF  x91
0F2C:  MOVLW  49
0F2E:  MOVWF  x90
0F30:  MOVLW  F0
0F32:  MOVWF  x8F
....................     } 
....................     printf(lcd_putc,"\fOYUN SURE :"); 
0F34:  MOVLW  C2
0F36:  MOVWF  FF6
0F38:  MOVLW  01
0F3A:  MOVWF  FF7
0F3C:  RCALL  0A06
....................     printf(lcd_putc,"\n%Lu", time_oyun); 
0F3E:  MOVLW  0A
0F40:  MOVLB  1
0F42:  MOVWF  x0E
0F44:  MOVLB  0
0F46:  RCALL  0996
0F48:  MOVLW  41
0F4A:  MOVWF  FE9
0F4C:  MOVFF  92,105
0F50:  MOVFF  91,104
0F54:  MOVFF  90,103
0F58:  MOVFF  8F,102
0F5C:  RCALL  0ABA
....................     delay_ms(1250); 
0F5E:  MOVLW  05
0F60:  MOVWF  xAF
0F62:  CLRF   16
0F64:  BTFSC  FF2.6
0F66:  BSF    16.6
0F68:  BCF    FF2.6
0F6A:  BTFSC  FF2.7
0F6C:  BSF    16.7
0F6E:  BCF    FF2.7
0F70:  MOVLW  FA
0F72:  MOVLB  1
0F74:  MOVWF  x27
0F76:  MOVLB  0
0F78:  CALL   0748
0F7C:  BTFSC  16.6
0F7E:  BSF    FF2.6
0F80:  BTFSC  16.7
0F82:  BSF    FF2.7
0F84:  DECFSZ xAF,F
0F86:  BRA    0F62
....................      
....................     if(read_eeprom(EE_ADR_BIS_SEC_SURE)!=0xFF){ 
0F88:  MOVFF  FF2,AF
0F8C:  BCF    FF2.6
0F8E:  BCF    FF2.7
0F90:  MOVLW  05
0F92:  MOVWF  FA9
0F94:  BCF    FA6.6
0F96:  BCF    FA6.7
0F98:  BSF    FA6.0
0F9A:  MOVF   FA8,W
0F9C:  BTFSC  xAF.6
0F9E:  BSF    FF2.6
0FA0:  BTFSC  xAF.7
0FA2:  BSF    FF2.7
0FA4:  SUBLW  FF
0FA6:  BZ    0FE2
....................         bisiklet_secme_suresi=_mul(read_eeprom(EE_ADR_BIS_SEC_SURE),1000); 
0FA8:  MOVFF  FF2,AF
0FAC:  BCF    FF2.6
0FAE:  BCF    FF2.7
0FB0:  MOVLW  05
0FB2:  MOVWF  FA9
0FB4:  BCF    FA6.6
0FB6:  BCF    FA6.7
0FB8:  BSF    FA6.0
0FBA:  MOVF   FA8,W
0FBC:  BTFSC  xAF.6
0FBE:  BSF    FF2.6
0FC0:  BTFSC  xAF.7
0FC2:  BSF    FF2.7
0FC4:  MOVWF  xB0
0FC6:  CLRF   xB9
0FC8:  MOVFF  B0,B8
0FCC:  MOVLW  03
0FCE:  MOVWF  xBB
0FD0:  MOVLW  E8
0FD2:  MOVWF  xBA
0FD4:  RCALL  0B78
0FD6:  MOVF   01,W
0FD8:  MOVFF  01,98
0FDC:  MOVFF  00,97
....................     }else{ 
0FE0:  BRA    0FEA
....................         bisiklet_secme_suresi=10000L; 
0FE2:  MOVLW  27
0FE4:  MOVWF  x98
0FE6:  MOVLW  10
0FE8:  MOVWF  x97
....................     } 
....................     printf(lcd_putc,"\fBIS. SECME SURE:"); 
0FEA:  MOVLW  D0
0FEC:  MOVWF  FF6
0FEE:  MOVLW  01
0FF0:  MOVWF  FF7
0FF2:  RCALL  0A06
....................     printf(lcd_putc,"\n%Lu", bisiklet_secme_suresi); 
0FF4:  MOVLW  0A
0FF6:  MOVLB  1
0FF8:  MOVWF  x0E
0FFA:  MOVLB  0
0FFC:  RCALL  0996
0FFE:  MOVLW  10
1000:  MOVWF  FE9
1002:  MOVFF  98,C4
1006:  MOVFF  97,C3
100A:  RCALL  0BB4
....................     delay_ms(1250); 
100C:  MOVLW  05
100E:  MOVWF  xAF
1010:  CLRF   16
1012:  BTFSC  FF2.6
1014:  BSF    16.6
1016:  BCF    FF2.6
1018:  BTFSC  FF2.7
101A:  BSF    16.7
101C:  BCF    FF2.7
101E:  MOVLW  FA
1020:  MOVLB  1
1022:  MOVWF  x27
1024:  MOVLB  0
1026:  CALL   0748
102A:  BTFSC  16.6
102C:  BSF    FF2.6
102E:  BTFSC  16.7
1030:  BSF    FF2.7
1032:  DECFSZ xAF,F
1034:  BRA    1010
....................      
....................     if(read_eeprom(EE_ADR_MAX_PWM)!=0xFF && read_eeprom(EE_ADR_MAX_PWM+1)!=0xFF){ 
1036:  MOVFF  FF2,AF
103A:  BCF    FF2.6
103C:  BCF    FF2.7
103E:  MOVLW  08
1040:  MOVWF  FA9
1042:  BCF    FA6.6
1044:  BCF    FA6.7
1046:  BSF    FA6.0
1048:  MOVF   FA8,W
104A:  BTFSC  xAF.6
104C:  BSF    FF2.6
104E:  BTFSC  xAF.7
1050:  BSF    FF2.7
1052:  SUBLW  FF
1054:  BZ    10BC
1056:  MOVFF  FF2,B0
105A:  BCF    FF2.6
105C:  BCF    FF2.7
105E:  MOVLW  09
1060:  MOVWF  FA9
1062:  BCF    FA6.6
1064:  BCF    FA6.7
1066:  BSF    FA6.0
1068:  MOVF   FA8,W
106A:  BTFSC  xB0.6
106C:  BSF    FF2.6
106E:  BTFSC  xB0.7
1070:  BSF    FF2.7
1072:  SUBLW  FF
1074:  BZ    10BC
....................        pwm_max_deger=make16(read_eeprom(EE_ADR_MAX_PWM+1),read_eeprom(EE_ADR_MAX_PWM)); 
1076:  MOVFF  FF2,AF
107A:  BCF    FF2.6
107C:  BCF    FF2.7
107E:  MOVLW  09
1080:  MOVWF  FA9
1082:  BCF    FA6.6
1084:  BCF    FA6.7
1086:  BSF    FA6.0
1088:  MOVF   FA8,W
108A:  BTFSC  xAF.6
108C:  BSF    FF2.6
108E:  BTFSC  xAF.7
1090:  BSF    FF2.7
1092:  MOVWF  xB0
1094:  MOVFF  FF2,B1
1098:  BCF    FF2.6
109A:  BCF    FF2.7
109C:  MOVLW  08
109E:  MOVWF  FA9
10A0:  BCF    FA6.6
10A2:  BCF    FA6.7
10A4:  BSF    FA6.0
10A6:  MOVF   FA8,W
10A8:  BTFSC  xB1.6
10AA:  BSF    FF2.6
10AC:  BTFSC  xB1.7
10AE:  BSF    FF2.7
10B0:  MOVWF  xB2
10B2:  MOVFF  B0,46
10B6:  MOVFF  B2,45
....................     }else{ 
10BA:  BRA    10C4
....................          pwm_max_deger=450; 
10BC:  MOVLW  01
10BE:  MOVWF  46
10C0:  MOVLW  C2
10C2:  MOVWF  45
....................     } 
....................      
....................     printf(lcd_putc,"\fMAX HIZ:"); 
10C4:  MOVLW  E2
10C6:  MOVWF  FF6
10C8:  MOVLW  01
10CA:  MOVWF  FF7
10CC:  RCALL  0A06
....................     printf(lcd_putc,"\n%Lu",pwm_max_deger); 
10CE:  MOVLW  0A
10D0:  MOVLB  1
10D2:  MOVWF  x0E
10D4:  MOVLB  0
10D6:  RCALL  0996
10D8:  MOVLW  10
10DA:  MOVWF  FE9
10DC:  MOVFF  46,C4
10E0:  MOVFF  45,C3
10E4:  RCALL  0BB4
....................     delay_ms(1250); 
10E6:  MOVLW  05
10E8:  MOVWF  xAF
10EA:  CLRF   16
10EC:  BTFSC  FF2.6
10EE:  BSF    16.6
10F0:  BCF    FF2.6
10F2:  BTFSC  FF2.7
10F4:  BSF    16.7
10F6:  BCF    FF2.7
10F8:  MOVLW  FA
10FA:  MOVLB  1
10FC:  MOVWF  x27
10FE:  MOVLB  0
1100:  CALL   0748
1104:  BTFSC  16.6
1106:  BSF    FF2.6
1108:  BTFSC  16.7
110A:  BSF    FF2.7
110C:  DECFSZ xAF,F
110E:  BRA    10EA
....................      
....................     if(read_eeprom(EE_ADR_MAX_SES)!=0xFF){ 
1110:  MOVFF  FF2,AF
1114:  BCF    FF2.6
1116:  BCF    FF2.7
1118:  MOVLW  07
111A:  MOVWF  FA9
111C:  BCF    FA6.6
111E:  BCF    FA6.7
1120:  BSF    FA6.0
1122:  MOVF   FA8,W
1124:  BTFSC  xAF.6
1126:  BSF    FF2.6
1128:  BTFSC  xAF.7
112A:  BSF    FF2.7
112C:  SUBLW  FF
112E:  BZ    1150
....................         dfPlayer_ses=read_eeprom(EE_ADR_MAX_SES); 
1130:  MOVFF  FF2,AF
1134:  BCF    FF2.6
1136:  BCF    FF2.7
1138:  MOVLW  07
113A:  MOVWF  FA9
113C:  BCF    FA6.6
113E:  BCF    FA6.7
1140:  BSF    FA6.0
1142:  MOVF   FA8,W
1144:  BTFSC  xAF.6
1146:  BSF    FF2.6
1148:  BTFSC  xAF.7
114A:  BSF    FF2.7
114C:  MOVWF  x9B
....................     }else{ 
114E:  BRA    1154
....................         dfPlayer_ses=20; 
1150:  MOVLW  14
1152:  MOVWF  x9B
....................     } 
....................     printf(lcd_putc,"\fMP3 Ses:"); 
1154:  MOVLW  EC
1156:  MOVWF  FF6
1158:  MOVLW  01
115A:  MOVWF  FF7
115C:  RCALL  0A06
....................     printf(lcd_putc,"\n%u", dfPlayer_ses); 
115E:  MOVLW  0A
1160:  MOVLB  1
1162:  MOVWF  x0E
1164:  MOVLB  0
1166:  RCALL  0996
1168:  MOVFF  9B,B5
116C:  MOVLW  1B
116E:  MOVWF  xB6
1170:  RCALL  0C9A
....................     delay_ms(1250); 
1172:  MOVLW  05
1174:  MOVWF  xAF
1176:  CLRF   16
1178:  BTFSC  FF2.6
117A:  BSF    16.6
117C:  BCF    FF2.6
117E:  BTFSC  FF2.7
1180:  BSF    16.7
1182:  BCF    FF2.7
1184:  MOVLW  FA
1186:  MOVLB  1
1188:  MOVWF  x27
118A:  MOVLB  0
118C:  CALL   0748
1190:  BTFSC  16.6
1192:  BSF    FF2.6
1194:  BTFSC  16.7
1196:  BSF    FF2.7
1198:  DECFSZ xAF,F
119A:  BRA    1176
....................      
....................      if(read_eeprom(EE_ADR_JTN_SYS)!=0xFF){ 
119C:  MOVFF  FF2,AF
11A0:  BCF    FF2.6
11A2:  BCF    FF2.7
11A4:  MOVLW  06
11A6:  MOVWF  FA9
11A8:  BCF    FA6.6
11AA:  BCF    FA6.7
11AC:  BSF    FA6.0
11AE:  MOVF   FA8,W
11B0:  BTFSC  xAF.6
11B2:  BSF    FF2.6
11B4:  BTFSC  xAF.7
11B6:  BSF    FF2.7
11B8:  SUBLW  FF
11BA:  BZ    11DC
....................         calisma_jeton_sayisi=read_eeprom(EE_ADR_JTN_SYS); 
11BC:  MOVFF  FF2,AF
11C0:  BCF    FF2.6
11C2:  BCF    FF2.7
11C4:  MOVLW  06
11C6:  MOVWF  FA9
11C8:  BCF    FA6.6
11CA:  BCF    FA6.7
11CC:  BSF    FA6.0
11CE:  MOVF   FA8,W
11D0:  BTFSC  xAF.6
11D2:  BSF    FF2.6
11D4:  BTFSC  xAF.7
11D6:  BSF    FF2.7
11D8:  MOVWF  x9C
....................     }else{ 
11DA:  BRA    11DE
....................         calisma_jeton_sayisi=0; 
11DC:  CLRF   x9C
....................     } 
....................     printf(lcd_putc,"\fCALISMA JETON:"); 
11DE:  MOVLW  F6
11E0:  MOVWF  FF6
11E2:  MOVLW  01
11E4:  MOVWF  FF7
11E6:  RCALL  0A06
....................     printf(lcd_putc,"\n%u", calisma_jeton_sayisi); 
11E8:  MOVLW  0A
11EA:  MOVLB  1
11EC:  MOVWF  x0E
11EE:  MOVLB  0
11F0:  CALL   0996
11F4:  MOVFF  9C,B5
11F8:  MOVLW  1B
11FA:  MOVWF  xB6
11FC:  RCALL  0C9A
....................     delay_ms(1250); 
11FE:  MOVLW  05
1200:  MOVWF  xAF
1202:  CLRF   16
1204:  BTFSC  FF2.6
1206:  BSF    16.6
1208:  BCF    FF2.6
120A:  BTFSC  FF2.7
120C:  BSF    16.7
120E:  BCF    FF2.7
1210:  MOVLW  FA
1212:  MOVLB  1
1214:  MOVWF  x27
1216:  MOVLB  0
1218:  CALL   0748
121C:  BTFSC  16.6
121E:  BSF    FF2.6
1220:  BTFSC  16.7
1222:  BSF    FF2.7
1224:  DECFSZ xAF,F
1226:  BRA    1202
1228:  GOTO   5836 (RETURN)
....................     
.................... } 
....................  
....................  
.................... #include "menu_islem.c" 
.................... #include "tanimlamalar.h" 
.................... /*  
....................  * File:   tanimlamalar.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 22 Þubat 2019 Cuma, 08:43 
....................  */ 
....................  
.................... #ifndef TANIMLAMALAR_H 
.................... #define	TANIMLAMALAR_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................     #define led0 PIN_B3 
....................     #define JTN_PIN PIN_B0 
....................     #define JTN2_PIN PIN_B7 
....................  
....................     #define HIZ1_SENS_PIN PIN_B1 
....................     #define HIZ2_SENS_PIN PIN_B2 
....................  
....................     #define TUR1_SENS_PIN PIN_B5 
....................     #define TUR2_SENS_PIN PIN_B4 
....................  
....................     #define BTN1_PIN PIN_A4 
....................     #define BTN2_PIN PIN_A5 
....................     #define BTN3_PIN PIN_E2 
....................  
....................     #define BIS_BTN1_PIN PIN_A2 
....................     #define BIS_BTN2_PIN PIN_A3 
....................  
....................     #define ADC_KANAL_M2 0  //SENS_B 
....................     #define ADC_KANAL_M1 1  //SENS_A 
....................  
....................     #define PWM_DUTY_MAX_4_KHZ      500 
....................     #define PWM_DUTY_MAX_2B5_KHZ    800 
....................  
....................     #define F_MAX 10   //saniyedeki max tur sayýsý, buþekildse max 100Hz olur 
....................     //#define DELAY_OLCUM ((1/F_MAX)*1000)/10  // mS/10  F_MAX=100Hz iken delay=1mS 
....................     #define DELAY_OLCUM 10 
....................  
....................      
....................     #define panel1_komut(komut)fprintf(Panel1Serial,"%cc",komut) 
....................     #define panel2_komut(komut)fprintf(Panel2Serial,"%cc",komut) 
....................  
....................     #define M1_PWM  10 
....................     #define M2_PWM  11 
....................  
....................     #define analogWrite(_pwm_pin, _pwm_deger)                           \ 
....................                         if(_pwm_pin==M1_PWM) set_pwm1_duty(_pwm_deger); \ 
....................                         if(_pwm_pin==M2_PWM) set_pwm2_duty(_pwm_deger); \ 
....................  
....................     #define jetonKontrol(pin) if(!input(pin)){                    \ 
....................                                                                   \ 
....................                             delay_ms(500);                        \ 
....................                             calismaJetonSay++;                    \ 
....................                            }                                      \ 
....................                                                                   \ 
....................                            if((calisma_jeton_sayisi>0 && calismaJetonSay>=calisma_jeton_sayisi)) \ 
....................                            {                                            \ 
....................                                 jetonAtildi=TRUE;                       \ 
....................                                 calismaJetonSay=0;                      \ 
....................                                 jetonSay++;                             \ 
....................                            }                                            \ 
....................                            else{                                        \ 
....................                                 jetonAtildi=TRUE;                       \ 
....................                                 jetonSay++;                             \ 
....................                                 }                                       \ 
....................  
....................     #define JETON 'J' 
....................  
....................     #define OYUNCU_MOD_SECIMI 'M' 
.................... 	#define OYUNCU_MOD_SECIM_SONU 'm' 
....................  
.................... 	#define OYUNCU_HIZ_VERI 'V' 
.................... 	#define OYUNCU2_HIZ_VERI 'v' 
....................  
.................... 	#define OYUNCU_TEKERLEK_DONME_SAYISI 'D' 
.................... 	#define OYUNCU2_TEKERLEK_DONME_SAYISI 'd' 
....................  
.................... 	#define OYUNCU_TUR_SAYISI 'T' 
....................  
.................... 	#define OYUNCU_YARIS_SIRA1 '1' 
.................... 	#define OYUNCU_YARIS_SIRA2 '2' 
.................... 	#define OYUNCU_YARIS_SIRA0 '0' 
....................  
.................... 	#define OYUNCU1 '3' 
.................... 	#define OYUNCU2 '4' 
.................... 	#define SISTEM '5' 
....................  
.................... 	#define OYUNCU_BISIKLET_SECIMI 'B' 
....................     #define OYUNCU1_SISTEM 'X' 
....................     #define OYUNCU1_OYUNCU2'x' 
....................  
.................... 	#define JETON_CHAR 'J' 
.................... 	#define JETON_AT 'A' 
....................  
.................... 	#define OYUN_MOD_SECME_SURESI 5000 
....................     //#define BISIKLET_SECME_SURESI 10000 
....................     #define MOD_SECILMEDI (-1) 
.................... 	#define BAY_MOD 0 
.................... 	#define BAYAN_MOD 1 
.................... 	#define COCUK_MOD 2 
....................  
.................... 	#define OYUN_OYNANAN_SURE 'O' 
.................... 	#define OYUN_BITTI 'E' 
....................  
.................... 	#define BOS_ANIM_EKRANI 'K' 
....................  
....................     #define ZAMAN_SAY 'Z' 
....................     #define MOTOR_YOK 'Q' 
....................     #define MOTOR_VAR 'q' 
....................  
....................  
.................... 	#define BISIKLET_MAX_HIZ    71 
.................... 	//#define PWM_MAX_DEGER       400 
....................     #define PIST_UZUNLUK        8.51f 
....................                             
.................... /// mp3-wav index 
.................... 	#define wav_atKisnemesi     1 
.................... 	#define wav_atKosmasi       2 
.................... 	#define wav_suDamlasi       3 
.................... 	#define wav_heySesi         4 
.................... 	#define wav_alkisSesi       5 
.................... 	#define wav_oyunBitti       6 
.................... 	#define wav_getReady        7 
.................... 	#define wav_whoosh          8 
.................... 	#define wav_jeton           9 
.................... 	#define wav_remix           10 
.................... 	#define wav_remix2          11 
.................... 	#define wav_waterDrop       12 
.................... 	#define mp3_adele_Rolling   14 
.................... 	#define wav_duduk_basla     15 
.................... 	#define wav_ding            16 
.................... 	#define mp3_mars            17 
.................... 	#define mp3_getlowve_araba	18 
....................     #define mp3_beep_uyari      19 
....................  
....................      //// bosta rastgele mp3 müzik 
....................      
....................     #define mp3_adele_Rolling   20 
....................     #define mp3_anitta          21 
....................     #define mp3_love_lo         22 
....................     #define mp3_remix           23 
....................     #define mp3_dejavu          24 
....................     #define mp3_rain            25 
....................     #define mp3_aweli           26 
....................     ///// 
....................     #define mp3_buton           27 
....................     #define mp3_buton2          28 
....................      
.................... 	#define wav_remix_sure 200000 //(3*60+20)*1000  //3:20 mS degeri.... 
.................... 	#define wav_atKisnemesi_sure  1500 
.................... 	#define wav_atKosmasi_sure    2000 
.................... 	#define wav_whoosh_sure  300//350 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TANIMLAMALAR_H */ 
....................  
....................  
....................  
.................... #define BUTON_SOL_PIN PIN_A4 
.................... #define BUTON_ONAY_PIN PIN_A5 
.................... #define BUTON_SAG_PIN PIN_E2 
....................  
.................... #define BUTON_SOL 's' 
.................... #define BUTON_ONAY 'o' 
.................... #define BUTON_SAG 'g' 
....................  
.................... #define MENU_SAYISI 8 
....................  
.................... #define BUTON_GECIKME 350 
....................  
....................  
.................... char btn_getir(){ 
....................      
....................     if(!input(BUTON_SOL_PIN)){ 
*
3CE0:  BTFSC  F80.4
3CE2:  BRA    3D44
....................         delay_ms(BUTON_GECIKME); 
3CE4:  MOVLW  02
3CE6:  MOVWF  xC3
3CE8:  CLRF   16
3CEA:  BTFSC  FF2.6
3CEC:  BSF    16.6
3CEE:  BCF    FF2.6
3CF0:  BTFSC  FF2.7
3CF2:  BSF    16.7
3CF4:  BCF    FF2.7
3CF6:  MOVLW  AF
3CF8:  MOVLB  1
3CFA:  MOVWF  x27
3CFC:  MOVLB  0
3CFE:  CALL   0748
3D02:  BTFSC  16.6
3D04:  BSF    FF2.6
3D06:  BTFSC  16.7
3D08:  BSF    FF2.7
3D0A:  DECFSZ xC3,F
3D0C:  BRA    3CE8
....................         mp3_stop();delay_ms(100); 
3D0E:  CALL   1302
3D12:  CLRF   16
3D14:  BTFSC  FF2.6
3D16:  BSF    16.6
3D18:  BCF    FF2.6
3D1A:  BTFSC  FF2.7
3D1C:  BSF    16.7
3D1E:  BCF    FF2.7
3D20:  MOVLW  64
3D22:  MOVLB  1
3D24:  MOVWF  x27
3D26:  MOVLB  0
3D28:  CALL   0748
3D2C:  BTFSC  16.6
3D2E:  BSF    FF2.6
3D30:  BTFSC  16.7
3D32:  BSF    FF2.7
....................         mp3_play(mp3_buton); 
3D34:  CLRF   xFF
3D36:  MOVLW  1B
3D38:  MOVWF  xFE
3D3A:  CALL   1658
....................         return BUTON_SOL; 
3D3E:  MOVLW  73
3D40:  MOVWF  01
3D42:  BRA    3E0A
....................     } 
....................      if(!input(BUTON_ONAY_PIN)){ 
3D44:  BTFSC  F80.5
3D46:  BRA    3DA8
....................         delay_ms(BUTON_GECIKME); 
3D48:  MOVLW  02
3D4A:  MOVWF  xC3
3D4C:  CLRF   16
3D4E:  BTFSC  FF2.6
3D50:  BSF    16.6
3D52:  BCF    FF2.6
3D54:  BTFSC  FF2.7
3D56:  BSF    16.7
3D58:  BCF    FF2.7
3D5A:  MOVLW  AF
3D5C:  MOVLB  1
3D5E:  MOVWF  x27
3D60:  MOVLB  0
3D62:  CALL   0748
3D66:  BTFSC  16.6
3D68:  BSF    FF2.6
3D6A:  BTFSC  16.7
3D6C:  BSF    FF2.7
3D6E:  DECFSZ xC3,F
3D70:  BRA    3D4C
....................         mp3_stop();delay_ms(100); 
3D72:  CALL   1302
3D76:  CLRF   16
3D78:  BTFSC  FF2.6
3D7A:  BSF    16.6
3D7C:  BCF    FF2.6
3D7E:  BTFSC  FF2.7
3D80:  BSF    16.7
3D82:  BCF    FF2.7
3D84:  MOVLW  64
3D86:  MOVLB  1
3D88:  MOVWF  x27
3D8A:  MOVLB  0
3D8C:  CALL   0748
3D90:  BTFSC  16.6
3D92:  BSF    FF2.6
3D94:  BTFSC  16.7
3D96:  BSF    FF2.7
....................         mp3_play(mp3_buton); 
3D98:  CLRF   xFF
3D9A:  MOVLW  1B
3D9C:  MOVWF  xFE
3D9E:  CALL   1658
....................         return BUTON_ONAY; 
3DA2:  MOVLW  6F
3DA4:  MOVWF  01
3DA6:  BRA    3E0A
....................     } 
....................     if(!input(BUTON_SAG_PIN)){ 
3DA8:  BTFSC  F84.2
3DAA:  BRA    3E0A
....................         delay_ms(BUTON_GECIKME); 
3DAC:  MOVLW  02
3DAE:  MOVWF  xC3
3DB0:  CLRF   16
3DB2:  BTFSC  FF2.6
3DB4:  BSF    16.6
3DB6:  BCF    FF2.6
3DB8:  BTFSC  FF2.7
3DBA:  BSF    16.7
3DBC:  BCF    FF2.7
3DBE:  MOVLW  AF
3DC0:  MOVLB  1
3DC2:  MOVWF  x27
3DC4:  MOVLB  0
3DC6:  CALL   0748
3DCA:  BTFSC  16.6
3DCC:  BSF    FF2.6
3DCE:  BTFSC  16.7
3DD0:  BSF    FF2.7
3DD2:  DECFSZ xC3,F
3DD4:  BRA    3DB0
....................         mp3_stop();delay_ms(100); 
3DD6:  CALL   1302
3DDA:  CLRF   16
3DDC:  BTFSC  FF2.6
3DDE:  BSF    16.6
3DE0:  BCF    FF2.6
3DE2:  BTFSC  FF2.7
3DE4:  BSF    16.7
3DE6:  BCF    FF2.7
3DE8:  MOVLW  64
3DEA:  MOVLB  1
3DEC:  MOVWF  x27
3DEE:  MOVLB  0
3DF0:  CALL   0748
3DF4:  BTFSC  16.6
3DF6:  BSF    FF2.6
3DF8:  BTFSC  16.7
3DFA:  BSF    FF2.7
....................         mp3_play(mp3_buton); 
3DFC:  CLRF   xFF
3DFE:  MOVLW  1B
3E00:  MOVWF  xFE
3E02:  CALL   1658
....................         return BUTON_SAG; 
3E06:  MOVLW  67
3E08:  MOVWF  01
....................     } 
3E0A:  RETURN 0
.................... } 
....................  
.................... char uzunBasBtnGetir(unsigned long btn_pin, unsigned long sure){ 
*
3BEE:  CLRF   xB4
3BF0:  CLRF   xB3
....................     unsigned long x=0; 
....................     // 
....................     if(!input(btn_pin)){ 
3BF2:  MOVFF  AF,B5
3BF6:  MOVLW  0F
3BF8:  MOVWF  xB7
3BFA:  MOVLW  80
3BFC:  MOVWF  xB6
3BFE:  RCALL  3BC0
3C00:  BTFSC  01.0
3C02:  BRA    3CDC
....................         delay_ms(BUTON_GECIKME); 
3C04:  MOVLW  02
3C06:  MOVWF  xB5
3C08:  CLRF   16
3C0A:  BTFSC  FF2.6
3C0C:  BSF    16.6
3C0E:  BCF    FF2.6
3C10:  BTFSC  FF2.7
3C12:  BSF    16.7
3C14:  BCF    FF2.7
3C16:  MOVLW  AF
3C18:  MOVLB  1
3C1A:  MOVWF  x27
3C1C:  MOVLB  0
3C1E:  CALL   0748
3C22:  BTFSC  16.6
3C24:  BSF    FF2.6
3C26:  BTFSC  16.7
3C28:  BSF    FF2.7
3C2A:  DECFSZ xB5,F
3C2C:  BRA    3C08
....................        //  printf(lcd_putc,"\f......");  
....................         do{ 
....................             x++; 
3C2E:  INCF   xB3,F
3C30:  BTFSC  FD8.2
3C32:  INCF   xB4,F
....................             if(x>sure){ 
3C34:  MOVF   xB2,W
3C36:  SUBWF  xB4,W
3C38:  BNC   3C78
3C3A:  BNZ   3C42
3C3C:  MOVF   xB3,W
3C3E:  SUBWF  xB1,W
3C40:  BC    3C78
....................  
....................                 if(btn_pin==BUTON_SOL_PIN) return BUTON_SOL; 
3C42:  MOVF   xAF,W
3C44:  SUBLW  04
3C46:  BNZ   3C54
3C48:  MOVF   xB0,W
3C4A:  SUBLW  7C
3C4C:  BNZ   3C54
3C4E:  MOVLW  73
3C50:  MOVWF  01
3C52:  BRA    3CDC
....................                 if(btn_pin==BUTON_ONAY_PIN) return BUTON_ONAY; 
3C54:  MOVF   xAF,W
3C56:  SUBLW  05
3C58:  BNZ   3C66
3C5A:  MOVF   xB0,W
3C5C:  SUBLW  7C
3C5E:  BNZ   3C66
3C60:  MOVLW  6F
3C62:  MOVWF  01
3C64:  BRA    3CDC
....................                 if(btn_pin==BUTON_SAG_PIN) return BUTON_SAG; 
3C66:  MOVF   xAF,W
3C68:  SUBLW  22
3C6A:  BNZ   3C78
3C6C:  MOVF   xB0,W
3C6E:  SUBLW  7C
3C70:  BNZ   3C78
3C72:  MOVLW  67
3C74:  MOVWF  01
3C76:  BRA    3CDC
3C78:  CLRF   16
3C7A:  BTFSC  FF2.6
3C7C:  BSF    16.6
3C7E:  BCF    FF2.6
3C80:  BTFSC  FF2.7
3C82:  BSF    16.7
3C84:  BCF    FF2.7
....................             } 
....................            // printf(lcd_putc,"\n%lu",x);  
....................             delay_ms(1); 
3C86:  MOVLW  01
3C88:  MOVLB  1
3C8A:  MOVWF  x27
3C8C:  MOVLB  0
3C8E:  CALL   0748
3C92:  BTFSC  16.6
3C94:  BSF    FF2.6
3C96:  BTFSC  16.7
3C98:  BSF    FF2.7
....................            //if(input(btn_pin))break; 
....................         }while(!input(btn_pin)); 
3C9A:  MOVFF  AF,B5
3C9E:  MOVLW  0F
3CA0:  MOVWF  xB7
3CA2:  MOVLW  80
3CA4:  MOVWF  xB6
3CA6:  RCALL  3BC0
3CA8:  BTFSS  01.0
3CAA:  BRA    3C2E
....................         mp3_stop();delay_ms(100); 
3CAC:  CALL   1302
3CB0:  CLRF   16
3CB2:  BTFSC  FF2.6
3CB4:  BSF    16.6
3CB6:  BCF    FF2.6
3CB8:  BTFSC  FF2.7
3CBA:  BSF    16.7
3CBC:  BCF    FF2.7
3CBE:  MOVLW  64
3CC0:  MOVLB  1
3CC2:  MOVWF  x27
3CC4:  MOVLB  0
3CC6:  CALL   0748
3CCA:  BTFSC  16.6
3CCC:  BSF    FF2.6
3CCE:  BTFSC  16.7
3CD0:  BSF    FF2.7
....................         mp3_play(mp3_buton); 
3CD2:  CLRF   xFF
3CD4:  MOVLW  1B
3CD6:  MOVWF  xFE
3CD8:  CALL   1658
....................     } 
3CDC:  GOTO   5ABA (RETURN)
.................... } 
....................  
.................... void lcd_menu_sec(int sec){ 
....................      
....................         switch(sec){ 
*
3E0C:  MOVF   xB2,W
3E0E:  ADDLW  F7
3E10:  BTFSC  FD8.0
3E12:  BRA    3F02
3E14:  ADDLW  09
3E16:  GOTO   3F06
....................             case 0: 
....................                 printf(lcd_putc,"\f    < MENU >");  
3E1A:  MOVLW  06
3E1C:  MOVWF  FF6
3E1E:  MOVLW  02
3E20:  MOVWF  FF7
3E22:  CALL   0A06
....................                 printf(lcd_putc,"\n    << <> >>");  
3E26:  MOVLW  14
3E28:  MOVWF  FF6
3E2A:  MOVLW  02
3E2C:  MOVWF  FF7
3E2E:  CALL   0A06
....................                 break; 
3E32:  BRA    3F02
....................             case 1: 
....................                 printf(lcd_putc,"\f 1-OYUN Sure");  
3E34:  MOVLW  22
3E36:  MOVWF  FF6
3E38:  MOVLW  02
3E3A:  MOVWF  FF7
3E3C:  CALL   0A06
....................                 printf(lcd_putc,"\n    << <> >>"); 
3E40:  MOVLW  30
3E42:  MOVWF  FF6
3E44:  MOVLW  02
3E46:  MOVWF  FF7
3E48:  CALL   0A06
....................                  break; 
3E4C:  BRA    3F02
....................             case 2: 
....................                  printf(lcd_putc,"\f 2-Secme Suresi");  
3E4E:  MOVLW  3E
3E50:  MOVWF  FF6
3E52:  MOVLW  02
3E54:  MOVWF  FF7
3E56:  CALL   0A06
....................                  printf(lcd_putc,"\n    << <> >>"); 
3E5A:  MOVLW  50
3E5C:  MOVWF  FF6
3E5E:  MOVLW  02
3E60:  MOVWF  FF7
3E62:  CALL   0A06
....................                  break; 
3E66:  BRA    3F02
....................             case 3: 
....................                  printf(lcd_putc,"\f 3-Motor TEST");  
3E68:  MOVLW  5E
3E6A:  MOVWF  FF6
3E6C:  MOVLW  02
3E6E:  MOVWF  FF7
3E70:  CALL   0A06
....................                  printf(lcd_putc,"\n    << <> >>"); 
3E74:  MOVLW  6E
3E76:  MOVWF  FF6
3E78:  MOVLW  02
3E7A:  MOVWF  FF7
3E7C:  CALL   0A06
....................                  break; 
3E80:  BRA    3F02
....................  
....................             case 4: 
....................                  printf(lcd_putc,"\f 4-Sensor TEST");  
3E82:  MOVLW  7C
3E84:  MOVWF  FF6
3E86:  MOVLW  02
3E88:  MOVWF  FF7
3E8A:  CALL   0A06
....................                  printf(lcd_putc,"\n    << <> >>"); 
3E8E:  MOVLW  8C
3E90:  MOVWF  FF6
3E92:  MOVLW  02
3E94:  MOVWF  FF7
3E96:  CALL   0A06
....................                  break; 
3E9A:  BRA    3F02
....................              case 5: 
....................                  printf(lcd_putc,"\f 5-SES");  
3E9C:  MOVLW  9A
3E9E:  MOVWF  FF6
3EA0:  MOVLW  02
3EA2:  MOVWF  FF7
3EA4:  CALL   0A06
....................                  printf(lcd_putc,"\n    << <> >>"); 
3EA8:  MOVLW  A2
3EAA:  MOVWF  FF6
3EAC:  MOVLW  02
3EAE:  MOVWF  FF7
3EB0:  CALL   0A06
....................                  break;   
3EB4:  BRA    3F02
....................             case 6: 
....................                  printf(lcd_putc,"\f 6-JETON Sayisi");  
3EB6:  MOVLW  B0
3EB8:  MOVWF  FF6
3EBA:  MOVLW  02
3EBC:  MOVWF  FF7
3EBE:  CALL   0A06
....................                  printf(lcd_putc,"\n    << <> >>"); 
3EC2:  MOVLW  C2
3EC4:  MOVWF  FF6
3EC6:  MOVLW  02
3EC8:  MOVWF  FF7
3ECA:  CALL   0A06
....................                  break; 
3ECE:  BRA    3F02
....................             case 7: 
....................                  printf(lcd_putc,"\f 7-RESET");  
3ED0:  MOVLW  D0
3ED2:  MOVWF  FF6
3ED4:  MOVLW  02
3ED6:  MOVWF  FF7
3ED8:  CALL   0A06
....................                  printf(lcd_putc,"\n    << <> >>"); 
3EDC:  MOVLW  DA
3EDE:  MOVWF  FF6
3EE0:  MOVLW  02
3EE2:  MOVWF  FF7
3EE4:  CALL   0A06
....................                  break; 
3EE8:  BRA    3F02
....................             case 8: 
....................                  printf(lcd_putc,"\f 8-CIKIS");  
3EEA:  MOVLW  E8
3EEC:  MOVWF  FF6
3EEE:  MOVLW  02
3EF0:  MOVWF  FF7
3EF2:  CALL   0A06
....................                  printf(lcd_putc,"\n    << <> >>"); 
3EF6:  MOVLW  F2
3EF8:  MOVWF  FF6
3EFA:  MOVLW  02
3EFC:  MOVWF  FF7
3EFE:  CALL   0A06
....................                  break; 
....................         } 
3F02:  GOTO   54B4 (RETURN)
.................... } 
....................  
.................... int oyun_sure_kaydet(int n){ 
*
3F42:  CLRF   xB6
3F44:  CLRF   xB5
3F46:  MOVLW  40
3F48:  MOVWF  xB4
3F4A:  MOVLW  7F
3F4C:  MOVWF  xB3
3F4E:  CLRF   xB7
....................     float oyun_sure=1.5f; 
....................     int btn=0; 
....................      
....................     oyun_sure=read_eeprom(EE_ADR_OYUN_SURE)/10.0f; 
3F50:  MOVFF  FF2,B8
3F54:  BCF    FF2.6
3F56:  BCF    FF2.7
3F58:  MOVLW  04
3F5A:  MOVWF  FA9
3F5C:  BCF    FA6.6
3F5E:  BCF    FA6.7
3F60:  BSF    FA6.0
3F62:  MOVF   FA8,W
3F64:  BTFSC  xB8.6
3F66:  BSF    FF2.6
3F68:  BTFSC  xB8.7
3F6A:  BSF    FF2.7
3F6C:  MOVLB  1
3F6E:  CLRF   x01
3F70:  MOVWF  x00
3F72:  MOVLB  0
3F74:  CALL   1888
3F78:  MOVFF  03,105
3F7C:  MOVFF  02,104
3F80:  MOVFF  01,103
3F84:  MOVFF  00,102
3F88:  MOVLB  1
3F8A:  CLRF   x09
3F8C:  CLRF   x08
3F8E:  MOVLW  20
3F90:  MOVWF  x07
3F92:  MOVLW  82
3F94:  MOVWF  x06
3F96:  MOVLB  0
3F98:  CALL   1E26
3F9C:  MOVFF  03,B6
3FA0:  MOVFF  02,B5
3FA4:  MOVFF  01,B4
3FA8:  MOVFF  00,B3
....................     if(oyun_sure>10.0) oyun_sure=2.5f; 
3FAC:  MOVLB  1
3FAE:  CLRF   x01
3FB0:  CLRF   x00
3FB2:  MOVLW  20
3FB4:  MOVLB  0
3FB6:  MOVWF  xFF
3FB8:  MOVLW  82
3FBA:  MOVWF  xFE
3FBC:  MOVFF  B6,105
3FC0:  MOVFF  B5,104
3FC4:  MOVFF  B4,103
3FC8:  MOVFF  B3,102
3FCC:  CALL   1D84
3FD0:  BNC   3FDE
3FD2:  CLRF   xB6
3FD4:  CLRF   xB5
3FD6:  MOVLW  20
3FD8:  MOVWF  xB4
3FDA:  MOVLW  80
3FDC:  MOVWF  xB3
....................      
....................     printf(lcd_putc,"\fSure : %f dk.",oyun_sure);  
3FDE:  MOVLW  00
3FE0:  MOVWF  FF6
3FE2:  MOVLW  03
3FE4:  MOVWF  FF7
3FE6:  MOVLW  08
3FE8:  MOVLB  1
3FEA:  MOVWF  x02
3FEC:  MOVLB  0
3FEE:  CALL   162E
3FF2:  MOVLW  89
3FF4:  MOVWF  FE9
3FF6:  MOVFF  B6,101
3FFA:  MOVFF  B5,100
3FFE:  MOVFF  B4,FF
4002:  MOVFF  B3,FE
4006:  MOVLW  02
4008:  MOVLB  1
400A:  MOVWF  x02
400C:  MOVLB  0
400E:  CALL   24B4
4012:  MOVLW  0A
4014:  MOVWF  FF6
4016:  MOVLW  03
4018:  MOVWF  FF7
401A:  MOVLW  04
401C:  MOVLB  1
401E:  MOVWF  x02
4020:  MOVLB  0
4022:  CALL   162E
....................     printf(lcd_putc,"\n    << <> >>"); 
4026:  MOVLW  10
4028:  MOVWF  FF6
402A:  MOVLW  03
402C:  MOVWF  FF7
402E:  CALL   0A06
....................     do{ 
....................        btn=btn_getir(); 
4032:  RCALL  3CE0
4034:  MOVFF  01,B7
....................        if(btn==BUTON_SOL){ 
4038:  MOVF   xB7,W
403A:  SUBLW  73
403C:  BNZ   40A2
....................            oyun_sure-=0.5f; 
403E:  BSF    FD8.1
4040:  MOVFF  B6,101
4044:  MOVFF  B5,100
4048:  MOVFF  B4,FF
404C:  MOVFF  B3,FE
4050:  MOVLB  1
4052:  CLRF   x05
4054:  CLRF   x04
4056:  CLRF   x03
4058:  MOVLW  7E
405A:  MOVWF  x02
405C:  MOVLB  0
405E:  CALL   2040
4062:  MOVFF  03,B6
4066:  MOVFF  02,B5
406A:  MOVFF  01,B4
406E:  MOVFF  00,B3
....................            if(oyun_sure<1.0f) oyun_sure=15.0f; 
4072:  MOVFF  B6,101
4076:  MOVFF  B5,100
407A:  MOVFF  B4,FF
407E:  MOVFF  B3,FE
4082:  MOVLB  1
4084:  CLRF   x05
4086:  CLRF   x04
4088:  CLRF   x03
408A:  MOVLW  7F
408C:  MOVWF  x02
408E:  MOVLB  0
4090:  CALL   1D84
4094:  BNC   40A2
4096:  CLRF   xB6
4098:  CLRF   xB5
409A:  MOVLW  70
409C:  MOVWF  xB4
409E:  MOVLW  82
40A0:  MOVWF  xB3
....................             
....................        } 
....................        if(btn==BUTON_SAG){ 
40A2:  MOVF   xB7,W
40A4:  SUBLW  67
40A6:  BNZ   410C
....................            oyun_sure+=0.5f; 
40A8:  BCF    FD8.1
40AA:  MOVFF  B6,101
40AE:  MOVFF  B5,100
40B2:  MOVFF  B4,FF
40B6:  MOVFF  B3,FE
40BA:  MOVLB  1
40BC:  CLRF   x05
40BE:  CLRF   x04
40C0:  CLRF   x03
40C2:  MOVLW  7E
40C4:  MOVWF  x02
40C6:  MOVLB  0
40C8:  CALL   2040
40CC:  MOVFF  03,B6
40D0:  MOVFF  02,B5
40D4:  MOVFF  01,B4
40D8:  MOVFF  00,B3
....................            if(oyun_sure>15.0f) oyun_sure=1.0f; 
40DC:  MOVLB  1
40DE:  CLRF   x01
40E0:  CLRF   x00
40E2:  MOVLW  70
40E4:  MOVLB  0
40E6:  MOVWF  xFF
40E8:  MOVLW  82
40EA:  MOVWF  xFE
40EC:  MOVFF  B6,105
40F0:  MOVFF  B5,104
40F4:  MOVFF  B4,103
40F8:  MOVFF  B3,102
40FC:  CALL   1D84
4100:  BNC   410C
4102:  CLRF   xB6
4104:  CLRF   xB5
4106:  CLRF   xB4
4108:  MOVLW  7F
410A:  MOVWF  xB3
....................        } 
....................        printf(lcd_putc,"\fSure : %f dk.",oyun_sure);  
410C:  MOVLW  1E
410E:  MOVWF  FF6
4110:  MOVLW  03
4112:  MOVWF  FF7
4114:  MOVLW  08
4116:  MOVLB  1
4118:  MOVWF  x02
411A:  MOVLB  0
411C:  CALL   162E
4120:  MOVLW  89
4122:  MOVWF  FE9
4124:  MOVFF  B6,101
4128:  MOVFF  B5,100
412C:  MOVFF  B4,FF
4130:  MOVFF  B3,FE
4134:  MOVLW  02
4136:  MOVLB  1
4138:  MOVWF  x02
413A:  MOVLB  0
413C:  CALL   24B4
4140:  MOVLW  28
4142:  MOVWF  FF6
4144:  MOVLW  03
4146:  MOVWF  FF7
4148:  MOVLW  04
414A:  MOVLB  1
414C:  MOVWF  x02
414E:  MOVLB  0
4150:  CALL   162E
....................        printf(lcd_putc,"\n    << <> >>"); 
4154:  MOVLW  2E
4156:  MOVWF  FF6
4158:  MOVLW  03
415A:  MOVWF  FF7
415C:  CALL   0A06
4160:  CLRF   16
4162:  BTFSC  FF2.6
4164:  BSF    16.6
4166:  BCF    FF2.6
4168:  BTFSC  FF2.7
416A:  BSF    16.7
416C:  BCF    FF2.7
....................        delay_ms(100); 
416E:  MOVLW  64
4170:  MOVLB  1
4172:  MOVWF  x27
4174:  MOVLB  0
4176:  CALL   0748
417A:  BTFSC  16.6
417C:  BSF    FF2.6
417E:  BTFSC  16.7
4180:  BSF    FF2.7
....................         
....................     }while(btn!=BUTON_ONAY); 
4182:  MOVF   xB7,W
4184:  SUBLW  6F
4186:  BTFSS  FD8.2
4188:  BRA    4032
....................     write_eeprom(EE_ADR_OYUN_SURE,(unsigned int)(oyun_sure*10.0)); 
418A:  MOVFF  B6,110
418E:  MOVFF  B5,10F
4192:  MOVFF  B4,10E
4196:  MOVFF  B3,10D
419A:  MOVLB  1
419C:  CLRF   x14
419E:  CLRF   x13
41A0:  MOVLW  20
41A2:  MOVWF  x12
41A4:  MOVLW  82
41A6:  MOVWF  x11
41A8:  MOVLB  0
41AA:  CALL   18BE
41AE:  MOVFF  03,103
41B2:  MOVFF  02,102
41B6:  MOVFF  01,101
41BA:  MOVFF  00,100
41BE:  CALL   182A
41C2:  MOVFF  01,B8
41C6:  MOVF   FF2,W
41C8:  MOVWF  00
41CA:  BCF    FF2.6
41CC:  BCF    FF2.7
41CE:  MOVLW  04
41D0:  MOVWF  FA9
41D2:  MOVFF  B8,FA8
41D6:  BCF    FA6.6
41D8:  BCF    FA6.7
41DA:  BSF    FA6.2
41DC:  MOVLB  F
41DE:  MOVLW  55
41E0:  MOVWF  FA7
41E2:  MOVLW  AA
41E4:  MOVWF  FA7
41E6:  BSF    FA6.1
41E8:  BTFSC  FA6.1
41EA:  BRA    41E8
41EC:  BCF    FA6.2
41EE:  MOVF   00,W
41F0:  IORWF  FF2,F
....................     time_oyun=(unsigned long long int)(oyun_sure*60.0);//_mul(oyun_sure,60);      //saniye 
41F2:  MOVFF  B6,110
41F6:  MOVFF  B5,10F
41FA:  MOVFF  B4,10E
41FE:  MOVFF  B3,10D
4202:  MOVLB  1
4204:  CLRF   x14
4206:  CLRF   x13
4208:  MOVLW  70
420A:  MOVWF  x12
420C:  MOVLW  84
420E:  MOVWF  x11
4210:  MOVLB  0
4212:  CALL   18BE
4216:  MOVFF  03,110
421A:  MOVFF  02,10F
421E:  MOVFF  01,10E
4222:  MOVFF  00,10D
4226:  CALL   2472
422A:  MOVFF  03,92
422E:  MOVFF  02,91
4232:  MOVFF  01,90
4236:  MOVFF  00,8F
....................     time_oyun= (unsigned long long int)_mul(time_oyun,1000);    //mS 
423A:  MOVFF  90,B9
423E:  MOVFF  8F,B8
4242:  MOVLW  03
4244:  MOVWF  xBB
4246:  MOVLW  E8
4248:  MOVWF  xBA
424A:  CALL   0B78
424E:  MOVF   01,W
4250:  MOVFF  03,92
4254:  MOVFF  02,91
4258:  MOVFF  01,90
425C:  MOVFF  00,8F
....................     printf(lcd_putc,"\f ! KAYDEDILDI !");  
4260:  MOVLW  3C
4262:  MOVWF  FF6
4264:  MOVLW  03
4266:  MOVWF  FF7
4268:  CALL   0A06
....................     printf(lcd_putc,"\nT:%lu",time_oyun);  
426C:  MOVLW  4E
426E:  MOVWF  FF6
4270:  MOVLW  03
4272:  MOVWF  FF7
4274:  MOVLW  03
4276:  MOVLB  1
4278:  MOVWF  x02
427A:  MOVLB  0
427C:  CALL   162E
4280:  MOVLW  41
4282:  MOVWF  FE9
4284:  MOVFF  92,105
4288:  MOVFF  91,104
428C:  MOVFF  90,103
4290:  MOVFF  8F,102
4294:  CALL   0ABA
....................     delay_ms(1500); 
4298:  MOVLW  06
429A:  MOVWF  xB8
429C:  CLRF   16
429E:  BTFSC  FF2.6
42A0:  BSF    16.6
42A2:  BCF    FF2.6
42A4:  BTFSC  FF2.7
42A6:  BSF    16.7
42A8:  BCF    FF2.7
42AA:  MOVLW  FA
42AC:  MOVLB  1
42AE:  MOVWF  x27
42B0:  MOVLB  0
42B2:  CALL   0748
42B6:  BTFSC  16.6
42B8:  BSF    FF2.6
42BA:  BTFSC  16.7
42BC:  BSF    FF2.7
42BE:  DECFSZ xB8,F
42C0:  BRA    429C
....................      
....................     return n+1; 
42C2:  MOVLW  01
42C4:  ADDWF  xB2,W
42C6:  MOVWF  01
42C8:  GOTO   54D0 (RETURN)
.................... } 
....................  
.................... int secme_sure_kaydet(int n)        //Bisiklet seçme süresi kaydet. 
42CC:  MOVLW  0A
42CE:  MOVWF  xB3
42D0:  CLRF   xB4
.................... { 
....................     int sec_sure=10; 
....................     int btn=0; 
....................     sec_sure=read_eeprom(EE_ADR_BIS_SEC_SURE); 
42D2:  MOVFF  FF2,B5
42D6:  BCF    FF2.6
42D8:  BCF    FF2.7
42DA:  MOVLW  05
42DC:  MOVWF  FA9
42DE:  BCF    FA6.6
42E0:  BCF    FA6.7
42E2:  BSF    FA6.0
42E4:  MOVF   FA8,W
42E6:  BTFSC  xB5.6
42E8:  BSF    FF2.6
42EA:  BTFSC  xB5.7
42EC:  BSF    FF2.7
42EE:  MOVWF  xB3
....................      
....................     if(sec_sure>30) sec_sure=10; 
42F0:  MOVF   xB3,W
42F2:  SUBLW  1E
42F4:  BC    42FA
42F6:  MOVLW  0A
42F8:  MOVWF  xB3
....................  
....................     do{ 
....................        btn=btn_getir(); 
42FA:  RCALL  3CE0
42FC:  MOVFF  01,B4
....................        if(btn==BUTON_SOL){ 
4300:  MOVF   xB4,W
4302:  SUBLW  73
4304:  BNZ   4314
....................            sec_sure-=1; 
4306:  MOVLW  01
4308:  SUBWF  xB3,F
....................            if(sec_sure<6) sec_sure=5; 
430A:  MOVF   xB3,W
430C:  SUBLW  05
430E:  BNC   4314
4310:  MOVLW  05
4312:  MOVWF  xB3
....................             
....................        } 
....................        if(btn==BUTON_SAG){ 
4314:  MOVF   xB4,W
4316:  SUBLW  67
4318:  BNZ   4328
....................            sec_sure+=1; 
431A:  MOVLW  01
431C:  ADDWF  xB3,F
....................            if(sec_sure>30) sec_sure=10; 
431E:  MOVF   xB3,W
4320:  SUBLW  1E
4322:  BC    4328
4324:  MOVLW  0A
4326:  MOVWF  xB3
....................        } 
....................        printf(lcd_putc,"\fSure : %u S.",sec_sure);  
4328:  MOVLW  56
432A:  MOVWF  FF6
432C:  MOVLW  03
432E:  MOVWF  FF7
4330:  MOVLW  08
4332:  MOVLB  1
4334:  MOVWF  x02
4336:  MOVLB  0
4338:  CALL   162E
433C:  MOVFF  B3,B5
4340:  MOVLW  1B
4342:  MOVWF  xB6
4344:  CALL   0C9A
4348:  MOVLW  60
434A:  MOVWF  FF6
434C:  MOVLW  03
434E:  MOVWF  FF7
4350:  MOVLW  03
4352:  MOVLB  1
4354:  MOVWF  x02
4356:  MOVLB  0
4358:  CALL   162E
....................        printf(lcd_putc,"\n    << <> >>"); 
435C:  MOVLW  64
435E:  MOVWF  FF6
4360:  MOVLW  03
4362:  MOVWF  FF7
4364:  CALL   0A06
4368:  CLRF   16
436A:  BTFSC  FF2.6
436C:  BSF    16.6
436E:  BCF    FF2.6
4370:  BTFSC  FF2.7
4372:  BSF    16.7
4374:  BCF    FF2.7
....................        delay_ms(100); 
4376:  MOVLW  64
4378:  MOVLB  1
437A:  MOVWF  x27
437C:  MOVLB  0
437E:  CALL   0748
4382:  BTFSC  16.6
4384:  BSF    FF2.6
4386:  BTFSC  16.7
4388:  BSF    FF2.7
....................         
....................     }while(btn!=BUTON_ONAY); 
438A:  MOVF   xB4,W
438C:  SUBLW  6F
438E:  BNZ   42FA
....................      
....................     write_eeprom(EE_ADR_BIS_SEC_SURE, sec_sure); 
4390:  MOVF   FF2,W
4392:  MOVWF  00
4394:  BCF    FF2.6
4396:  BCF    FF2.7
4398:  MOVLW  05
439A:  MOVWF  FA9
439C:  MOVFF  B3,FA8
43A0:  BCF    FA6.6
43A2:  BCF    FA6.7
43A4:  BSF    FA6.2
43A6:  MOVLB  F
43A8:  MOVLW  55
43AA:  MOVWF  FA7
43AC:  MOVLW  AA
43AE:  MOVWF  FA7
43B0:  BSF    FA6.1
43B2:  BTFSC  FA6.1
43B4:  BRA    43B2
43B6:  BCF    FA6.2
43B8:  MOVF   00,W
43BA:  IORWF  FF2,F
....................     bisiklet_secme_suresi=_mul(sec_sure,1000); 
43BC:  MOVLB  0
43BE:  CLRF   xB9
43C0:  MOVFF  B3,B8
43C4:  MOVLW  03
43C6:  MOVWF  xBB
43C8:  MOVLW  E8
43CA:  MOVWF  xBA
43CC:  CALL   0B78
43D0:  MOVF   01,W
43D2:  MOVFF  01,98
43D6:  MOVFF  00,97
....................      
....................     printf(lcd_putc,"\f ! KAYDEDILDI !");  
43DA:  MOVLW  72
43DC:  MOVWF  FF6
43DE:  MOVLW  03
43E0:  MOVWF  FF7
43E2:  CALL   0A06
....................     delay_ms(1500); 
43E6:  MOVLW  06
43E8:  MOVWF  xB5
43EA:  CLRF   16
43EC:  BTFSC  FF2.6
43EE:  BSF    16.6
43F0:  BCF    FF2.6
43F2:  BTFSC  FF2.7
43F4:  BSF    16.7
43F6:  BCF    FF2.7
43F8:  MOVLW  FA
43FA:  MOVLB  1
43FC:  MOVWF  x27
43FE:  MOVLB  0
4400:  CALL   0748
4404:  BTFSC  16.6
4406:  BSF    FF2.6
4408:  BTFSC  16.7
440A:  BSF    FF2.7
440C:  DECFSZ xB5,F
440E:  BRA    43EA
....................     return n+1; 
4410:  MOVLW  01
4412:  ADDWF  xB2,W
4414:  MOVWF  01
4416:  GOTO   54DE (RETURN)
.................... } 
....................  
.................... int motor_pwm_kaydet(int n){ 
441A:  CLRF   xB4
441C:  MOVLW  96
441E:  MOVWF  xB3
4420:  CLRF   xB5
....................     unsigned int16 pwm=150; 
....................     char btn=0; 
....................     pwm=make16(read_eeprom(EE_ADR_MAX_PWM+1),read_eeprom(EE_ADR_MAX_PWM)); 
4422:  MOVFF  FF2,C3
4426:  BCF    FF2.6
4428:  BCF    FF2.7
442A:  MOVLW  09
442C:  MOVWF  FA9
442E:  BCF    FA6.6
4430:  BCF    FA6.7
4432:  BSF    FA6.0
4434:  MOVF   FA8,W
4436:  BTFSC  xC3.6
4438:  BSF    FF2.6
443A:  BTFSC  xC3.7
443C:  BSF    FF2.7
443E:  MOVWF  xC4
4440:  MOVFF  FF2,C5
4444:  BCF    FF2.6
4446:  BCF    FF2.7
4448:  MOVLW  08
444A:  MOVWF  FA9
444C:  BCF    FA6.6
444E:  BCF    FA6.7
4450:  BSF    FA6.0
4452:  MOVF   FA8,W
4454:  BTFSC  xC5.6
4456:  BSF    FF2.6
4458:  BTFSC  xC5.7
445A:  BSF    FF2.7
445C:  MOVWF  xC6
445E:  MOVFF  C4,B4
4462:  MOVFF  C6,B3
....................     if(pwm>500) pwm=450; 
4466:  MOVF   xB4,W
4468:  SUBLW  00
446A:  BC    447E
446C:  XORLW  FF
446E:  BNZ   4476
4470:  MOVF   xB3,W
4472:  SUBLW  F4
4474:  BC    447E
4476:  MOVLW  01
4478:  MOVWF  xB4
447A:  MOVLW  C2
447C:  MOVWF  xB3
....................     unsigned long long time_akim_olc=millis(); 
447E:  MOVFF  2D,B9
4482:  MOVFF  2C,B8
4486:  MOVFF  2B,B7
448A:  MOVFF  2A,B6
....................      
....................     if(pwm>500) pwm=400; 
448E:  MOVF   xB4,W
4490:  SUBLW  00
4492:  BC    44A6
4494:  XORLW  FF
4496:  BNZ   449E
4498:  MOVF   xB3,W
449A:  SUBLW  F4
449C:  BC    44A6
449E:  MOVLW  01
44A0:  MOVWF  xB4
44A2:  MOVLW  90
44A4:  MOVWF  xB3
....................     do{ 
....................         btn=btn_getir(); 
44A6:  RCALL  3CE0
44A8:  MOVFF  01,B5
....................         if(btn==BUTON_SOL){ 
44AC:  MOVF   xB5,W
44AE:  SUBLW  73
44B0:  BNZ   44CA
....................            pwm-=10; 
44B2:  MOVLW  0A
44B4:  SUBWF  xB3,F
44B6:  MOVLW  00
44B8:  SUBWFB xB4,F
....................            if( pwm<100) pwm=100; 
44BA:  MOVF   xB4,F
44BC:  BNZ   44CA
44BE:  MOVF   xB3,W
44C0:  SUBLW  63
44C2:  BNC   44CA
44C4:  CLRF   xB4
44C6:  MOVLW  64
44C8:  MOVWF  xB3
....................         } 
....................         if(btn==BUTON_SAG){ 
44CA:  MOVF   xB5,W
44CC:  SUBLW  67
44CE:  BNZ   44F0
....................            pwm+=10; 
44D0:  MOVLW  0A
44D2:  ADDWF  xB3,F
44D4:  MOVLW  00
44D6:  ADDWFC xB4,F
....................            if( pwm>500) pwm=500; 
44D8:  MOVF   xB4,W
44DA:  SUBLW  00
44DC:  BC    44F0
44DE:  XORLW  FF
44E0:  BNZ   44E8
44E2:  MOVF   xB3,W
44E4:  SUBLW  F4
44E6:  BC    44F0
44E8:  MOVLW  01
44EA:  MOVWF  xB4
44EC:  MOVLW  F4
44EE:  MOVWF  xB3
....................         } 
....................          
....................         analogWrite(M1_PWM,pwm); 
44F0:  MOVFF  B4,02
44F4:  MOVFF  B3,01
44F8:  RRCF   02,F
44FA:  RRCF   01,F
44FC:  RRCF   02,F
44FE:  RRCF   01,F
4500:  RRCF   02,F
4502:  MOVFF  01,FBE
4506:  RRCF   02,F
4508:  RRCF   02,W
450A:  ANDLW  30
450C:  MOVWF  00
450E:  MOVF   FBD,W
4510:  ANDLW  CF
4512:  IORWF  00,W
4514:  MOVWF  FBD
....................         analogWrite(M2_PWM,pwm); 
4516:  MOVFF  B4,02
451A:  MOVFF  B3,01
451E:  RRCF   02,F
4520:  RRCF   01,F
4522:  RRCF   02,F
4524:  RRCF   01,F
4526:  RRCF   02,F
4528:  MOVFF  01,F67
452C:  RRCF   02,F
452E:  RRCF   02,W
4530:  ANDLW  30
4532:  MOVWF  00
4534:  MOVF   F66,W
4536:  ANDLW  CF
4538:  IORWF  00,W
453A:  MOVWF  F66
....................          
....................         o1_akim_olc(); 
453C:  CALL   1F84
....................         o2_akim_olc(); 
4540:  CALL   1FE2
....................          
....................         if(akim_adc_deger1<5){ 
4544:  MOVF   4C,F
4546:  BNZ   45EE
4548:  MOVF   4B,W
454A:  SUBLW  04
454C:  BNC   45EE
....................              printf(lcd_putc,"\fM1 yok !!!");  
454E:  MOVLW  84
4550:  MOVWF  FF6
4552:  MOVLW  03
4554:  MOVWF  FF7
4556:  CALL   0A06
....................              printf(lcd_putc,"\nI1:%Lu",akim_adc_deger1);  
455A:  MOVLW  90
455C:  MOVWF  FF6
455E:  MOVLW  03
4560:  MOVWF  FF7
4562:  MOVLW  04
4564:  MOVLB  1
4566:  MOVWF  x02
4568:  MOVLB  0
456A:  CALL   162E
456E:  MOVLW  10
4570:  MOVWF  FE9
4572:  MOVFF  4C,C4
4576:  MOVFF  4B,C3
457A:  CALL   0BB4
....................               
....................              if(millis()-time_akim_olc>1500 ){ 
457E:  MOVF   xB6,W
4580:  SUBWF  2A,W
4582:  MOVWF  xC3
4584:  MOVF   xB7,W
4586:  SUBWFB 2B,W
4588:  MOVWF  xC4
458A:  MOVF   xB8,W
458C:  SUBWFB 2C,W
458E:  MOVWF  xC5
4590:  MOVF   xB9,W
4592:  SUBWFB 2D,W
4594:  MOVWF  xC6
4596:  MOVF   xC6,F
4598:  BNZ   45AE
459A:  MOVF   xC5,F
459C:  BNZ   45AE
459E:  MOVF   xC4,W
45A0:  SUBLW  04
45A2:  BC    45EE
45A4:  XORLW  FF
45A6:  BNZ   45AE
45A8:  MOVF   xC3,W
45AA:  SUBLW  DC
45AC:  BC    45EE
....................                 // panel1_komut(MOTOR_YOK); 
....................                  mp3_stop();delay_ms(100); 
45AE:  CALL   1302
45B2:  CLRF   16
45B4:  BTFSC  FF2.6
45B6:  BSF    16.6
45B8:  BCF    FF2.6
45BA:  BTFSC  FF2.7
45BC:  BSF    16.7
45BE:  BCF    FF2.7
45C0:  MOVLW  64
45C2:  MOVLB  1
45C4:  MOVWF  x27
45C6:  MOVLB  0
45C8:  CALL   0748
45CC:  BTFSC  16.6
45CE:  BSF    FF2.6
45D0:  BTFSC  16.7
45D2:  BSF    FF2.7
....................                  mp3_play(mp3_beep_uyari); 
45D4:  CLRF   xFF
45D6:  MOVLW  13
45D8:  MOVWF  xFE
45DA:  CALL   1658
....................                  time_akim_olc=millis(); 
45DE:  MOVFF  2D,B9
45E2:  MOVFF  2C,B8
45E6:  MOVFF  2B,B7
45EA:  MOVFF  2A,B6
....................              }        
....................              
....................         } 
....................         if(akim_adc_deger2<5){ 
45EE:  MOVF   4E,F
45F0:  BNZ   4698
45F2:  MOVF   4D,W
45F4:  SUBLW  04
45F6:  BNC   4698
....................             printf(lcd_putc,"\fM2 yok !!!"); 
45F8:  MOVLW  98
45FA:  MOVWF  FF6
45FC:  MOVLW  03
45FE:  MOVWF  FF7
4600:  CALL   0A06
....................             printf(lcd_putc,"\nI2:%Lu",akim_adc_deger2); 
4604:  MOVLW  A4
4606:  MOVWF  FF6
4608:  MOVLW  03
460A:  MOVWF  FF7
460C:  MOVLW  04
460E:  MOVLB  1
4610:  MOVWF  x02
4612:  MOVLB  0
4614:  CALL   162E
4618:  MOVLW  10
461A:  MOVWF  FE9
461C:  MOVFF  4E,C4
4620:  MOVFF  4D,C3
4624:  CALL   0BB4
....................               
....................               if(millis()-time_akim_olc>1500 ){ 
4628:  MOVF   xB6,W
462A:  SUBWF  2A,W
462C:  MOVWF  xC3
462E:  MOVF   xB7,W
4630:  SUBWFB 2B,W
4632:  MOVWF  xC4
4634:  MOVF   xB8,W
4636:  SUBWFB 2C,W
4638:  MOVWF  xC5
463A:  MOVF   xB9,W
463C:  SUBWFB 2D,W
463E:  MOVWF  xC6
4640:  MOVF   xC6,F
4642:  BNZ   4658
4644:  MOVF   xC5,F
4646:  BNZ   4658
4648:  MOVF   xC4,W
464A:  SUBLW  04
464C:  BC    4698
464E:  XORLW  FF
4650:  BNZ   4658
4652:  MOVF   xC3,W
4654:  SUBLW  DC
4656:  BC    4698
....................                   mp3_stop();delay_ms(100); 
4658:  CALL   1302
465C:  CLRF   16
465E:  BTFSC  FF2.6
4660:  BSF    16.6
4662:  BCF    FF2.6
4664:  BTFSC  FF2.7
4666:  BSF    16.7
4668:  BCF    FF2.7
466A:  MOVLW  64
466C:  MOVLB  1
466E:  MOVWF  x27
4670:  MOVLB  0
4672:  CALL   0748
4676:  BTFSC  16.6
4678:  BSF    FF2.6
467A:  BTFSC  16.7
467C:  BSF    FF2.7
....................                   mp3_play(mp3_beep_uyari); 
467E:  CLRF   xFF
4680:  MOVLW  13
4682:  MOVWF  xFE
4684:  CALL   1658
....................                   time_akim_olc=millis(); 
4688:  MOVFF  2D,B9
468C:  MOVFF  2C,B8
4690:  MOVFF  2B,B7
4694:  MOVFF  2A,B6
....................                  //  panel2_komut(MOTOR_YOK); 
....................               }   
....................         } 
....................          
....................         if(akim_adc_deger1>200 || akim_adc_deger2>200)//1000mV/4.88mv=~205 motordan geçen 1Amper akým deðeridir. aþýrýakým korumasý. 
4698:  MOVF   4C,F
469A:  BNZ   46AC
469C:  MOVF   4B,W
469E:  SUBLW  C8
46A0:  BNC   46AC
46A2:  MOVF   4E,F
46A4:  BNZ   46AC
46A6:  MOVF   4D,W
46A8:  SUBLW  C8
46AA:  BC    473C
....................         { 
....................             analogWrite(M1_PWM, 0); 
46AC:  CLRF   FBE
....................             analogWrite(M2_PWM, 0); 
46AE:  CLRF   F67
....................             printf(lcd_putc,"\f! ASIRI AKIM !");  
46B0:  MOVLW  AC
46B2:  MOVWF  FF6
46B4:  MOVLW  03
46B6:  MOVWF  FF7
46B8:  CALL   0A06
....................             printf(lcd_putc,"\n    << <> >>"); 
46BC:  MOVLW  BC
46BE:  MOVWF  FF6
46C0:  MOVLW  03
46C2:  MOVWF  FF7
46C4:  CALL   0A06
....................              
....................             while(akim_adc_deger1< 25 && akim_adc_deger2<25){ 
46C8:  MOVF   4C,F
46CA:  BNZ   473C
46CC:  MOVF   4B,W
46CE:  SUBLW  18
46D0:  BNC   473C
46D2:  MOVF   4E,F
46D4:  BNZ   473C
46D6:  MOVF   4D,W
46D8:  SUBLW  18
46DA:  BNC   473C
....................                 analogWrite(M1_PWM, 0); 
46DC:  CLRF   FBE
....................                 analogWrite(M2_PWM, 0); 
46DE:  CLRF   F67
....................                 o1_akim_olc(); 
46E0:  CALL   1F84
....................                 o2_akim_olc(); 
46E4:  CALL   1FE2
....................                 panel1_komut(MOTOR_YOK); 
46E8:  MOVLW  51
46EA:  MOVLB  1
46EC:  MOVWF  x00
46EE:  MOVLB  0
46F0:  CALL   13BA
46F4:  MOVLW  63
46F6:  MOVLB  1
46F8:  MOVWF  x00
46FA:  MOVLB  0
46FC:  CALL   13BA
....................                 panel2_komut(MOTOR_YOK); 
4700:  MOVLW  51
4702:  MOVLB  1
4704:  MOVWF  x00
4706:  MOVLB  0
4708:  CALL   143C
470C:  MOVLW  63
470E:  MOVLB  1
4710:  MOVWF  x00
4712:  MOVLB  0
4714:  CALL   143C
4718:  CLRF   16
471A:  BTFSC  FF2.6
471C:  BSF    16.6
471E:  BCF    FF2.6
4720:  BTFSC  FF2.7
4722:  BSF    16.7
4724:  BCF    FF2.7
....................                 delay_ms(150); 
4726:  MOVLW  96
4728:  MOVLB  1
472A:  MOVWF  x27
472C:  MOVLB  0
472E:  CALL   0748
4732:  BTFSC  16.6
4734:  BSF    FF2.6
4736:  BTFSC  16.7
4738:  BSF    FF2.7
473A:  BRA    46C8
....................             } 
....................              
....................         } 
....................         printf(lcd_putc,"\fHIZ : %Lu ",pwm);  
473C:  MOVLW  CA
473E:  MOVWF  FF6
4740:  MOVLW  03
4742:  MOVWF  FF7
4744:  MOVLW  07
4746:  MOVLB  1
4748:  MOVWF  x02
474A:  MOVLB  0
474C:  CALL   162E
4750:  MOVLW  10
4752:  MOVWF  FE9
4754:  MOVFF  B4,C4
4758:  MOVFF  B3,C3
475C:  CALL   0BB4
4760:  MOVLW  20
4762:  MOVLB  1
4764:  MOVWF  x0E
4766:  MOVLB  0
4768:  CALL   0996
....................         printf(lcd_putc,"\nI1:%lu I2:%lu"akim_adc_deger1,akim_adc_deger2); 
476C:  MOVLW  D6
476E:  MOVWF  FF6
4770:  MOVLW  03
4772:  MOVWF  FF7
4774:  MOVLW  04
4776:  MOVLB  1
4778:  MOVWF  x02
477A:  MOVLB  0
477C:  CALL   162E
4780:  MOVLW  10
4782:  MOVWF  FE9
4784:  MOVFF  4C,C4
4788:  MOVFF  4B,C3
478C:  CALL   0BB4
4790:  MOVLW  DD
4792:  MOVWF  FF6
4794:  MOVLW  03
4796:  MOVWF  FF7
4798:  MOVLW  04
479A:  MOVLB  1
479C:  MOVWF  x02
479E:  MOVLB  0
47A0:  CALL   162E
47A4:  MOVLW  10
47A6:  MOVWF  FE9
47A8:  MOVFF  4E,C4
47AC:  MOVFF  4D,C3
47B0:  CALL   0BB4
47B4:  CLRF   16
47B6:  BTFSC  FF2.6
47B8:  BSF    16.6
47BA:  BCF    FF2.6
47BC:  BTFSC  FF2.7
47BE:  BSF    16.7
47C0:  BCF    FF2.7
....................         delay_ms(250); 
47C2:  MOVLW  FA
47C4:  MOVLB  1
47C6:  MOVWF  x27
47C8:  MOVLB  0
47CA:  CALL   0748
47CE:  BTFSC  16.6
47D0:  BSF    FF2.6
47D2:  BTFSC  16.7
47D4:  BSF    FF2.7
....................          
....................     }while(btn!=BUTON_ONAY); 
47D6:  MOVF   xB5,W
47D8:  SUBLW  6F
47DA:  BTFSS  FD8.2
47DC:  BRA    44A6
....................      
....................     analogWrite(M1_PWM,0x0000); 
47DE:  CLRF   FBE
....................     analogWrite(M2_PWM,0x0000); 
47E0:  CLRF   F67
....................     write_eeprom(EE_ADR_MAX_PWM, make8(pwm,0));     //LSB 
47E2:  MOVFF  B3,C3
47E6:  MOVF   FF2,W
47E8:  MOVWF  00
47EA:  BCF    FF2.6
47EC:  BCF    FF2.7
47EE:  MOVLW  08
47F0:  MOVWF  FA9
47F2:  MOVFF  C3,FA8
47F6:  BCF    FA6.6
47F8:  BCF    FA6.7
47FA:  BSF    FA6.2
47FC:  MOVLB  F
47FE:  MOVLW  55
4800:  MOVWF  FA7
4802:  MOVLW  AA
4804:  MOVWF  FA7
4806:  BSF    FA6.1
4808:  BTFSC  FA6.1
480A:  BRA    4808
480C:  BCF    FA6.2
480E:  MOVF   00,W
4810:  IORWF  FF2,F
....................     write_eeprom(EE_ADR_MAX_PWM+1, make8(pwm,1)); 
4812:  MOVFF  B4,C3
4816:  MOVFF  FF2,00
481A:  BCF    FF2.6
481C:  BCF    FF2.7
481E:  MOVLW  09
4820:  MOVWF  FA9
4822:  MOVFF  B4,FA8
4826:  BCF    FA6.6
4828:  BCF    FA6.7
482A:  BSF    FA6.2
482C:  MOVLW  55
482E:  MOVWF  FA7
4830:  MOVLW  AA
4832:  MOVWF  FA7
4834:  BSF    FA6.1
4836:  BTFSC  FA6.1
4838:  BRA    4836
483A:  BCF    FA6.2
483C:  MOVF   00,W
483E:  IORWF  FF2,F
....................     pwm_max_deger=pwm; 
4840:  MOVFF  B4,46
4844:  MOVFF  B3,45
....................     printf(lcd_putc,"\f ! KAYDEDILDI !");  
4848:  MOVLW  E6
484A:  MOVWF  FF6
484C:  MOVLW  03
484E:  MOVWF  FF7
4850:  MOVLB  0
4852:  CALL   0A06
....................      
....................     BOOLEAN m1_dur = FALSE, m2_dur = FALSE; 
.................... 	unsigned long long time = millis(); 
.................... 	unsigned long long time_m12_dur = millis(); 
4856:  BCF    xBA.0
4858:  BCF    xBA.1
485A:  MOVFF  2D,BE
485E:  MOVFF  2C,BD
4862:  MOVFF  2B,BC
4866:  MOVFF  2A,BB
486A:  MOVFF  2D,C2
486E:  MOVFF  2C,C1
4872:  MOVFF  2B,C0
4876:  MOVFF  2A,BF
.................... 	m1_pwm_deger = m2_pwm_deger =pwm_max_deger;        //yoldan çýkmamasý için ayarlanan max deger. 
487A:  MOVFF  46,A0
487E:  MOVFF  45,9F
4882:  MOVFF  A0,9E
4886:  MOVFF  9F,9D
.................... 	analogWrite(M1_PWM, m1_pwm_deger);		//analogWrite(pin, value) 
488A:  MOVFF  9E,02
488E:  MOVFF  9D,01
4892:  RRCF   02,F
4894:  RRCF   01,F
4896:  RRCF   02,F
4898:  RRCF   01,F
489A:  RRCF   02,F
489C:  MOVFF  01,FBE
48A0:  RRCF   02,F
48A2:  RRCF   02,W
48A4:  ANDLW  30
48A6:  MOVWF  00
48A8:  MOVF   FBD,W
48AA:  ANDLW  CF
48AC:  IORWF  00,W
48AE:  MOVWF  FBD
.................... 	analogWrite(M2_PWM, m2_pwm_deger); 
48B0:  MOVFF  A0,02
48B4:  MOVFF  9F,01
48B8:  RRCF   02,F
48BA:  RRCF   01,F
48BC:  RRCF   02,F
48BE:  RRCF   01,F
48C0:  RRCF   02,F
48C2:  MOVFF  01,F67
48C6:  RRCF   02,F
48C8:  RRCF   02,W
48CA:  ANDLW  30
48CC:  MOVWF  00
48CE:  MOVF   F66,W
48D0:  ANDLW  CF
48D2:  IORWF  00,W
48D4:  MOVWF  F66
....................       
....................      do{ 
....................  
.................... 		if (!input(TUR1_SENS_PIN)){ 
48D6:  BSF    F93.5
48D8:  BTFSC  F81.5
48DA:  BRA    48E0
.................... 			analogWrite(M1_PWM, 0);		//analogWrite(pin, value) 
48DC:  CLRF   FBE
.................... 			m1_dur = TRUE; 
48DE:  BSF    xBA.0
.................... 		} 
.................... 		if (!input(TUR2_SENS_PIN)){ 
48E0:  BSF    F93.4
48E2:  BTFSC  F81.4
48E4:  BRA    48EA
.................... 			analogWrite(M2_PWM, 0); 
48E6:  CLRF   F67
.................... 			m2_dur = TRUE; 
48E8:  BSF    xBA.1
.................... 		} 
....................  
.................... 		if (millis() - time_m12_dur > 10000){ 
48EA:  MOVF   xBF,W
48EC:  SUBWF  2A,W
48EE:  MOVWF  xC3
48F0:  MOVF   xC0,W
48F2:  SUBWFB 2B,W
48F4:  MOVWF  xC4
48F6:  MOVF   xC1,W
48F8:  SUBWFB 2C,W
48FA:  MOVWF  xC5
48FC:  MOVF   xC2,W
48FE:  SUBWFB 2D,W
4900:  MOVWF  xC6
4902:  MOVF   xC6,F
4904:  BNZ   491A
4906:  MOVF   xC5,F
4908:  BNZ   491A
490A:  MOVF   xC4,W
490C:  SUBLW  26
490E:  BC    4920
4910:  XORLW  FF
4912:  BNZ   491A
4914:  MOVF   xC3,W
4916:  SUBLW  10
4918:  BC    4920
.................... 			analogWrite(M1_PWM, 0); 
491A:  CLRF   FBE
.................... 			analogWrite(M2_PWM, 0); 
491C:  CLRF   F67
.................... 			break; 
491E:  BRA    492A
.................... 		} 
.................... 		if (m1_dur && m2_dur) break; 
4920:  BTFSS  xBA.0
4922:  BRA    4928
4924:  BTFSC  xBA.1
4926:  BRA    492A
....................  
....................     } while (1); 
4928:  BRA    48D6
....................      
....................     return n+1; 
492A:  MOVLW  01
492C:  ADDWF  xB2,W
492E:  MOVWF  01
4930:  GOTO   54EC (RETURN)
....................      
.................... } 
....................  
.................... int sensor_test(int n){ 
4934:  CLRF   xB3
....................     int btn=0; 
....................     disable_interrupts(GLOBAL); 
4936:  BCF    FF2.6
4938:  BCF    FF2.7
493A:  BTFSC  FF2.7
493C:  BRA    4938
....................     do{ 
....................         btn=btn_getir(); 
493E:  CALL   3CE0
4942:  MOVFF  01,B3
....................          
....................         if(!input(JTN_PIN)){ 
4946:  BSF    F93.0
4948:  BTFSC  F81.0
494A:  BRA    49BE
....................            mp3_stop();delay_ms(100); 
494C:  CALL   1302
4950:  CLRF   16
4952:  BTFSC  FF2.6
4954:  BSF    16.6
4956:  BCF    FF2.6
4958:  BTFSC  FF2.7
495A:  BSF    16.7
495C:  BCF    FF2.7
495E:  MOVLW  64
4960:  MOVLB  1
4962:  MOVWF  x27
4964:  MOVLB  0
4966:  CALL   0748
496A:  BTFSC  16.6
496C:  BSF    FF2.6
496E:  BTFSC  16.7
4970:  BSF    FF2.7
....................            mp3_play(wav_ding); 
4972:  CLRF   xFF
4974:  MOVLW  10
4976:  MOVWF  xFE
4978:  CALL   1658
....................            printf(lcd_putc,"\fSens: JETON");  
497C:  MOVLW  F8
497E:  MOVWF  FF6
4980:  MOVLW  03
4982:  MOVWF  FF7
4984:  CALL   0A06
....................            printf(lcd_putc,"\n    << <> >>"); 
4988:  MOVLW  06
498A:  MOVWF  FF6
498C:  MOVLW  04
498E:  MOVWF  FF7
4990:  CALL   0A06
....................            delay_ms(1000); 
4994:  MOVLW  04
4996:  MOVWF  xB4
4998:  CLRF   16
499A:  BTFSC  FF2.6
499C:  BSF    16.6
499E:  BCF    FF2.6
49A0:  BTFSC  FF2.7
49A2:  BSF    16.7
49A4:  BCF    FF2.7
49A6:  MOVLW  FA
49A8:  MOVLB  1
49AA:  MOVWF  x27
49AC:  MOVLB  0
49AE:  CALL   0748
49B2:  BTFSC  16.6
49B4:  BSF    FF2.6
49B6:  BTFSC  16.7
49B8:  BSF    FF2.7
49BA:  DECFSZ xB4,F
49BC:  BRA    4998
....................         } 
....................         if(!input(JTN2_PIN)){ 
49BE:  BSF    F93.7
49C0:  BTFSC  F81.7
49C2:  BRA    4A36
....................            mp3_stop();delay_ms(100); 
49C4:  CALL   1302
49C8:  CLRF   16
49CA:  BTFSC  FF2.6
49CC:  BSF    16.6
49CE:  BCF    FF2.6
49D0:  BTFSC  FF2.7
49D2:  BSF    16.7
49D4:  BCF    FF2.7
49D6:  MOVLW  64
49D8:  MOVLB  1
49DA:  MOVWF  x27
49DC:  MOVLB  0
49DE:  CALL   0748
49E2:  BTFSC  16.6
49E4:  BSF    FF2.6
49E6:  BTFSC  16.7
49E8:  BSF    FF2.7
....................            mp3_play(wav_ding); 
49EA:  CLRF   xFF
49EC:  MOVLW  10
49EE:  MOVWF  xFE
49F0:  CALL   1658
....................            printf(lcd_putc,"\fSens: JETON2");  
49F4:  MOVLW  14
49F6:  MOVWF  FF6
49F8:  MOVLW  04
49FA:  MOVWF  FF7
49FC:  CALL   0A06
....................            printf(lcd_putc,"\n    << <> >>"); 
4A00:  MOVLW  22
4A02:  MOVWF  FF6
4A04:  MOVLW  04
4A06:  MOVWF  FF7
4A08:  CALL   0A06
....................            delay_ms(1000); 
4A0C:  MOVLW  04
4A0E:  MOVWF  xB4
4A10:  CLRF   16
4A12:  BTFSC  FF2.6
4A14:  BSF    16.6
4A16:  BCF    FF2.6
4A18:  BTFSC  FF2.7
4A1A:  BSF    16.7
4A1C:  BCF    FF2.7
4A1E:  MOVLW  FA
4A20:  MOVLB  1
4A22:  MOVWF  x27
4A24:  MOVLB  0
4A26:  CALL   0748
4A2A:  BTFSC  16.6
4A2C:  BSF    FF2.6
4A2E:  BTFSC  16.7
4A30:  BSF    FF2.7
4A32:  DECFSZ xB4,F
4A34:  BRA    4A10
....................         } 
....................         if(!input(HIZ1_SENS_PIN)){  
4A36:  BSF    F93.1
4A38:  BTFSC  F81.1
4A3A:  BRA    4AAE
....................            mp3_stop();delay_ms(100); 
4A3C:  CALL   1302
4A40:  CLRF   16
4A42:  BTFSC  FF2.6
4A44:  BSF    16.6
4A46:  BCF    FF2.6
4A48:  BTFSC  FF2.7
4A4A:  BSF    16.7
4A4C:  BCF    FF2.7
4A4E:  MOVLW  64
4A50:  MOVLB  1
4A52:  MOVWF  x27
4A54:  MOVLB  0
4A56:  CALL   0748
4A5A:  BTFSC  16.6
4A5C:  BSF    FF2.6
4A5E:  BTFSC  16.7
4A60:  BSF    FF2.7
....................            mp3_play(wav_ding); 
4A62:  CLRF   xFF
4A64:  MOVLW  10
4A66:  MOVWF  xFE
4A68:  CALL   1658
....................            printf(lcd_putc,"\fSens: HIZ1 ");  
4A6C:  MOVLW  30
4A6E:  MOVWF  FF6
4A70:  MOVLW  04
4A72:  MOVWF  FF7
4A74:  CALL   0A06
....................            printf(lcd_putc,"\n    << <> >>"); 
4A78:  MOVLW  3E
4A7A:  MOVWF  FF6
4A7C:  MOVLW  04
4A7E:  MOVWF  FF7
4A80:  CALL   0A06
....................            delay_ms(1000); 
4A84:  MOVLW  04
4A86:  MOVWF  xB4
4A88:  CLRF   16
4A8A:  BTFSC  FF2.6
4A8C:  BSF    16.6
4A8E:  BCF    FF2.6
4A90:  BTFSC  FF2.7
4A92:  BSF    16.7
4A94:  BCF    FF2.7
4A96:  MOVLW  FA
4A98:  MOVLB  1
4A9A:  MOVWF  x27
4A9C:  MOVLB  0
4A9E:  CALL   0748
4AA2:  BTFSC  16.6
4AA4:  BSF    FF2.6
4AA6:  BTFSC  16.7
4AA8:  BSF    FF2.7
4AAA:  DECFSZ xB4,F
4AAC:  BRA    4A88
....................         } 
....................          
....................         if(!input(HIZ2_SENS_PIN)){  
4AAE:  BSF    F93.2
4AB0:  BTFSC  F81.2
4AB2:  BRA    4B26
....................            mp3_stop();delay_ms(100); 
4AB4:  CALL   1302
4AB8:  CLRF   16
4ABA:  BTFSC  FF2.6
4ABC:  BSF    16.6
4ABE:  BCF    FF2.6
4AC0:  BTFSC  FF2.7
4AC2:  BSF    16.7
4AC4:  BCF    FF2.7
4AC6:  MOVLW  64
4AC8:  MOVLB  1
4ACA:  MOVWF  x27
4ACC:  MOVLB  0
4ACE:  CALL   0748
4AD2:  BTFSC  16.6
4AD4:  BSF    FF2.6
4AD6:  BTFSC  16.7
4AD8:  BSF    FF2.7
....................            mp3_play(wav_ding); 
4ADA:  CLRF   xFF
4ADC:  MOVLW  10
4ADE:  MOVWF  xFE
4AE0:  CALL   1658
....................            printf(lcd_putc,"\fSens: HIZ2 ");  
4AE4:  MOVLW  4C
4AE6:  MOVWF  FF6
4AE8:  MOVLW  04
4AEA:  MOVWF  FF7
4AEC:  CALL   0A06
....................            printf(lcd_putc,"\n    << <> >>"); 
4AF0:  MOVLW  5A
4AF2:  MOVWF  FF6
4AF4:  MOVLW  04
4AF6:  MOVWF  FF7
4AF8:  CALL   0A06
....................            delay_ms(1000); 
4AFC:  MOVLW  04
4AFE:  MOVWF  xB4
4B00:  CLRF   16
4B02:  BTFSC  FF2.6
4B04:  BSF    16.6
4B06:  BCF    FF2.6
4B08:  BTFSC  FF2.7
4B0A:  BSF    16.7
4B0C:  BCF    FF2.7
4B0E:  MOVLW  FA
4B10:  MOVLB  1
4B12:  MOVWF  x27
4B14:  MOVLB  0
4B16:  CALL   0748
4B1A:  BTFSC  16.6
4B1C:  BSF    FF2.6
4B1E:  BTFSC  16.7
4B20:  BSF    FF2.7
4B22:  DECFSZ xB4,F
4B24:  BRA    4B00
....................         } 
....................         if(!input(TUR1_SENS_PIN)){  
4B26:  BSF    F93.5
4B28:  BTFSC  F81.5
4B2A:  BRA    4B9E
....................            mp3_stop();delay_ms(100); 
4B2C:  CALL   1302
4B30:  CLRF   16
4B32:  BTFSC  FF2.6
4B34:  BSF    16.6
4B36:  BCF    FF2.6
4B38:  BTFSC  FF2.7
4B3A:  BSF    16.7
4B3C:  BCF    FF2.7
4B3E:  MOVLW  64
4B40:  MOVLB  1
4B42:  MOVWF  x27
4B44:  MOVLB  0
4B46:  CALL   0748
4B4A:  BTFSC  16.6
4B4C:  BSF    FF2.6
4B4E:  BTFSC  16.7
4B50:  BSF    FF2.7
....................            mp3_play(wav_ding); 
4B52:  CLRF   xFF
4B54:  MOVLW  10
4B56:  MOVWF  xFE
4B58:  CALL   1658
....................            printf(lcd_putc,"\fSens: TUR1 ");  
4B5C:  MOVLW  68
4B5E:  MOVWF  FF6
4B60:  MOVLW  04
4B62:  MOVWF  FF7
4B64:  CALL   0A06
....................            printf(lcd_putc,"\n    << <> >>"); 
4B68:  MOVLW  76
4B6A:  MOVWF  FF6
4B6C:  MOVLW  04
4B6E:  MOVWF  FF7
4B70:  CALL   0A06
....................            delay_ms(1000); 
4B74:  MOVLW  04
4B76:  MOVWF  xB4
4B78:  CLRF   16
4B7A:  BTFSC  FF2.6
4B7C:  BSF    16.6
4B7E:  BCF    FF2.6
4B80:  BTFSC  FF2.7
4B82:  BSF    16.7
4B84:  BCF    FF2.7
4B86:  MOVLW  FA
4B88:  MOVLB  1
4B8A:  MOVWF  x27
4B8C:  MOVLB  0
4B8E:  CALL   0748
4B92:  BTFSC  16.6
4B94:  BSF    FF2.6
4B96:  BTFSC  16.7
4B98:  BSF    FF2.7
4B9A:  DECFSZ xB4,F
4B9C:  BRA    4B78
....................         } 
....................         if(!input(TUR2_SENS_PIN)){  
4B9E:  BSF    F93.4
4BA0:  BTFSC  F81.4
4BA2:  BRA    4C16
....................            mp3_stop();delay_ms(100); 
4BA4:  CALL   1302
4BA8:  CLRF   16
4BAA:  BTFSC  FF2.6
4BAC:  BSF    16.6
4BAE:  BCF    FF2.6
4BB0:  BTFSC  FF2.7
4BB2:  BSF    16.7
4BB4:  BCF    FF2.7
4BB6:  MOVLW  64
4BB8:  MOVLB  1
4BBA:  MOVWF  x27
4BBC:  MOVLB  0
4BBE:  CALL   0748
4BC2:  BTFSC  16.6
4BC4:  BSF    FF2.6
4BC6:  BTFSC  16.7
4BC8:  BSF    FF2.7
....................            mp3_play(wav_ding); 
4BCA:  CLRF   xFF
4BCC:  MOVLW  10
4BCE:  MOVWF  xFE
4BD0:  CALL   1658
....................            printf(lcd_putc,"\fSens: TUR2 ");  
4BD4:  MOVLW  84
4BD6:  MOVWF  FF6
4BD8:  MOVLW  04
4BDA:  MOVWF  FF7
4BDC:  CALL   0A06
....................            printf(lcd_putc,"\n    << <> >>"); 
4BE0:  MOVLW  92
4BE2:  MOVWF  FF6
4BE4:  MOVLW  04
4BE6:  MOVWF  FF7
4BE8:  CALL   0A06
....................            delay_ms(1000); 
4BEC:  MOVLW  04
4BEE:  MOVWF  xB4
4BF0:  CLRF   16
4BF2:  BTFSC  FF2.6
4BF4:  BSF    16.6
4BF6:  BCF    FF2.6
4BF8:  BTFSC  FF2.7
4BFA:  BSF    16.7
4BFC:  BCF    FF2.7
4BFE:  MOVLW  FA
4C00:  MOVLB  1
4C02:  MOVWF  x27
4C04:  MOVLB  0
4C06:  CALL   0748
4C0A:  BTFSC  16.6
4C0C:  BSF    FF2.6
4C0E:  BTFSC  16.7
4C10:  BSF    FF2.7
4C12:  DECFSZ xB4,F
4C14:  BRA    4BF0
....................         } 
....................         if(!input(BIS_BTN1_PIN)){  
4C16:  BTFSC  F80.2
4C18:  BRA    4C8C
....................            mp3_stop();delay_ms(100); 
4C1A:  CALL   1302
4C1E:  CLRF   16
4C20:  BTFSC  FF2.6
4C22:  BSF    16.6
4C24:  BCF    FF2.6
4C26:  BTFSC  FF2.7
4C28:  BSF    16.7
4C2A:  BCF    FF2.7
4C2C:  MOVLW  64
4C2E:  MOVLB  1
4C30:  MOVWF  x27
4C32:  MOVLB  0
4C34:  CALL   0748
4C38:  BTFSC  16.6
4C3A:  BSF    FF2.6
4C3C:  BTFSC  16.7
4C3E:  BSF    FF2.7
....................            mp3_play(wav_ding); 
4C40:  CLRF   xFF
4C42:  MOVLW  10
4C44:  MOVWF  xFE
4C46:  CALL   1658
....................            printf(lcd_putc,"\fSens: BIS BTN1 ");  
4C4A:  MOVLW  A0
4C4C:  MOVWF  FF6
4C4E:  MOVLW  04
4C50:  MOVWF  FF7
4C52:  CALL   0A06
....................            printf(lcd_putc,"\n    << <> >>"); 
4C56:  MOVLW  B2
4C58:  MOVWF  FF6
4C5A:  MOVLW  04
4C5C:  MOVWF  FF7
4C5E:  CALL   0A06
....................            delay_ms(1000); 
4C62:  MOVLW  04
4C64:  MOVWF  xB4
4C66:  CLRF   16
4C68:  BTFSC  FF2.6
4C6A:  BSF    16.6
4C6C:  BCF    FF2.6
4C6E:  BTFSC  FF2.7
4C70:  BSF    16.7
4C72:  BCF    FF2.7
4C74:  MOVLW  FA
4C76:  MOVLB  1
4C78:  MOVWF  x27
4C7A:  MOVLB  0
4C7C:  CALL   0748
4C80:  BTFSC  16.6
4C82:  BSF    FF2.6
4C84:  BTFSC  16.7
4C86:  BSF    FF2.7
4C88:  DECFSZ xB4,F
4C8A:  BRA    4C66
....................         } 
....................         if(!input(BIS_BTN2_PIN)){  
4C8C:  BTFSC  F80.3
4C8E:  BRA    4D02
....................            mp3_stop();delay_ms(100); 
4C90:  CALL   1302
4C94:  CLRF   16
4C96:  BTFSC  FF2.6
4C98:  BSF    16.6
4C9A:  BCF    FF2.6
4C9C:  BTFSC  FF2.7
4C9E:  BSF    16.7
4CA0:  BCF    FF2.7
4CA2:  MOVLW  64
4CA4:  MOVLB  1
4CA6:  MOVWF  x27
4CA8:  MOVLB  0
4CAA:  CALL   0748
4CAE:  BTFSC  16.6
4CB0:  BSF    FF2.6
4CB2:  BTFSC  16.7
4CB4:  BSF    FF2.7
....................            mp3_play(wav_ding); 
4CB6:  CLRF   xFF
4CB8:  MOVLW  10
4CBA:  MOVWF  xFE
4CBC:  CALL   1658
....................            printf(lcd_putc,"\fSens: BIS BTN2 ");  
4CC0:  MOVLW  C0
4CC2:  MOVWF  FF6
4CC4:  MOVLW  04
4CC6:  MOVWF  FF7
4CC8:  CALL   0A06
....................            printf(lcd_putc,"\n    << <> >>"); 
4CCC:  MOVLW  D2
4CCE:  MOVWF  FF6
4CD0:  MOVLW  04
4CD2:  MOVWF  FF7
4CD4:  CALL   0A06
....................            delay_ms(1000); 
4CD8:  MOVLW  04
4CDA:  MOVWF  xB4
4CDC:  CLRF   16
4CDE:  BTFSC  FF2.6
4CE0:  BSF    16.6
4CE2:  BCF    FF2.6
4CE4:  BTFSC  FF2.7
4CE6:  BSF    16.7
4CE8:  BCF    FF2.7
4CEA:  MOVLW  FA
4CEC:  MOVLB  1
4CEE:  MOVWF  x27
4CF0:  MOVLB  0
4CF2:  CALL   0748
4CF6:  BTFSC  16.6
4CF8:  BSF    FF2.6
4CFA:  BTFSC  16.7
4CFC:  BSF    FF2.7
4CFE:  DECFSZ xB4,F
4D00:  BRA    4CDC
4D02:  CLRF   16
4D04:  BTFSC  FF2.6
4D06:  BSF    16.6
4D08:  BCF    FF2.6
4D0A:  BTFSC  FF2.7
4D0C:  BSF    16.7
4D0E:  BCF    FF2.7
....................         } 
....................  
.................... //        printf(lcd_putc,"\fSens: ?",);  
.................... //        printf(lcd_putc,"\n    << <> >>"); 
....................         delay_ms(100); 
4D10:  MOVLW  64
4D12:  MOVLB  1
4D14:  MOVWF  x27
4D16:  MOVLB  0
4D18:  CALL   0748
4D1C:  BTFSC  16.6
4D1E:  BSF    FF2.6
4D20:  BTFSC  16.7
4D22:  BSF    FF2.7
....................          
....................     }while(btn!=BUTON_ONAY); 
4D24:  MOVF   xB3,W
4D26:  SUBLW  6F
4D28:  BTFSS  FD8.2
4D2A:  BRA    493E
....................      
....................      
....................     enable_interrupts(GLOBAL); 
4D2C:  MOVLW  C0
4D2E:  IORWF  FF2,F
4D30:  GOTO   54FA (RETURN)
.................... } 
....................  
.................... int dfPlayer_ses_kaydet(int n){ 
4D34:  MOVLW  0F
4D36:  MOVWF  xB3
4D38:  CLRF   xB4
....................     unsigned int ses=15; 
....................     char btn=0; 
....................      
....................     mp3_stop(); 
4D3A:  CALL   1302
4D3E:  CLRF   16
4D40:  BTFSC  FF2.6
4D42:  BSF    16.6
4D44:  BCF    FF2.6
4D46:  BTFSC  FF2.7
4D48:  BSF    16.7
4D4A:  BCF    FF2.7
....................     delay_ms(100); 
4D4C:  MOVLW  64
4D4E:  MOVLB  1
4D50:  MOVWF  x27
4D52:  MOVLB  0
4D54:  CALL   0748
4D58:  BTFSC  16.6
4D5A:  BSF    FF2.6
4D5C:  BTFSC  16.7
4D5E:  BSF    FF2.7
....................     mp3_play(mp3_adele_Rolling); 
4D60:  CLRF   xFF
4D62:  MOVLW  14
4D64:  MOVWF  xFE
4D66:  CALL   1658
....................     ses=read_eeprom(EE_ADR_MAX_SES); 
4D6A:  MOVFF  FF2,B5
4D6E:  BCF    FF2.6
4D70:  BCF    FF2.7
4D72:  MOVLW  07
4D74:  MOVWF  FA9
4D76:  BCF    FA6.6
4D78:  BCF    FA6.7
4D7A:  BSF    FA6.0
4D7C:  MOVF   FA8,W
4D7E:  BTFSC  xB5.6
4D80:  BSF    FF2.6
4D82:  BTFSC  xB5.7
4D84:  BSF    FF2.7
4D86:  MOVWF  xB3
....................     if(ses>30) ses=30; 
4D88:  MOVF   xB3,W
4D8A:  SUBLW  1E
4D8C:  BC    4D92
4D8E:  MOVLW  1E
4D90:  MOVWF  xB3
....................     do{ 
....................          btn=btn_getir(); 
4D92:  CALL   3CE0
4D96:  MOVFF  01,B4
....................         if(btn==BUTON_SOL){ 
4D9A:  MOVF   xB4,W
4D9C:  SUBLW  73
4D9E:  BNZ   4DD4
....................           ses--; 
4DA0:  DECF   xB3,F
....................           if( ses<1) ses=1; 
4DA2:  MOVF   xB3,F
4DA4:  BNZ   4DAA
4DA6:  MOVLW  01
4DA8:  MOVWF  xB3
....................           mp3_set_volume(ses); 
4DAA:  MOVFF  B3,B5
4DAE:  CALL   1312
4DB2:  CLRF   16
4DB4:  BTFSC  FF2.6
4DB6:  BSF    16.6
4DB8:  BCF    FF2.6
4DBA:  BTFSC  FF2.7
4DBC:  BSF    16.7
4DBE:  BCF    FF2.7
....................           delay_ms(100); 
4DC0:  MOVLW  64
4DC2:  MOVLB  1
4DC4:  MOVWF  x27
4DC6:  MOVLB  0
4DC8:  CALL   0748
4DCC:  BTFSC  16.6
4DCE:  BSF    FF2.6
4DD0:  BTFSC  16.7
4DD2:  BSF    FF2.7
....................         } 
....................         if(btn==BUTON_SAG){ 
4DD4:  MOVF   xB4,W
4DD6:  SUBLW  67
4DD8:  BNZ   4E10
....................           ses++; 
4DDA:  INCF   xB3,F
....................           if( ses>30) ses=30; 
4DDC:  MOVF   xB3,W
4DDE:  SUBLW  1E
4DE0:  BC    4DE6
4DE2:  MOVLW  1E
4DE4:  MOVWF  xB3
....................           mp3_set_volume(ses); 
4DE6:  MOVFF  B3,B5
4DEA:  CALL   1312
4DEE:  CLRF   16
4DF0:  BTFSC  FF2.6
4DF2:  BSF    16.6
4DF4:  BCF    FF2.6
4DF6:  BTFSC  FF2.7
4DF8:  BSF    16.7
4DFA:  BCF    FF2.7
....................           delay_ms(100); 
4DFC:  MOVLW  64
4DFE:  MOVLB  1
4E00:  MOVWF  x27
4E02:  MOVLB  0
4E04:  CALL   0748
4E08:  BTFSC  16.6
4E0A:  BSF    FF2.6
4E0C:  BTFSC  16.7
4E0E:  BSF    FF2.7
....................         } 
....................         printf(lcd_putc,"\fSES: %u ",ses);  
4E10:  MOVLW  E0
4E12:  MOVWF  FF6
4E14:  MOVLW  04
4E16:  MOVWF  FF7
4E18:  MOVLW  06
4E1A:  MOVLB  1
4E1C:  MOVWF  x02
4E1E:  MOVLB  0
4E20:  CALL   162E
4E24:  MOVFF  B3,B5
4E28:  MOVLW  1B
4E2A:  MOVWF  xB6
4E2C:  CALL   0C9A
4E30:  MOVLW  20
4E32:  MOVLB  1
4E34:  MOVWF  x0E
4E36:  MOVLB  0
4E38:  CALL   0996
....................         printf(lcd_putc,"\n    << <> >>"); 
4E3C:  MOVLW  EA
4E3E:  MOVWF  FF6
4E40:  MOVLW  04
4E42:  MOVWF  FF7
4E44:  CALL   0A06
4E48:  CLRF   16
4E4A:  BTFSC  FF2.6
4E4C:  BSF    16.6
4E4E:  BCF    FF2.6
4E50:  BTFSC  FF2.7
4E52:  BSF    16.7
4E54:  BCF    FF2.7
....................         delay_ms(100); 
4E56:  MOVLW  64
4E58:  MOVLB  1
4E5A:  MOVWF  x27
4E5C:  MOVLB  0
4E5E:  CALL   0748
4E62:  BTFSC  16.6
4E64:  BSF    FF2.6
4E66:  BTFSC  16.7
4E68:  BSF    FF2.7
....................          
....................      }while(btn!=BUTON_ONAY); 
4E6A:  MOVF   xB4,W
4E6C:  SUBLW  6F
4E6E:  BNZ   4D92
....................       
....................     dfPlayer_ses=ses; 
4E70:  MOVFF  B3,9B
....................     write_eeprom(EE_ADR_MAX_SES,ses); 
4E74:  MOVF   FF2,W
4E76:  MOVWF  00
4E78:  BCF    FF2.6
4E7A:  BCF    FF2.7
4E7C:  MOVLW  07
4E7E:  MOVWF  FA9
4E80:  MOVFF  B3,FA8
4E84:  BCF    FA6.6
4E86:  BCF    FA6.7
4E88:  BSF    FA6.2
4E8A:  MOVLB  F
4E8C:  MOVLW  55
4E8E:  MOVWF  FA7
4E90:  MOVLW  AA
4E92:  MOVWF  FA7
4E94:  BSF    FA6.1
4E96:  BTFSC  FA6.1
4E98:  BRA    4E96
4E9A:  BCF    FA6.2
4E9C:  MOVF   00,W
4E9E:  IORWF  FF2,F
....................     printf(lcd_putc,"\f ! KAYDEDILDI !");  
4EA0:  MOVLW  F8
4EA2:  MOVWF  FF6
4EA4:  MOVLW  04
4EA6:  MOVWF  FF7
4EA8:  MOVLB  0
4EAA:  CALL   0A06
....................     delay_ms(1500); 
4EAE:  MOVLW  06
4EB0:  MOVWF  xB5
4EB2:  CLRF   16
4EB4:  BTFSC  FF2.6
4EB6:  BSF    16.6
4EB8:  BCF    FF2.6
4EBA:  BTFSC  FF2.7
4EBC:  BSF    16.7
4EBE:  BCF    FF2.7
4EC0:  MOVLW  FA
4EC2:  MOVLB  1
4EC4:  MOVWF  x27
4EC6:  MOVLB  0
4EC8:  CALL   0748
4ECC:  BTFSC  16.6
4ECE:  BSF    FF2.6
4ED0:  BTFSC  16.7
4ED2:  BSF    FF2.7
4ED4:  DECFSZ xB5,F
4ED6:  BRA    4EB2
....................     return n+1; 
4ED8:  MOVLW  01
4EDA:  ADDWF  xB2,W
4EDC:  MOVWF  01
4EDE:  GOTO   5506 (RETURN)
.................... } 
.................... int jeton_calisma_sayi_kaydet(int n) 
*
4FA2:  CLRF   xB3
4FA4:  CLRF   xB4
.................... { 
....................     signed int jtn=0; 
....................     char btn=0; 
....................     jtn=read_eeprom(EE_ADR_JTN_SYS); 
4FA6:  MOVFF  FF2,B5
4FAA:  BCF    FF2.6
4FAC:  BCF    FF2.7
4FAE:  MOVLW  06
4FB0:  MOVWF  FA9
4FB2:  BCF    FA6.6
4FB4:  BCF    FA6.7
4FB6:  BSF    FA6.0
4FB8:  MOVF   FA8,W
4FBA:  BTFSC  xB5.6
4FBC:  BSF    FF2.6
4FBE:  BTFSC  xB5.7
4FC0:  BSF    FF2.7
4FC2:  MOVWF  xB3
....................     if(jtn>20) jtn=0; 
4FC4:  BTFSC  xB3.7
4FC6:  BRA    4FD0
4FC8:  MOVF   xB3,W
4FCA:  SUBLW  14
4FCC:  BC    4FD0
4FCE:  CLRF   xB3
....................      printf(lcd_putc,"\fDIKKAT !!!");  
4FD0:  MOVLW  0A
4FD2:  MOVWF  FF6
4FD4:  MOVLW  05
4FD6:  MOVWF  FF7
4FD8:  CALL   0A06
....................      printf(lcd_putc,"\nKartli sis. de,"); 
4FDC:  MOVLW  16
4FDE:  MOVWF  FF6
4FE0:  MOVLW  05
4FE2:  MOVWF  FF7
4FE4:  CALL   0A06
....................      delay_ms(2500); 
4FE8:  MOVLW  0A
4FEA:  MOVWF  xB5
4FEC:  CLRF   16
4FEE:  BTFSC  FF2.6
4FF0:  BSF    16.6
4FF2:  BCF    FF2.6
4FF4:  BTFSC  FF2.7
4FF6:  BSF    16.7
4FF8:  BCF    FF2.7
4FFA:  MOVLW  FA
4FFC:  MOVLB  1
4FFE:  MOVWF  x27
5000:  MOVLB  0
5002:  CALL   0748
5006:  BTFSC  16.6
5008:  BSF    FF2.6
500A:  BTFSC  16.7
500C:  BSF    FF2.7
500E:  DECFSZ xB5,F
5010:  BRA    4FEC
....................      printf(lcd_putc,"\njeton=0 olmali.."); 
5012:  MOVLW  28
5014:  MOVWF  FF6
5016:  MOVLW  05
5018:  MOVWF  FF7
501A:  CALL   0A06
....................      delay_ms(2500); 
501E:  MOVLW  0A
5020:  MOVWF  xB5
5022:  CLRF   16
5024:  BTFSC  FF2.6
5026:  BSF    16.6
5028:  BCF    FF2.6
502A:  BTFSC  FF2.7
502C:  BSF    16.7
502E:  BCF    FF2.7
5030:  MOVLW  FA
5032:  MOVLB  1
5034:  MOVWF  x27
5036:  MOVLB  0
5038:  CALL   0748
503C:  BTFSC  16.6
503E:  BSF    FF2.6
5040:  BTFSC  16.7
5042:  BSF    FF2.7
5044:  DECFSZ xB5,F
5046:  BRA    5022
....................       
....................      do{ 
....................         btn=btn_getir(); 
5048:  CALL   3CE0
504C:  MOVFF  01,B4
....................         if(btn==BUTON_SOL){ 
5050:  MOVF   xB4,W
5052:  SUBLW  73
5054:  BNZ   505E
....................             jtn--; 
5056:  DECF   xB3,F
....................             if(jtn<0) jtn=0; 
5058:  BTFSS  xB3.7
505A:  BRA    505E
505C:  CLRF   xB3
....................         } 
....................          if(btn==BUTON_SAG){ 
505E:  MOVF   xB4,W
5060:  SUBLW  67
5062:  BNZ   5074
....................             jtn++; 
5064:  INCF   xB3,F
....................             if(jtn>20) jtn=20; 
5066:  BTFSC  xB3.7
5068:  BRA    5074
506A:  MOVF   xB3,W
506C:  SUBLW  14
506E:  BC    5074
5070:  MOVLW  14
5072:  MOVWF  xB3
....................         } 
....................         printf(lcd_putc,"\fJeton: %d ",jtn);  
5074:  MOVLW  3A
5076:  MOVWF  FF6
5078:  MOVLW  05
507A:  MOVWF  FF7
507C:  MOVLW  08
507E:  MOVLB  1
5080:  MOVWF  x02
5082:  MOVLB  0
5084:  CALL   162E
5088:  MOVFF  B3,B5
508C:  MOVLW  18
508E:  MOVWF  xB6
5090:  BRA    4EE2
5092:  MOVLW  20
5094:  MOVLB  1
5096:  MOVWF  x0E
5098:  MOVLB  0
509A:  CALL   0996
....................         printf(lcd_putc,"\n    << <> >>"); 
509E:  MOVLW  46
50A0:  MOVWF  FF6
50A2:  MOVLW  05
50A4:  MOVWF  FF7
50A6:  CALL   0A06
50AA:  CLRF   16
50AC:  BTFSC  FF2.6
50AE:  BSF    16.6
50B0:  BCF    FF2.6
50B2:  BTFSC  FF2.7
50B4:  BSF    16.7
50B6:  BCF    FF2.7
....................         delay_ms(100); 
50B8:  MOVLW  64
50BA:  MOVLB  1
50BC:  MOVWF  x27
50BE:  MOVLB  0
50C0:  CALL   0748
50C4:  BTFSC  16.6
50C6:  BSF    FF2.6
50C8:  BTFSC  16.7
50CA:  BSF    FF2.7
....................           
....................      }while(btn!=BUTON_ONAY); 
50CC:  MOVF   xB4,W
50CE:  SUBLW  6F
50D0:  BNZ   5048
....................       
....................      calisma_jeton_sayisi=jtn; 
50D2:  MOVFF  B3,9C
....................      write_eeprom(EE_ADR_JTN_SYS,jtn); 
50D6:  MOVF   FF2,W
50D8:  MOVWF  00
50DA:  BCF    FF2.6
50DC:  BCF    FF2.7
50DE:  MOVLW  06
50E0:  MOVWF  FA9
50E2:  MOVFF  B3,FA8
50E6:  BCF    FA6.6
50E8:  BCF    FA6.7
50EA:  BSF    FA6.2
50EC:  MOVLB  F
50EE:  MOVLW  55
50F0:  MOVWF  FA7
50F2:  MOVLW  AA
50F4:  MOVWF  FA7
50F6:  BSF    FA6.1
50F8:  BTFSC  FA6.1
50FA:  BRA    50F8
50FC:  BCF    FA6.2
50FE:  MOVF   00,W
5100:  IORWF  FF2,F
....................       
....................      printf(lcd_putc,"\f ! KAYDEDILDI !");  
5102:  MOVLW  54
5104:  MOVWF  FF6
5106:  MOVLW  05
5108:  MOVWF  FF7
510A:  MOVLB  0
510C:  CALL   0A06
....................      delay_ms(1500); 
5110:  MOVLW  06
5112:  MOVWF  xB5
5114:  CLRF   16
5116:  BTFSC  FF2.6
5118:  BSF    16.6
511A:  BCF    FF2.6
511C:  BTFSC  FF2.7
511E:  BSF    16.7
5120:  BCF    FF2.7
5122:  MOVLW  FA
5124:  MOVLB  1
5126:  MOVWF  x27
5128:  MOVLB  0
512A:  CALL   0748
512E:  BTFSC  16.6
5130:  BSF    FF2.6
5132:  BTFSC  16.7
5134:  BSF    FF2.7
5136:  DECFSZ xB5,F
5138:  BRA    5114
....................      return n+1; 
513A:  MOVLW  01
513C:  ADDWF  xB2,W
513E:  MOVWF  01
5140:  GOTO   5512 (RETURN)
.................... } 
....................  
.................... int ee_reset(int n){ 
5144:  CLRF   xB3
....................     char btn=0; 
....................     printf(lcd_putc,"\fRESET ?");  
5146:  MOVLW  66
5148:  MOVWF  FF6
514A:  MOVLW  05
514C:  MOVWF  FF7
514E:  CALL   0A06
....................     printf(lcd_putc,"\n   <E> <> <H>"); 
5152:  MOVLW  70
5154:  MOVWF  FF6
5156:  MOVLW  05
5158:  MOVWF  FF7
515A:  CALL   0A06
....................     do{ 
....................         btn=btn_getir(); 
515E:  CALL   3CE0
5162:  MOVFF  01,B3
....................         if(btn==BUTON_SOL){ 
5166:  MOVF   xB3,W
5168:  SUBLW  73
516A:  BTFSS  FD8.2
516C:  BRA    5440
....................              
....................             toplam_jeton_sayisi=0; 
516E:  CLRF   44
5170:  CLRF   43
5172:  CLRF   42
5174:  CLRF   41
....................             write_eeprom(EE_ADR_TOP_JTN_SYS,make8(0xFF,0));//LSB 
5176:  MOVF   FF2,W
5178:  MOVWF  00
517A:  BCF    FF2.6
517C:  BCF    FF2.7
517E:  CLRF   FA9
5180:  SETF   FA8
5182:  BCF    FA6.6
5184:  BCF    FA6.7
5186:  BSF    FA6.2
5188:  MOVLB  F
518A:  MOVLW  55
518C:  MOVWF  FA7
518E:  MOVLW  AA
5190:  MOVWF  FA7
5192:  BSF    FA6.1
5194:  BTFSC  FA6.1
5196:  BRA    5194
5198:  BCF    FA6.2
519A:  MOVF   00,W
519C:  IORWF  FF2,F
....................             write_eeprom(EE_ADR_TOP_JTN_SYS+1,make8(0xFF,1)); 
519E:  MOVFF  FF2,00
51A2:  BCF    FF2.6
51A4:  BCF    FF2.7
51A6:  MOVLW  01
51A8:  MOVWF  FA9
51AA:  CLRF   FA8
51AC:  BCF    FA6.6
51AE:  BCF    FA6.7
51B0:  BSF    FA6.2
51B2:  MOVLW  55
51B4:  MOVWF  FA7
51B6:  MOVLW  AA
51B8:  MOVWF  FA7
51BA:  BSF    FA6.1
51BC:  BTFSC  FA6.1
51BE:  BRA    51BC
51C0:  BCF    FA6.2
51C2:  MOVF   00,W
51C4:  IORWF  FF2,F
....................             write_eeprom(EE_ADR_TOP_JTN_SYS+2,make8(0xFF,2)); 
51C6:  MOVFF  FF2,00
51CA:  BCF    FF2.6
51CC:  BCF    FF2.7
51CE:  MOVLW  02
51D0:  MOVWF  FA9
51D2:  CLRF   FA8
51D4:  BCF    FA6.6
51D6:  BCF    FA6.7
51D8:  BSF    FA6.2
51DA:  MOVLW  55
51DC:  MOVWF  FA7
51DE:  MOVLW  AA
51E0:  MOVWF  FA7
51E2:  BSF    FA6.1
51E4:  BTFSC  FA6.1
51E6:  BRA    51E4
51E8:  BCF    FA6.2
51EA:  MOVF   00,W
51EC:  IORWF  FF2,F
....................             write_eeprom(EE_ADR_TOP_JTN_SYS+3,make8(0xFF,3));//MSB 
51EE:  MOVFF  FF2,00
51F2:  BCF    FF2.6
51F4:  BCF    FF2.7
51F6:  MOVLW  03
51F8:  MOVWF  FA9
51FA:  CLRF   FA8
51FC:  BCF    FA6.6
51FE:  BCF    FA6.7
5200:  BSF    FA6.2
5202:  MOVLW  55
5204:  MOVWF  FA7
5206:  MOVLW  AA
5208:  MOVWF  FA7
520A:  BSF    FA6.1
520C:  BTFSC  FA6.1
520E:  BRA    520C
5210:  BCF    FA6.2
5212:  MOVF   00,W
5214:  IORWF  FF2,F
....................             printf(lcd_putc,"\fTOP.JetonSayisi:");  
5216:  MOVLW  80
5218:  MOVWF  FF6
521A:  MOVLW  05
521C:  MOVWF  FF7
521E:  MOVLB  0
5220:  CALL   0A06
....................             printf(lcd_putc,"\n   0"); 
5224:  MOVLW  92
5226:  MOVWF  FF6
5228:  MOVLW  05
522A:  MOVWF  FF7
522C:  CALL   0A06
....................             delay_ms(1000); 
5230:  MOVLW  04
5232:  MOVWF  xB4
5234:  CLRF   16
5236:  BTFSC  FF2.6
5238:  BSF    16.6
523A:  BCF    FF2.6
523C:  BTFSC  FF2.7
523E:  BSF    16.7
5240:  BCF    FF2.7
5242:  MOVLW  FA
5244:  MOVLB  1
5246:  MOVWF  x27
5248:  MOVLB  0
524A:  CALL   0748
524E:  BTFSC  16.6
5250:  BSF    FF2.6
5252:  BTFSC  16.7
5254:  BSF    FF2.7
5256:  DECFSZ xB4,F
5258:  BRA    5234
....................              
....................             write_eeprom(EE_ADR_OYUN_SURE,(unsigned int)(2.5*10.0));   // default 2.5 dk 
525A:  MOVF   FF2,W
525C:  MOVWF  00
525E:  BCF    FF2.6
5260:  BCF    FF2.7
5262:  MOVLW  04
5264:  MOVWF  FA9
5266:  MOVLW  19
5268:  MOVWF  FA8
526A:  BCF    FA6.6
526C:  BCF    FA6.7
526E:  BSF    FA6.2
5270:  MOVLB  F
5272:  MOVLW  55
5274:  MOVWF  FA7
5276:  MOVLW  AA
5278:  MOVWF  FA7
527A:  BSF    FA6.1
527C:  BTFSC  FA6.1
527E:  BRA    527C
5280:  BCF    FA6.2
5282:  MOVF   00,W
5284:  IORWF  FF2,F
....................             printf(lcd_putc,"\fOYUN SURE:");  
5286:  MOVLW  98
5288:  MOVWF  FF6
528A:  MOVLW  05
528C:  MOVWF  FF7
528E:  MOVLB  0
5290:  CALL   0A06
....................             printf(lcd_putc,"\n   2.5 dk."); 
5294:  MOVLW  A4
5296:  MOVWF  FF6
5298:  MOVLW  05
529A:  MOVWF  FF7
529C:  CALL   0A06
....................             delay_ms(1000); 
52A0:  MOVLW  04
52A2:  MOVWF  xB4
52A4:  CLRF   16
52A6:  BTFSC  FF2.6
52A8:  BSF    16.6
52AA:  BCF    FF2.6
52AC:  BTFSC  FF2.7
52AE:  BSF    16.7
52B0:  BCF    FF2.7
52B2:  MOVLW  FA
52B4:  MOVLB  1
52B6:  MOVWF  x27
52B8:  MOVLB  0
52BA:  CALL   0748
52BE:  BTFSC  16.6
52C0:  BSF    FF2.6
52C2:  BTFSC  16.7
52C4:  BSF    FF2.7
52C6:  DECFSZ xB4,F
52C8:  BRA    52A4
....................              
....................             write_eeprom(EE_ADR_BIS_SEC_SURE, 0x05); 
52CA:  MOVF   FF2,W
52CC:  MOVWF  00
52CE:  BCF    FF2.6
52D0:  BCF    FF2.7
52D2:  MOVLW  05
52D4:  MOVWF  FA9
52D6:  MOVWF  FA8
52D8:  BCF    FA6.6
52DA:  BCF    FA6.7
52DC:  BSF    FA6.2
52DE:  MOVLB  F
52E0:  MOVLW  55
52E2:  MOVWF  FA7
52E4:  MOVLW  AA
52E6:  MOVWF  FA7
52E8:  BSF    FA6.1
52EA:  BTFSC  FA6.1
52EC:  BRA    52EA
52EE:  BCF    FA6.2
52F0:  MOVF   00,W
52F2:  IORWF  FF2,F
....................             printf(lcd_putc,"\fBIS. SECME SURE:"); 
52F4:  MOVLW  B0
52F6:  MOVWF  FF6
52F8:  MOVLW  05
52FA:  MOVWF  FF7
52FC:  MOVLB  0
52FE:  CALL   0A06
....................             printf(lcd_putc,"\n   5 S.",); 
5302:  MOVLW  C2
5304:  MOVWF  FF6
5306:  MOVLW  05
5308:  MOVWF  FF7
530A:  CALL   0A06
....................             delay_ms(1000); 
530E:  MOVLW  04
5310:  MOVWF  xB4
5312:  CLRF   16
5314:  BTFSC  FF2.6
5316:  BSF    16.6
5318:  BCF    FF2.6
531A:  BTFSC  FF2.7
531C:  BSF    16.7
531E:  BCF    FF2.7
5320:  MOVLW  FA
5322:  MOVLB  1
5324:  MOVWF  x27
5326:  MOVLB  0
5328:  CALL   0748
532C:  BTFSC  16.6
532E:  BSF    FF2.6
5330:  BTFSC  16.7
5332:  BSF    FF2.7
5334:  DECFSZ xB4,F
5336:  BRA    5312
....................              
....................             write_eeprom(EE_ADR_MAX_PWM, make8(0x90,0));     //LSB 400 -> 0x0190 
5338:  MOVF   FF2,W
533A:  MOVWF  00
533C:  BCF    FF2.6
533E:  BCF    FF2.7
5340:  MOVLW  08
5342:  MOVWF  FA9
5344:  MOVLW  90
5346:  MOVWF  FA8
5348:  BCF    FA6.6
534A:  BCF    FA6.7
534C:  BSF    FA6.2
534E:  MOVLB  F
5350:  MOVLW  55
5352:  MOVWF  FA7
5354:  MOVLW  AA
5356:  MOVWF  FA7
5358:  BSF    FA6.1
535A:  BTFSC  FA6.1
535C:  BRA    535A
535E:  BCF    FA6.2
5360:  MOVF   00,W
5362:  IORWF  FF2,F
....................             write_eeprom(EE_ADR_MAX_PWM+1, make8(0x01,1)); 
5364:  MOVFF  FF2,00
5368:  BCF    FF2.6
536A:  BCF    FF2.7
536C:  MOVLW  09
536E:  MOVWF  FA9
5370:  CLRF   FA8
5372:  BCF    FA6.6
5374:  BCF    FA6.7
5376:  BSF    FA6.2
5378:  MOVLW  55
537A:  MOVWF  FA7
537C:  MOVLW  AA
537E:  MOVWF  FA7
5380:  BSF    FA6.1
5382:  BTFSC  FA6.1
5384:  BRA    5382
5386:  BCF    FA6.2
5388:  MOVF   00,W
538A:  IORWF  FF2,F
....................             printf(lcd_putc,"\fHIZ :",);  
538C:  MOVLW  CC
538E:  MOVWF  FF6
5390:  MOVLW  05
5392:  MOVWF  FF7
5394:  MOVLB  0
5396:  CALL   0A06
....................             printf(lcd_putc,"\n   400",); 
539A:  MOVLW  D4
539C:  MOVWF  FF6
539E:  MOVLW  05
53A0:  MOVWF  FF7
53A2:  CALL   0A06
....................             delay_ms(1000); 
53A6:  MOVLW  04
53A8:  MOVWF  xB4
53AA:  CLRF   16
53AC:  BTFSC  FF2.6
53AE:  BSF    16.6
53B0:  BCF    FF2.6
53B2:  BTFSC  FF2.7
53B4:  BSF    16.7
53B6:  BCF    FF2.7
53B8:  MOVLW  FA
53BA:  MOVLB  1
53BC:  MOVWF  x27
53BE:  MOVLB  0
53C0:  CALL   0748
53C4:  BTFSC  16.6
53C6:  BSF    FF2.6
53C8:  BTFSC  16.7
53CA:  BSF    FF2.7
53CC:  DECFSZ xB4,F
53CE:  BRA    53AA
....................              
....................             write_eeprom(EE_ADR_JTN_SYS,0x00); 
53D0:  MOVF   FF2,W
53D2:  MOVWF  00
53D4:  BCF    FF2.6
53D6:  BCF    FF2.7
53D8:  MOVLW  06
53DA:  MOVWF  FA9
53DC:  CLRF   FA8
53DE:  BCF    FA6.6
53E0:  BCF    FA6.7
53E2:  BSF    FA6.2
53E4:  MOVLB  F
53E6:  MOVLW  55
53E8:  MOVWF  FA7
53EA:  MOVLW  AA
53EC:  MOVWF  FA7
53EE:  BSF    FA6.1
53F0:  BTFSC  FA6.1
53F2:  BRA    53F0
53F4:  BCF    FA6.2
53F6:  MOVF   00,W
53F8:  IORWF  FF2,F
....................             printf(lcd_putc,"\fCALISMA JETON:"); 
53FA:  MOVLW  DC
53FC:  MOVWF  FF6
53FE:  MOVLW  05
5400:  MOVWF  FF7
5402:  MOVLB  0
5404:  CALL   0A06
....................             printf(lcd_putc,"\n   0"); 
5408:  MOVLW  EC
540A:  MOVWF  FF6
540C:  MOVLW  05
540E:  MOVWF  FF7
5410:  CALL   0A06
....................             delay_ms(1000); 
5414:  MOVLW  04
5416:  MOVWF  xB4
5418:  CLRF   16
541A:  BTFSC  FF2.6
541C:  BSF    16.6
541E:  BCF    FF2.6
5420:  BTFSC  FF2.7
5422:  BSF    16.7
5424:  BCF    FF2.7
5426:  MOVLW  FA
5428:  MOVLB  1
542A:  MOVWF  x27
542C:  MOVLB  0
542E:  CALL   0748
5432:  BTFSC  16.6
5434:  BSF    FF2.6
5436:  BTFSC  16.7
5438:  BSF    FF2.7
543A:  DECFSZ xB4,F
543C:  BRA    5418
....................              
....................             break; 
543E:  BRA    5450
....................               
....................         } 
....................     } while(btn!=BUTON_ONAY || btn!=BUTON_SAG); 
5440:  MOVF   xB3,W
5442:  SUBLW  6F
5444:  BTFSS  FD8.2
5446:  BRA    515E
5448:  MOVF   xB3,W
544A:  SUBLW  67
544C:  BTFSS  FD8.2
544E:  BRA    515E
5450:  GOTO   551E (RETURN)
.................... } 
....................  
.................... void lcd_menu_islem(){ 
5454:  CLRF   xAF
5456:  CLRF   xB0
5458:  BCF    xB1.0
....................      
....................     int btn=0; 
....................     signed int alt_menu=0; 
....................     int1 cikis=0; 
....................     mp3_stop(); 
545A:  CALL   1302
545E:  CLRF   16
5460:  BTFSC  FF2.6
5462:  BSF    16.6
5464:  BCF    FF2.6
5466:  BTFSC  FF2.7
5468:  BSF    16.7
546A:  BCF    FF2.7
....................     delay_ms(100); 
546C:  MOVLW  64
546E:  MOVLB  1
5470:  MOVWF  x27
5472:  MOVLB  0
5474:  CALL   0748
5478:  BTFSC  16.6
547A:  BSF    FF2.6
547C:  BTFSC  16.7
547E:  BSF    FF2.7
....................     do{ 
....................         btn=btn_getir(); 
5480:  CALL   3CE0
5484:  MOVFF  01,AF
....................          
....................         if(btn==BUTON_SOL){ 
5488:  MOVF   xAF,W
548A:  SUBLW  73
548C:  BNZ   5498
....................             alt_menu--; 
548E:  DECF   xB0,F
....................             if(alt_menu<0) alt_menu=MENU_SAYISI; 
5490:  BTFSS  xB0.7
5492:  BRA    5498
5494:  MOVLW  08
5496:  MOVWF  xB0
....................         } 
....................  
....................         if(btn==BUTON_SAG){ 
5498:  MOVF   xAF,W
549A:  SUBLW  67
549C:  BNZ   54AC
....................             alt_menu++; 
549E:  INCF   xB0,F
....................             if(alt_menu>MENU_SAYISI) alt_menu=0; 
54A0:  BTFSC  xB0.7
54A2:  BRA    54AC
54A4:  MOVF   xB0,W
54A6:  SUBLW  08
54A8:  BC    54AC
54AA:  CLRF   xB0
....................         } 
....................         lcd_menu_sec(alt_menu); 
54AC:  MOVFF  B0,B2
54B0:  GOTO   3E0C
....................                  
....................         if(btn==BUTON_ONAY){ 
54B4:  MOVF   xAF,W
54B6:  SUBLW  6F
54B8:  BNZ   5526
....................              
....................             switch(alt_menu){ 
54BA:  MOVLW  01
54BC:  SUBWF  xB0,W
54BE:  ADDLW  F8
54C0:  BC    5526
54C2:  ADDLW  08
54C4:  GOTO   558E
....................                 case 1: 
....................                     alt_menu=oyun_sure_kaydet(alt_menu); 
54C8:  MOVFF  B0,B2
54CC:  GOTO   3F42
54D0:  MOVFF  01,B0
....................                     break; 
54D4:  BRA    5526
....................                 case 2: 
....................                     alt_menu=secme_sure_kaydet(alt_menu); 
54D6:  MOVFF  B0,B2
54DA:  GOTO   42CC
54DE:  MOVFF  01,B0
....................                     break; 
54E2:  BRA    5526
....................                 case 3:     
....................                     alt_menu=motor_pwm_kaydet(alt_menu); 
54E4:  MOVFF  B0,B2
54E8:  GOTO   441A
54EC:  MOVFF  01,B0
....................                     break; 
54F0:  BRA    5526
....................                 case 4:     
....................                     alt_menu=sensor_test(alt_menu); 
54F2:  MOVFF  B0,B2
54F6:  GOTO   4934
54FA:  MOVFF  01,B0
....................                     break; 
54FE:  BRA    5526
....................                 case 5: 
....................                     alt_menu=dfPlayer_ses_kaydet(alt_menu); 
5500:  MOVFF  B0,B2
5504:  BRA    4D34
5506:  MOVFF  01,B0
....................                     break; 
550A:  BRA    5526
....................                 case 6: 
....................                     alt_menu=jeton_calisma_sayi_kaydet(alt_menu); 
550C:  MOVFF  B0,B2
5510:  BRA    4FA2
5512:  MOVFF  01,B0
....................                     break; 
5516:  BRA    5526
....................                 case 7: 
....................                     alt_menu= ee_reset(alt_menu); 
5518:  MOVFF  B0,B2
551C:  BRA    5144
551E:  MOVFF  01,B0
....................                     break; 
5522:  BRA    5526
....................                 case 8: 
....................                     cikis=1; 
5524:  BSF    xB1.0
....................                     break; 
....................             } 
5526:  CLRF   16
5528:  BTFSC  FF2.6
552A:  BSF    16.6
552C:  BCF    FF2.6
552E:  BTFSC  FF2.7
5530:  BSF    16.7
5532:  BCF    FF2.7
....................         } 
....................         delay_ms(100); 
5534:  MOVLW  64
5536:  MOVLB  1
5538:  MOVWF  x27
553A:  MOVLB  0
553C:  CALL   0748
5540:  BTFSC  16.6
5542:  BSF    FF2.6
5544:  BTFSC  16.7
5546:  BSF    FF2.7
....................     }while(!cikis); 
5548:  BTFSS  xB1.0
554A:  BRA    5480
....................      
....................     printf(lcd_putc,"\f    YOYUNCAK"); 
554C:  MOVLW  F2
554E:  MOVWF  FF6
5550:  MOVLW  05
5552:  MOVWF  FF7
5554:  CALL   0A06
....................     printf(lcd_putc,"\n HIZLI & PEDALLI"); 
5558:  MOVLW  00
555A:  MOVWF  FF6
555C:  MOVLW  06
555E:  MOVWF  FF7
5560:  CALL   0A06
....................     mp3_stop(); 
5564:  CALL   1302
5568:  CLRF   16
556A:  BTFSC  FF2.6
556C:  BSF    16.6
556E:  BCF    FF2.6
5570:  BTFSC  FF2.7
5572:  BSF    16.7
5574:  BCF    FF2.7
....................     delay_ms(100); 
5576:  MOVLW  64
5578:  MOVLB  1
557A:  MOVWF  x27
557C:  MOVLB  0
557E:  CALL   0748
5582:  BTFSC  16.6
5584:  BSF    FF2.6
5586:  BTFSC  16.7
5588:  BSF    FF2.7
558A:  GOTO   5AC2 (RETURN)
....................     //mp3_play(mp3_getlowve_araba); 
....................      
....................      
.................... } 
....................  
....................  
....................  main() { 
*
55C8:  CLRF   FF8
55CA:  BCF    FF1.2
55CC:  BCF    FF0.6
55CE:  BCF    FF0.7
55D0:  BCF    FF1.0
55D2:  BSF    FD0.7
55D4:  BSF    07.7
55D6:  MOVLW  60
55D8:  MOVWF  FD3
55DA:  BSF    F9B.6
55DC:  BCF    F9B.7
55DE:  CLRF   29
55E0:  BSF    F70.3
55E2:  MOVLW  40
55E4:  MOVWF  F75
55E6:  MOVLW  03
55E8:  MOVWF  F76
55EA:  MOVLW  A6
55EC:  MOVWF  F72
55EE:  MOVLW  90
55F0:  MOVWF  F71
55F2:  BSF    FB8.3
55F4:  MOVLW  40
55F6:  MOVWF  FAF
55F8:  MOVLW  03
55FA:  MOVWF  FB0
55FC:  MOVLW  A6
55FE:  MOVWF  FAC
5600:  MOVLW  90
5602:  MOVWF  FAB
5604:  BCF    F94.4
5606:  BSF    F8B.4
5608:  BCF    F96.1
560A:  BSF    F8D.1
560C:  CLRF   2D
560E:  CLRF   2C
5610:  CLRF   2B
5612:  CLRF   2A
5614:  CLRF   35
5616:  CLRF   34
5618:  CLRF   36
561A:  CLRF   37
561C:  BCF    38.0
561E:  BCF    38.1
5620:  BCF    38.2
5622:  SETF   39
5624:  SETF   3A
5626:  MOVLW  35
5628:  MOVWF  3B
562A:  MOVWF  3C
562C:  CLRF   40
562E:  CLRF   3F
5630:  CLRF   3E
5632:  CLRF   3D
5634:  MOVLW  01
5636:  MOVWF  46
5638:  MOVLW  90
563A:  MOVWF  45
563C:  CLRF   48
563E:  CLRF   47
5640:  CLRF   4A
5642:  CLRF   49
5644:  CLRF   4C
5646:  CLRF   4B
5648:  CLRF   4E
564A:  CLRF   4D
564C:  CLRF   50
564E:  CLRF   4F
5650:  CLRF   52
5652:  CLRF   51
5654:  CLRF   54
5656:  CLRF   53
5658:  CLRF   56
565A:  CLRF   55
565C:  CLRF   5A
565E:  CLRF   59
5660:  CLRF   58
5662:  CLRF   57
5664:  CLRF   5E
5666:  CLRF   5D
5668:  CLRF   5C
566A:  CLRF   5B
566C:  CLRF   x62
566E:  CLRF   x61
5670:  CLRF   x60
5672:  CLRF   5F
5674:  CLRF   x66
5676:  CLRF   x65
5678:  CLRF   x64
567A:  CLRF   x63
567C:  CLRF   x68
567E:  CLRF   x67
5680:  CLRF   x6A
5682:  CLRF   x69
5684:  CLRF   x6E
5686:  CLRF   x6D
5688:  CLRF   x6C
568A:  CLRF   x6B
568C:  CLRF   x72
568E:  CLRF   x71
5690:  CLRF   x70
5692:  CLRF   x6F
5694:  CLRF   x73
5696:  CLRF   x74
5698:  CLRF   x76
569A:  CLRF   x75
569C:  CLRF   x78
569E:  CLRF   x77
56A0:  CLRF   x7A
56A2:  CLRF   x79
56A4:  CLRF   x7C
56A6:  CLRF   x7B
56A8:  CLRF   x7D
56AA:  CLRF   x7E
56AC:  CLRF   x82
56AE:  CLRF   x81
56B0:  CLRF   x80
56B2:  CLRF   x7F
56B4:  CLRF   x86
56B6:  CLRF   x85
56B8:  CLRF   x84
56BA:  CLRF   x83
56BC:  CLRF   x8A
56BE:  CLRF   x89
56C0:  CLRF   x88
56C2:  CLRF   x87
56C4:  CLRF   x8E
56C6:  CLRF   x8D
56C8:  CLRF   x8C
56CA:  CLRF   x8B
56CC:  CLRF   x92
56CE:  MOVLW  01
56D0:  MOVWF  x91
56D2:  MOVLW  5F
56D4:  MOVWF  x90
56D6:  MOVLW  90
56D8:  MOVWF  x8F
56DA:  CLRF   x96
56DC:  CLRF   x95
56DE:  CLRF   x94
56E0:  CLRF   x93
56E2:  MOVLW  27
56E4:  MOVWF  x98
56E6:  MOVLW  10
56E8:  MOVWF  x97
56EA:  CLRF   x99
56EC:  CLRF   x9A
56EE:  MOVLW  14
56F0:  MOVWF  x9B
56F2:  CLRF   x9C
56F4:  BCF    38.3
56F6:  BCF    38.4
56F8:  BCF    38.5
56FA:  CLRF   x9E
56FC:  CLRF   x9D
56FE:  CLRF   xA0
5700:  CLRF   x9F
5702:  MOVLW  13
5704:  MOVWF  xA4
5706:  CLRF   xAC
5708:  CLRF   xAE
570A:  CLRF   xAD
570C:  MOVF   FC1,W
570E:  ANDLW  F0
5710:  MOVWF  FC1
5712:  MOVLW  00
5714:  MOVLB  F
5716:  MOVWF  x38
5718:  MOVWF  x3C
571A:  MOVWF  x39
571C:  MOVWF  x3A
571E:  MOVWF  x3B
5720:  MOVLB  1
5722:  CLRF   x88
5724:  CLRF   F77
5726:  CLRF   F78
5728:  CLRF   F79
572A:  CLRF   2E
572C:  CLRF   2F
....................  
....................    setup_oscillator(OSC_32MHZ); 
572E:  MOVLW  60
5730:  MOVWF  FD3
5732:  BSF    F9B.6
5734:  BCF    F9B.7
....................  
....................    setup_timer_1(T1_DISABLED);  
5736:  CLRF   FCD
5738:  CLRF   FCC
....................    setup_timer_2(T2_DIV_BY_16, 124, 1);   // 32MHz fosc ile 4KHz yaklaþýk(div_16) 
573A:  MOVLW  00
573C:  IORLW  06
573E:  MOVWF  FBA
5740:  MOVLW  7C
5742:  MOVWF  FBB
....................    //setup_timer_2(T2_DIV_BY_16, 199, 1);   // 32MHz fosc ile 2.5KHz yaklaþýk(div_16) 
....................     
....................    setup_timer_4(T4_DISABLED,0,1);  
5744:  MOVLW  00
5746:  MOVLB  F
5748:  MOVWF  x51
574A:  MOVLW  00
574C:  MOVWF  x52
....................    setup_timer_5(T5_DISABLED); 
574E:  CLRF   x4D
5750:  CLRF   x4E
....................    setup_timer_6(T6_DISABLED,0,1);  
5752:  MOVWF  x4A
5754:  MOVLW  00
5756:  MOVWF  x4B
....................     
....................    setup_ccp1(CCP_PWM );  
5758:  BCF    F8B.2
575A:  MOVLW  0C
575C:  MOVWF  FBD
575E:  CLRF   FB7
5760:  CLRF   FB6
5762:  MOVLW  01
5764:  MOVWF  FB9
5766:  MOVLW  FC
5768:  ANDWF  x49,F
576A:  MOVLW  00
576C:  IORWF  x49,F
....................    setup_ccp2(CCP_PWM );  
576E:  BCF    F8B.1
5770:  MOVLW  0C
5772:  MOVWF  F66
5774:  CLRF   F65
5776:  CLRF   F64
5778:  MOVLW  01
577A:  MOVWF  F63
577C:  MOVLW  E7
577E:  ANDWF  x49,F
5780:  MOVLW  00
5782:  IORWF  x49,F
....................     
....................    setup_ccp3(CCP_OFF);  
5784:  MOVLW  F0
5786:  ANDWF  x5D,F
....................    setup_ccp4(CCP_OFF);  
5788:  ANDWF  x57,F
....................    setup_ccp5(CCP_OFF); 
578A:  ANDWF  x54,F
....................   
....................    setup_dac(DAC_OFF);  
578C:  CLRF   x41
....................    setup_comparator(NC_NC_NC_NC);  
578E:  CLRF   F77
5790:  MOVLW  04
5792:  MOVWF  F78
5794:  MOVWF  F79
....................    setup_vref(FALSE);  
5796:  CLRF   x42
....................    //setup_adc(ADC_OFF | NO_ANALOGS); //setup_adc(ADC_OFF);  
....................    //setup_adc_ports(NO_ANALOGS);  
....................    set_tris_a(0b00111111); 
5798:  MOVLW  3F
579A:  MOVWF  F92
....................    //set_tris_b(0b11111111); 
....................    set_tris_c(0b10101000); 
579C:  MOVLW  A8
579E:  MOVWF  F94
....................    set_tris_e(0b00001101); 
57A0:  BSF    F96.0
57A2:  BCF    F96.1
57A4:  BSF    F96.2
57A6:  BSF    F96.3
....................     
....................    output_low(PIN_C4); 
57A8:  BCF    F8B.4
....................    output_low(PIN_E1); 
57AA:  BCF    F8D.1
....................     
....................    lcd_init();  // Always call this first.  
57AC:  MOVLB  0
57AE:  GOTO   08A4
....................     
....................    setup_adc_ports(sAN0|sAN1);  //L298 motor çýkýþlarý akým ölçmek için. 
57B2:  MOVF   FC1,W
57B4:  ANDLW  F0
57B6:  MOVWF  FC1
57B8:  MOVLW  03
57BA:  MOVLB  F
57BC:  MOVWF  x38
57BE:  MOVLW  00
57C0:  MOVWF  x3C
57C2:  MOVWF  x39
57C4:  MOVWF  x3A
57C6:  MOVWF  x3B
....................    //setup_adc_ports(AN0_TO_AN1);   //18f4520 
....................    setup_adc(ADC_CLOCK_INTERNAL);   //ADC_CLOCK_DIV_8); 
57C8:  MOVF   FC0,W
57CA:  ANDLW  C0
57CC:  IORLW  07
57CE:  MOVWF  FC0
57D0:  BSF    FC0.7
57D2:  BSF    FC2.0
....................     
....................     ext_int_edge(H_TO_L);      // init interrupt triggering for button press  
57D4:  BCF    FF1.6
....................   // ext_int_edge( 0, L_TO_H); // Set up PIC18 EXT0 
....................    ext_int_edge( 1, L_TO_H); // Set up PIC18 EXT1 
57D6:  BSF    FF1.5
....................    ext_int_edge( 2, L_TO_H); // Set up PIC18 EXT0 
57D8:  BSF    FF1.4
....................     
....................    enable_interrupts(INT_EXT); 
57DA:  BSF    FF2.4
....................    disable_interrupts(INT_EXT1);       //HIZ1 
57DC:  BCF    FF0.3
....................    disable_interrupts(INT_EXT2); 
57DE:  BCF    FF0.4
....................    disable_interrupts(INT_RB); 
57E0:  CLRF   F62
....................    //enable_interrupts(INT_RB); 
....................   
....................    timer_kur();   
57E2:  MOVLB  0
57E4:  GOTO   095E
....................    enable_interrupts(GLOBAL); 
57E8:  MOVLW  C0
57EA:  IORWF  FF2,F
.................... //  
....................     //set_pwm1_duty(512);       //yarým peryot motoru döndürmediiii 
....................    set_pwm1_duty(0); 
57EC:  CLRF   FBE
....................    set_pwm2_duty(0); 
57EE:  CLRF   F67
....................     
....................    printf(lcd_putc,"\f    YOYUNCAK"); 
57F0:  MOVLW  12
57F2:  MOVWF  FF6
57F4:  MOVLW  06
57F6:  MOVWF  FF7
57F8:  CALL   0A06
....................    printf(lcd_putc,"\n HIZLI & PEDALLI"); 
57FC:  MOVLW  20
57FE:  MOVWF  FF6
5800:  MOVLW  06
5802:  MOVWF  FF7
5804:  CALL   0A06
....................    delay_ms(1500); 
5808:  MOVLW  06
580A:  MOVWF  xAF
580C:  CLRF   16
580E:  BTFSC  FF2.6
5810:  BSF    16.6
5812:  BCF    FF2.6
5814:  BTFSC  FF2.7
5816:  BSF    16.7
5818:  BCF    FF2.7
581A:  MOVLW  FA
581C:  MOVLB  1
581E:  MOVWF  x27
5820:  MOVLB  0
5822:  CALL   0748
5826:  BTFSC  16.6
5828:  BSF    FF2.6
582A:  BTFSC  16.7
582C:  BSF    FF2.7
582E:  DECFSZ xAF,F
5830:  BRA    580C
....................     
....................    ee_ilk_baslama_degerleri_oku() ; 
5832:  GOTO   0D08
....................  
....................    mp3_baslangic(dfPlayer_ses); 
5836:  MOVFF  9B,AF
583A:  GOTO   1338
....................  
....................    time=millis(); 
583E:  MOVFF  2D,40
5842:  MOVFF  2C,3F
5846:  MOVFF  2B,3E
584A:  MOVFF  2A,3D
....................  
....................    //fprintf(usbSerial,"JETON.."); 
....................    fprintf(Panel1Serial,"01010101c");  //Kablodaki gurultu vb verileri atmak için preamp benzeri bilgi..... 
584E:  MOVLW  32
5850:  MOVWF  FF6
5852:  MOVLW  06
5854:  MOVWF  FF7
5856:  CALL   141C
....................    fprintf(Panel2Serial,"01010101c");  //Kablodaki gurultu vb verileri atmak için 
585A:  MOVLW  3C
585C:  MOVWF  FF6
585E:  MOVLW  06
5860:  MOVWF  FF7
5862:  CALL   149E
....................     
....................    srand(450);  
5866:  CLRF   xB2
5868:  CLRF   xB1
586A:  MOVLW  01
586C:  MOVWF  xB0
586E:  MOVLW  C2
5870:  MOVWF  xAF
5872:  GOTO   14BE
....................    printf(lcd_putc,"\f    YOYUNCAK"); 
5876:  MOVLW  46
5878:  MOVWF  FF6
587A:  MOVLW  06
587C:  MOVWF  FF7
587E:  CALL   0A06
....................    printf(lcd_putc,"\n HIZLI & PEDALLI"); 
5882:  MOVLW  54
5884:  MOVWF  FF6
5886:  MOVLW  06
5888:  MOVWF  FF7
588A:  CALL   0A06
....................    delay_ms(1500); 
588E:  MOVLW  06
5890:  MOVWF  xAF
5892:  CLRF   16
5894:  BTFSC  FF2.6
5896:  BSF    16.6
5898:  BCF    FF2.6
589A:  BTFSC  FF2.7
589C:  BSF    16.7
589E:  BCF    FF2.7
58A0:  MOVLW  FA
58A2:  MOVLB  1
58A4:  MOVWF  x27
58A6:  MOVLB  0
58A8:  CALL   0748
58AC:  BTFSC  16.6
58AE:  BSF    FF2.6
58B0:  BTFSC  16.7
58B2:  BSF    FF2.7
58B4:  DECFSZ xAF,F
58B6:  BRA    5892
....................  
....................     //fprintf(usbSerial,"JETON.."); 
....................    fprintf(Panel1Serial,"01010101c");  //Kablodaki gurultu vb verileri atmak için preamp benzeri bilgi..... 
58B8:  MOVLW  66
58BA:  MOVWF  FF6
58BC:  MOVLW  06
58BE:  MOVWF  FF7
58C0:  CALL   141C
....................    fprintf(Panel2Serial,"01010101c");  //Kablodaki gurultu vb verileri atmak için 
58C4:  MOVLW  70
58C6:  MOVWF  FF6
58C8:  MOVLW  06
58CA:  MOVWF  FF7
58CC:  CALL   149E
....................     
....................    pevtime1 = pevtime2=millis(); 
58D0:  MOVFF  2D,5E
58D4:  MOVFF  2C,5D
58D8:  MOVFF  2B,5C
58DC:  MOVFF  2A,5B
58E0:  MOVFF  5E,5A
58E4:  MOVFF  5D,59
58E8:  MOVFF  5C,58
58EC:  MOVFF  5B,57
....................   
....................    while(TRUE){ 
....................         
....................        if(input(DF_BUSY_PIN)){ 
58F0:  BTFSS  F82.3
58F2:  BRA    58F8
....................            mp3_rastgele(); 
58F4:  GOTO   1674
....................        } 
....................        
....................        if(jetonAtildi){ 
58F8:  BTFSS  38.0
58FA:  BRA    5A9E
....................             
....................             mp3_stop(); delay_ms(100); 
58FC:  CALL   1302
5900:  CLRF   16
5902:  BTFSC  FF2.6
5904:  BSF    16.6
5906:  BCF    FF2.6
5908:  BTFSC  FF2.7
590A:  BSF    16.7
590C:  BCF    FF2.7
590E:  MOVLW  64
5910:  MOVLB  1
5912:  MOVWF  x27
5914:  MOVLB  0
5916:  CALL   0748
591A:  BTFSC  16.6
591C:  BSF    FF2.6
591E:  BTFSC  16.7
5920:  BSF    FF2.7
....................             mp3_play(wav_jeton); 
5922:  CLRF   xFF
5924:  MOVLW  09
5926:  MOVWF  xFE
5928:  CALL   1658
....................             delay_ms(300); 
592C:  MOVLW  02
592E:  MOVWF  xAF
5930:  CLRF   16
5932:  BTFSC  FF2.6
5934:  BSF    16.6
5936:  BCF    FF2.6
5938:  BTFSC  FF2.7
593A:  BSF    16.7
593C:  BCF    FF2.7
593E:  MOVLW  96
5940:  MOVLB  1
5942:  MOVWF  x27
5944:  MOVLB  0
5946:  CALL   0748
594A:  BTFSC  16.6
594C:  BSF    FF2.6
594E:  BTFSC  16.7
5950:  BSF    FF2.7
5952:  DECFSZ xAF,F
5954:  BRA    5930
....................              
....................             //printf(lcd_putc,"\fj:%u",jetonSay); 
....................              
....................             panel1_komut(JETON); 
5956:  MOVLW  4A
5958:  MOVLB  1
595A:  MOVWF  x00
595C:  MOVLB  0
595E:  CALL   13BA
5962:  MOVLW  63
5964:  MOVLB  1
5966:  MOVWF  x00
5968:  MOVLB  0
596A:  CALL   13BA
....................             panel2_komut(JETON); 
596E:  MOVLW  4A
5970:  MOVLB  1
5972:  MOVWF  x00
5974:  MOVLB  0
5976:  CALL   143C
597A:  MOVLW  63
597C:  MOVLB  1
597E:  MOVWF  x00
5980:  MOVLB  0
5982:  CALL   143C
....................              
....................             jetonAtildi=FALSE; 
5986:  BCF    38.0
....................             zmn_say1=zmn_say2=0; 
5988:  CLRF   x9A
598A:  MOVFF  9A,99
....................              
....................             oyun_basladi=FALSE; 
598E:  BCF    38.3
....................             bis_sec_sure_bitti=FALSE; 
5990:  BCF    38.4
....................             bis_sec_sure_baslat=TRUE; 
5992:  BSF    38.5
....................              
....................             toplam_jeton_sayisi++; 
5994:  MOVLW  01
5996:  ADDWF  41,F
5998:  BTFSC  FD8.0
599A:  INCF   42,F
599C:  BTFSC  FD8.2
599E:  INCF   43,F
59A0:  BTFSC  FD8.2
59A2:  INCF   44,F
....................             write_eeprom(EE_ADR_TOP_JTN_SYS,make8(toplam_jeton_sayisi,0));//LSB 
59A4:  MOVFF  41,AF
59A8:  MOVF   FF2,W
59AA:  MOVWF  00
59AC:  BCF    FF2.6
59AE:  BCF    FF2.7
59B0:  CLRF   FA9
59B2:  MOVFF  AF,FA8
59B6:  BCF    FA6.6
59B8:  BCF    FA6.7
59BA:  BSF    FA6.2
59BC:  MOVLB  F
59BE:  MOVLW  55
59C0:  MOVWF  FA7
59C2:  MOVLW  AA
59C4:  MOVWF  FA7
59C6:  BSF    FA6.1
59C8:  BTFSC  FA6.1
59CA:  BRA    59C8
59CC:  BCF    FA6.2
59CE:  MOVF   00,W
59D0:  IORWF  FF2,F
....................             write_eeprom(EE_ADR_TOP_JTN_SYS+1,make8(toplam_jeton_sayisi,1)); 
59D2:  MOVFF  42,AF
59D6:  MOVFF  FF2,00
59DA:  BCF    FF2.6
59DC:  BCF    FF2.7
59DE:  MOVLW  01
59E0:  MOVWF  FA9
59E2:  MOVFF  42,FA8
59E6:  BCF    FA6.6
59E8:  BCF    FA6.7
59EA:  BSF    FA6.2
59EC:  MOVLW  55
59EE:  MOVWF  FA7
59F0:  MOVLW  AA
59F2:  MOVWF  FA7
59F4:  BSF    FA6.1
59F6:  BTFSC  FA6.1
59F8:  BRA    59F6
59FA:  BCF    FA6.2
59FC:  MOVF   00,W
59FE:  IORWF  FF2,F
....................             write_eeprom(EE_ADR_TOP_JTN_SYS+2,make8(toplam_jeton_sayisi,2)); 
5A00:  MOVFF  43,AF
5A04:  MOVFF  FF2,00
5A08:  BCF    FF2.6
5A0A:  BCF    FF2.7
5A0C:  MOVLW  02
5A0E:  MOVWF  FA9
5A10:  MOVFF  43,FA8
5A14:  BCF    FA6.6
5A16:  BCF    FA6.7
5A18:  BSF    FA6.2
5A1A:  MOVLW  55
5A1C:  MOVWF  FA7
5A1E:  MOVLW  AA
5A20:  MOVWF  FA7
5A22:  BSF    FA6.1
5A24:  BTFSC  FA6.1
5A26:  BRA    5A24
5A28:  BCF    FA6.2
5A2A:  MOVF   00,W
5A2C:  IORWF  FF2,F
....................             write_eeprom(EE_ADR_TOP_JTN_SYS+3,make8(toplam_jeton_sayisi,3));//MSB 
5A2E:  MOVFF  44,AF
5A32:  MOVFF  FF2,00
5A36:  BCF    FF2.6
5A38:  BCF    FF2.7
5A3A:  MOVLW  03
5A3C:  MOVWF  FA9
5A3E:  MOVFF  44,FA8
5A42:  BCF    FA6.6
5A44:  BCF    FA6.7
5A46:  BSF    FA6.2
5A48:  MOVLW  55
5A4A:  MOVWF  FA7
5A4C:  MOVLW  AA
5A4E:  MOVWF  FA7
5A50:  BSF    FA6.1
5A52:  BTFSC  FA6.1
5A54:  BRA    5A52
5A56:  BCF    FA6.2
5A58:  MOVF   00,W
5A5A:  IORWF  FF2,F
....................              
....................             printf(lcd_putc,"\fTOPLAM JETON :"); 
5A5C:  MOVLW  7A
5A5E:  MOVWF  FF6
5A60:  MOVLW  06
5A62:  MOVWF  FF7
5A64:  MOVLB  0
5A66:  CALL   0A06
....................             printf(lcd_putc,"\n%Lu", toplam_jeton_sayisi); 
5A6A:  MOVLW  0A
5A6C:  MOVLB  1
5A6E:  MOVWF  x0E
5A70:  MOVLB  0
5A72:  CALL   0996
5A76:  MOVLW  41
5A78:  MOVWF  FE9
5A7A:  MOVFF  44,105
5A7E:  MOVFF  43,104
5A82:  MOVFF  42,103
5A86:  MOVFF  41,102
5A8A:  CALL   0ABA
....................              
....................             time_bis_sec=millis(); 
5A8E:  MOVFF  2D,8E
5A92:  MOVFF  2C,8D
5A96:  MOVFF  2B,8C
5A9A:  MOVFF  2A,8B
....................  
....................        }//jetonAtildi 
....................        if(jetonSay>0){ 
5A9E:  MOVF   36,F
5AA0:  BZ    5AA6
....................            oyun_giris_islemler(); 
5AA2:  GOTO   36EC
....................        } 
....................         
.................... //       if(btn_getir()==BUTON_ONAY){ 
.................... //           // delay_ms(BUTON_GECIKME); 
.................... //             lcd_menu_sec(0); 
.................... //        } 
....................        if(uzunBasBtnGetir(BUTON_ONAY_PIN,3000)==BUTON_ONAY){ 
5AA6:  MOVLW  7C
5AA8:  MOVWF  xB0
5AAA:  MOVLW  05
5AAC:  MOVWF  xAF
5AAE:  MOVLW  0B
5AB0:  MOVWF  xB2
5AB2:  MOVLW  B8
5AB4:  MOVWF  xB1
5AB6:  GOTO   3BEE
5ABA:  MOVF   01,W
5ABC:  SUBLW  6F
5ABE:  BNZ   5AC2
....................            lcd_menu_islem(); 
5AC0:  BRA    5454
....................        } 
5AC2:  BRA    58F0
....................          
....................         
....................    }//while(TRUE) 
....................     
.................... }//main 
....................   
5AC4:  SLEEP 
....................  int mp3_sarki=19; 
....................  int mp3_sarki_list[7]; 
....................  int mp3_index=0; 
....................   
....................  BOOLEAN mp3_list_kontrol(){ 
*
14EE:  CLRF   xAF
....................     int x=0;  
....................     for(x=0;x<7;x++){ 
14F0:  CLRF   xAF
14F2:  MOVF   xAF,W
14F4:  SUBLW  06
14F6:  BNC   1516
....................         if( mp3_sarki==mp3_sarki_list[x]){ 
14F8:  CLRF   03
14FA:  MOVF   xAF,W
14FC:  ADDLW  A5
14FE:  MOVWF  FE9
1500:  MOVLW  00
1502:  ADDWFC 03,W
1504:  MOVWF  FEA
1506:  MOVF   FEF,W
1508:  SUBWF  xA4,W
150A:  BNZ   1512
....................             return FALSE; 
150C:  MOVLW  00
150E:  MOVWF  01
1510:  BRA    151A
....................         }  
1512:  INCF   xAF,F
1514:  BRA    14F2
....................     } 
....................     return TRUE; 
1516:  MOVLW  01
1518:  MOVWF  01
151A:  GOTO   16B2 (RETURN)
....................  } 
....................   
....................  void mp3_rastgele(){ 
....................  
....................     mp3_stop(); 
*
1674:  RCALL  1302
1676:  CLRF   16
1678:  BTFSC  FF2.6
167A:  BSF    16.6
167C:  BCF    FF2.6
167E:  BTFSC  FF2.7
1680:  BSF    16.7
1682:  BCF    FF2.7
....................     delay_ms(100); 
1684:  MOVLW  64
1686:  MOVLB  1
1688:  MOVWF  x27
168A:  MOVLB  0
168C:  CALL   0748
1690:  BTFSC  16.6
1692:  BSF    FF2.6
1694:  BTFSC  16.7
1696:  BSF    FF2.7
....................      
....................      if(mp3_index>6){ 
1698:  MOVF   xAC,W
169A:  SUBLW  06
169C:  BC    16B0
....................         mp3_index=0; 
169E:  CLRF   xAC
....................         memset(mp3_sarki_list,0,sizeof(mp3_sarki_list)); 
16A0:  CLRF   FEA
16A2:  MOVLW  A5
16A4:  MOVWF  FE9
16A6:  CLRF   00
16A8:  CLRF   02
16AA:  MOVLW  07
16AC:  MOVWF  01
16AE:  BRA    14D2
....................     } 
....................     while(!mp3_list_kontrol()){ 
16B0:  BRA    14EE
16B2:  MOVF   01,F
16B4:  BNZ   16DC
....................          mp3_sarki=20+rand()%7; 
16B6:  RCALL  15BE
16B8:  MOVFF  02,B0
16BC:  MOVFF  01,AF
16C0:  MOVFF  02,10F
16C4:  MOVFF  01,10E
16C8:  MOVLB  1
16CA:  CLRF   x11
16CC:  MOVLW  07
16CE:  MOVWF  x10
16D0:  MOVLB  0
16D2:  RCALL  1578
16D4:  MOVF   00,W
16D6:  ADDLW  14
16D8:  MOVWF  xA4
16DA:  BRA    16B0
....................     } 
....................     mp3_sarki_list[mp3_index]=mp3_sarki; 
16DC:  CLRF   03
16DE:  MOVF   xAC,W
16E0:  ADDLW  A5
16E2:  MOVWF  FE9
16E4:  MOVLW  00
16E6:  ADDWFC 03,W
16E8:  MOVWF  FEA
16EA:  MOVFF  A4,FEF
....................     mp3_index++; 
16EE:  INCF   xAC,F
....................  
....................     if(mp3_sarki>25)mp3_sarki=25; 
16F0:  MOVF   xA4,W
16F2:  SUBLW  19
16F4:  BC    16FA
16F6:  MOVLW  19
16F8:  MOVWF  xA4
....................     //mp3_play(mp3_getlowve_araba); 
....................     printf(lcd_putc,"\f HIZLI & PEDALLI"); 
16FA:  MOVLW  8A
16FC:  MOVWF  FF6
16FE:  MOVLW  06
1700:  MOVWF  FF7
1702:  CALL   0A06
....................     printf(lcd_putc,"\n   ::  %u  ::",mp3_sarki); 
1706:  MOVLW  9C
1708:  MOVWF  FF6
170A:  MOVLW  06
170C:  MOVWF  FF7
170E:  MOVLW  08
1710:  MOVLB  1
1712:  MOVWF  x02
1714:  MOVLB  0
1716:  RCALL  162E
1718:  MOVFF  A4,B5
171C:  MOVLW  1B
171E:  MOVWF  xB6
1720:  CALL   0C9A
1724:  MOVLW  A6
1726:  MOVWF  FF6
1728:  MOVLW  06
172A:  MOVWF  FF7
172C:  MOVLW  04
172E:  MOVLB  1
1730:  MOVWF  x02
1732:  MOVLB  0
1734:  RCALL  162E
....................     mp3_play(mp3_sarki); 
1736:  CLRF   xFF
1738:  MOVFF  A4,FE
173C:  RCALL  1658
173E:  GOTO   58F8 (RETURN)
....................    // delay_ms(1000); 
....................       
....................  } 
....................   
....................   
....................   
....................  void oyun_giris_islemler(){ 
....................       
....................         if(!input(BIS_BTN1_PIN))       
*
36EC:  BTFSC  F80.2
36EE:  BRA    374C
....................         { 
....................             //printf(lcd_putc,"\fBIS_BTN1"); 
....................             delay_ms(350); 
36F0:  MOVLW  02
36F2:  MOVWF  xAF
36F4:  CLRF   16
36F6:  BTFSC  FF2.6
36F8:  BSF    16.6
36FA:  BCF    FF2.6
36FC:  BTFSC  FF2.7
36FE:  BSF    16.7
3700:  BCF    FF2.7
3702:  MOVLW  AF
3704:  MOVLB  1
3706:  MOVWF  x27
3708:  MOVLB  0
370A:  CALL   0748
370E:  BTFSC  16.6
3710:  BSF    FF2.6
3712:  BTFSC  16.7
3714:  BSF    FF2.7
3716:  DECFSZ xAF,F
3718:  BRA    36F4
....................             if(o1_mod==SISTEM) b1=1; 
371A:  MOVF   3B,W
371C:  SUBLW  35
371E:  BNZ   3722
3720:  BSF    38.1
....................    
....................             if(o1_mod==OYUNCU1){ 
3722:  MOVF   3B,W
3724:  SUBLW  33
3726:  BNZ   374C
....................                 o1_mod_say++; 
3728:  INCF   39,F
....................                 if(o1_mod_say>=3) o1_mod_say=0; 
372A:  MOVF   39,W
372C:  SUBLW  02
372E:  BC    3732
3730:  CLRF   39
....................                // printf(lcd_putc,"\fo1Mod:%u", o1_mod_say); 
....................                // delay_ms(200); 
....................                 panel1_komut(OYUNCU_MOD_SECIMI); 
3732:  MOVLW  4D
3734:  MOVLB  1
3736:  MOVWF  x00
3738:  MOVLB  0
373A:  CALL   13BA
373E:  MOVLW  63
3740:  MOVLB  1
3742:  MOVWF  x00
3744:  MOVLB  0
3746:  CALL   13BA
....................                  
....................                 zmn_say1=0; 
374A:  CLRF   x99
....................             } 
....................  
....................         } 
....................         
....................         if(!input(BIS_BTN2_PIN))       
374C:  BTFSC  F80.3
374E:  BRA    37AC
....................         { 
....................             //printf(lcd_putc,"\fBIS_BTN2"); 
....................             delay_ms(350); 
3750:  MOVLW  02
3752:  MOVWF  xAF
3754:  CLRF   16
3756:  BTFSC  FF2.6
3758:  BSF    16.6
375A:  BCF    FF2.6
375C:  BTFSC  FF2.7
375E:  BSF    16.7
3760:  BCF    FF2.7
3762:  MOVLW  AF
3764:  MOVLB  1
3766:  MOVWF  x27
3768:  MOVLB  0
376A:  CALL   0748
376E:  BTFSC  16.6
3770:  BSF    FF2.6
3772:  BTFSC  16.7
3774:  BSF    FF2.7
3776:  DECFSZ xAF,F
3778:  BRA    3754
....................             if(o2_mod==SISTEM) b2=1; 
377A:  MOVF   3C,W
377C:  SUBLW  35
377E:  BNZ   3782
3780:  BSF    38.2
....................  
....................             if(o2_mod==OYUNCU2){ 
3782:  MOVF   3C,W
3784:  SUBLW  34
3786:  BNZ   37AC
....................                 o2_mod_say++; 
3788:  INCF   3A,F
....................                 if(o2_mod_say>=3) o2_mod_say=0; 
378A:  MOVF   3A,W
378C:  SUBLW  02
378E:  BC    3792
3790:  CLRF   3A
....................                 //printf(lcd_putc,"\fo2Mod:%u", o2_mod_say); 
....................                  panel2_komut(OYUNCU_MOD_SECIMI); 
3792:  MOVLW  4D
3794:  MOVLB  1
3796:  MOVWF  x00
3798:  MOVLB  0
379A:  CALL   143C
379E:  MOVLW  63
37A0:  MOVLB  1
37A2:  MOVWF  x00
37A4:  MOVLB  0
37A6:  CALL   143C
....................                
....................                zmn_say2=0; 
37AA:  CLRF   x9A
....................             } 
....................         } 
....................         if(jetonSay==1){ 
37AC:  DECFSZ 36,W
37AE:  BRA    38AC
....................              
....................             if(b1==1 && b2==0 && o1_mod!=OYUNCU1){ 
37B0:  BTFSS  38.1
37B2:  BRA    37C8
37B4:  BTFSC  38.2
37B6:  BRA    37C8
37B8:  MOVF   3B,W
37BA:  SUBLW  33
37BC:  BZ    37C8
....................                 o1_mod=OYUNCU1; 
37BE:  MOVLW  33
37C0:  MOVWF  3B
....................                 o2_mod=SISTEM; 
37C2:  MOVLW  35
37C4:  MOVWF  3C
....................                 //printf(lcd_putc,"\f0_1"); 
....................                  
....................                 //delay_ms(500); 
....................                 b2=0;  
37C6:  BCF    38.2
....................             } 
....................             if(b1==0 && b2==1 && o2_mod!=OYUNCU2){ 
37C8:  BTFSC  38.1
37CA:  BRA    37E0
37CC:  BTFSS  38.2
37CE:  BRA    37E0
37D0:  MOVF   3C,W
37D2:  SUBLW  34
37D4:  BZ    37E0
....................                 o1_mod=SISTEM; 
37D6:  MOVLW  35
37D8:  MOVWF  3B
....................                 o2_mod=OYUNCU2; 
37DA:  MOVLW  34
37DC:  MOVWF  3C
....................                 //printf(lcd_putc,"\f0_2"); 
....................                // delay_ms(500); 
....................                 b1=0; 
37DE:  BCF    38.1
....................                  
....................             } 
....................             if(o1_mod==OYUNCU1 && o2_mod==SISTEM && o1_mod_say==MOD_SECILMEDI){ 
37E0:  MOVF   3B,W
37E2:  SUBLW  33
37E4:  BNZ   3846
37E6:  MOVF   3C,W
37E8:  SUBLW  35
37EA:  BNZ   3846
37EC:  MOVF   39,W
37EE:  SUBLW  FF
37F0:  BNZ   3846
.................... //                printf(lcd_putc,"\f0_1 Mod Sec"); 
.................... //                printf(lcd_putc,"\n0_2 JETON AT"); 
....................                 //delay_ms(200); 
....................                 panel1_komut(OYUNCU_BISIKLET_SECIMI); 
37F2:  MOVLW  42
37F4:  MOVLB  1
37F6:  MOVWF  x00
37F8:  MOVLB  0
37FA:  CALL   13BA
37FE:  MOVLW  63
3800:  MOVLB  1
3802:  MOVWF  x00
3804:  MOVLB  0
3806:  CALL   13BA
380A:  CLRF   16
380C:  BTFSC  FF2.6
380E:  BSF    16.6
3810:  BCF    FF2.6
3812:  BTFSC  FF2.7
3814:  BSF    16.7
3816:  BCF    FF2.7
....................                 delay_ms(100); 
3818:  MOVLW  64
381A:  MOVLB  1
381C:  MOVWF  x27
381E:  MOVLB  0
3820:  CALL   0748
3824:  BTFSC  16.6
3826:  BSF    FF2.6
3828:  BTFSC  16.7
382A:  BSF    FF2.7
....................                 panel2_komut(JETON_AT); 
382C:  MOVLW  41
382E:  MOVLB  1
3830:  MOVWF  x00
3832:  MOVLB  0
3834:  CALL   143C
3838:  MOVLW  63
383A:  MOVLB  1
383C:  MOVWF  x00
383E:  MOVLB  0
3840:  CALL   143C
....................                 o1_mod_say=0; 
3844:  CLRF   39
....................             } 
....................             if(o2_mod==OYUNCU2 && o1_mod==SISTEM && o2_mod_say==MOD_SECILMEDI){ 
3846:  MOVF   3C,W
3848:  SUBLW  34
384A:  BNZ   38AC
384C:  MOVF   3B,W
384E:  SUBLW  35
3850:  BNZ   38AC
3852:  MOVF   3A,W
3854:  SUBLW  FF
3856:  BNZ   38AC
.................... //                printf(lcd_putc,"\f0_2 Mod Sec"); 
.................... //                printf(lcd_putc,"\n0_1 JETON AT"); 
....................                // delay_ms(200); 
....................                 panel2_komut(OYUNCU_BISIKLET_SECIMI); 
3858:  MOVLW  42
385A:  MOVLB  1
385C:  MOVWF  x00
385E:  MOVLB  0
3860:  CALL   143C
3864:  MOVLW  63
3866:  MOVLB  1
3868:  MOVWF  x00
386A:  MOVLB  0
386C:  CALL   143C
3870:  CLRF   16
3872:  BTFSC  FF2.6
3874:  BSF    16.6
3876:  BCF    FF2.6
3878:  BTFSC  FF2.7
387A:  BSF    16.7
387C:  BCF    FF2.7
....................                 delay_ms(100); 
387E:  MOVLW  64
3880:  MOVLB  1
3882:  MOVWF  x27
3884:  MOVLB  0
3886:  CALL   0748
388A:  BTFSC  16.6
388C:  BSF    FF2.6
388E:  BTFSC  16.7
3890:  BSF    FF2.7
....................                 panel1_komut(JETON_AT); 
3892:  MOVLW  41
3894:  MOVLB  1
3896:  MOVWF  x00
3898:  MOVLB  0
389A:  CALL   13BA
389E:  MOVLW  63
38A0:  MOVLB  1
38A2:  MOVWF  x00
38A4:  MOVLB  0
38A6:  CALL   13BA
....................                 o2_mod_say=0; 
38AA:  CLRF   3A
....................             } 
....................         } 
....................         if(jetonSay>=2){ 
38AC:  MOVF   36,W
38AE:  SUBLW  01
38B0:  BC    3912
....................              
....................             jetonSay=2; 
38B2:  MOVLW  02
38B4:  MOVWF  36
....................              
....................             if(b1==0&& b2==0){b1=1;b2=1;} 
38B6:  BTFSC  38.1
38B8:  BRA    38C2
38BA:  BTFSC  38.2
38BC:  BRA    38C2
38BE:  BSF    38.1
38C0:  BSF    38.2
....................              
....................             if(b1==1 && b2==1){ 
38C2:  BTFSS  38.1
38C4:  BRA    3912
38C6:  BTFSS  38.2
38C8:  BRA    3912
....................                  
....................                 if(o2_mod==SISTEM){ 
38CA:  MOVF   3C,W
38CC:  SUBLW  35
38CE:  BNZ   38EC
....................                     o2_mod=OYUNCU2; 
38D0:  MOVLW  34
38D2:  MOVWF  3C
....................                     panel2_komut(OYUNCU_BISIKLET_SECIMI); 
38D4:  MOVLW  42
38D6:  MOVLB  1
38D8:  MOVWF  x00
38DA:  MOVLB  0
38DC:  CALL   143C
38E0:  MOVLW  63
38E2:  MOVLB  1
38E4:  MOVWF  x00
38E6:  MOVLB  0
38E8:  CALL   143C
....................                 } 
....................                 if(o1_mod==SISTEM){ 
38EC:  MOVF   3B,W
38EE:  SUBLW  35
38F0:  BNZ   390E
....................                     o1_mod=OYUNCU1; 
38F2:  MOVLW  33
38F4:  MOVWF  3B
....................                     panel1_komut(OYUNCU_BISIKLET_SECIMI); 
38F6:  MOVLW  42
38F8:  MOVLB  1
38FA:  MOVWF  x00
38FC:  MOVLB  0
38FE:  CALL   13BA
3902:  MOVLW  63
3904:  MOVLB  1
3906:  MOVWF  x00
3908:  MOVLB  0
390A:  CALL   13BA
....................                 } 
....................                 b1=b2=0; 
390E:  BCF    38.2
3910:  BCF    38.1
....................                  
....................             } 
....................         } 
....................         
....................        if((millis()-time_mod_sec>1000) && !oyun_basladi){ 
3912:  MOVF   x87,W
3914:  SUBWF  2A,W
3916:  MOVWF  xAF
3918:  MOVF   x88,W
391A:  SUBWFB 2B,W
391C:  MOVWF  xB0
391E:  MOVF   x89,W
3920:  SUBWFB 2C,W
3922:  MOVWF  xB1
3924:  MOVF   x8A,W
3926:  SUBWFB 2D,W
3928:  MOVWF  xB2
392A:  MOVF   xB2,F
392C:  BNZ   3942
392E:  MOVF   xB1,F
3930:  BNZ   3942
3932:  MOVF   xB0,W
3934:  SUBLW  02
3936:  BC    39EE
3938:  XORLW  FF
393A:  BNZ   3942
393C:  MOVF   xAF,W
393E:  SUBLW  E8
3940:  BC    39EE
3942:  BTFSC  38.3
3944:  BRA    39EE
....................             
....................            if(o1_mod==OYUNCU1){ 
3946:  MOVF   3B,W
3948:  SUBLW  33
394A:  BNZ   3992
....................                zmn_say1++; 
394C:  INCF   x99,F
....................                if(zmn_say1>=5) { 
394E:  MOVF   x99,W
3950:  SUBLW  04
3952:  BC    396E
....................                 panel1_komut(OYUNCU_MOD_SECIM_SONU);   
3954:  MOVLW  6D
3956:  MOVLB  1
3958:  MOVWF  x00
395A:  MOVLB  0
395C:  CALL   13BA
3960:  MOVLW  63
3962:  MOVLB  1
3964:  MOVWF  x00
3966:  MOVLB  0
3968:  CALL   13BA
....................                 } else{ 
396C:  BRA    3992
....................                   fprintf(Panel1Serial,"Z%uc",zmn_say1);   
396E:  MOVLW  5A
3970:  MOVLB  1
3972:  MOVWF  x00
3974:  MOVLB  0
3976:  CALL   13BA
397A:  MOVFF  99,AF
397E:  MOVLW  1B
3980:  MOVWF  xB0
3982:  GOTO   1742
3986:  MOVLW  63
3988:  MOVLB  1
398A:  MOVWF  x00
398C:  MOVLB  0
398E:  CALL   13BA
....................                 } 
....................     
....................            } 
....................            if(o2_mod==OYUNCU2){ 
3992:  MOVF   3C,W
3994:  SUBLW  34
3996:  BNZ   39DE
....................                zmn_say2++; 
3998:  INCF   x9A,F
....................  
....................                if(zmn_say2>=5) { 
399A:  MOVF   x9A,W
399C:  SUBLW  04
399E:  BC    39BA
....................                     panel2_komut(OYUNCU_MOD_SECIM_SONU);   
39A0:  MOVLW  6D
39A2:  MOVLB  1
39A4:  MOVWF  x00
39A6:  MOVLB  0
39A8:  CALL   143C
39AC:  MOVLW  63
39AE:  MOVLB  1
39B0:  MOVWF  x00
39B2:  MOVLB  0
39B4:  CALL   143C
....................                }else{ 
39B8:  BRA    39DE
....................                    fprintf(Panel2Serial,"Z%uc",zmn_say2); 
39BA:  MOVLW  5A
39BC:  MOVLB  1
39BE:  MOVWF  x00
39C0:  MOVLB  0
39C2:  CALL   143C
39C6:  MOVFF  9A,AF
39CA:  MOVLW  1B
39CC:  MOVWF  xB0
39CE:  GOTO   17B6
39D2:  MOVLW  63
39D4:  MOVLB  1
39D6:  MOVWF  x00
39D8:  MOVLB  0
39DA:  CALL   143C
....................                } 
....................    
....................            } 
....................            time_mod_sec=millis(); 
39DE:  MOVFF  2D,8A
39E2:  MOVFF  2C,89
39E6:  MOVFF  2B,88
39EA:  MOVFF  2A,87
....................        } 
....................         
....................        if(bis_sec_sure_bitti){ 
39EE:  BTFSS  38.4
39F0:  BRA    3B2E
....................  
....................             if(o1_mod==SISTEM && o2_mod==OYUNCU2){ 
39F2:  MOVF   3B,W
39F4:  SUBLW  35
39F6:  BNZ   3A16
39F8:  MOVF   3C,W
39FA:  SUBLW  34
39FC:  BNZ   3A16
....................                 panel1_komut(SISTEM);  
39FE:  MOVLW  35
3A00:  MOVLB  1
3A02:  MOVWF  x00
3A04:  MOVLB  0
3A06:  CALL   13BA
3A0A:  MOVLW  63
3A0C:  MOVLB  1
3A0E:  MOVWF  x00
3A10:  MOVLB  0
3A12:  CALL   13BA
....................             } 
....................             if(o2_mod==SISTEM && o1_mod==OYUNCU1){ 
3A16:  MOVF   3C,W
3A18:  SUBLW  35
3A1A:  BNZ   3A3A
3A1C:  MOVF   3B,W
3A1E:  SUBLW  33
3A20:  BNZ   3A3A
....................                 panel2_komut(SISTEM);  
3A22:  MOVLW  35
3A24:  MOVLB  1
3A26:  MOVWF  x00
3A28:  MOVLB  0
3A2A:  CALL   143C
3A2E:  MOVLW  63
3A30:  MOVLB  1
3A32:  MOVWF  x00
3A34:  MOVLB  0
3A36:  CALL   143C
....................             } 
....................              
....................             if(o1_mod==SISTEM && o2_mod==SISTEM && jetonSay==1){ 
3A3A:  MOVF   3B,W
3A3C:  SUBLW  35
3A3E:  BNZ   3A8C
3A40:  MOVF   3C,W
3A42:  SUBLW  35
3A44:  BNZ   3A8C
3A46:  DECFSZ 36,W
3A48:  BRA    3A8C
....................                 o1_mod=OYUNCU1; 
3A4A:  MOVLW  33
3A4C:  MOVWF  3B
....................                 o2_mod==SISTEM; 
3A4E:  MOVF   3C,W
3A50:  SUBLW  35
3A52:  BZ    3A56
3A54:  MOVLW  00
....................                 panel1_komut(OYUNCU1_SISTEM);   
3A56:  MOVLW  58
3A58:  MOVLB  1
3A5A:  MOVWF  x00
3A5C:  MOVLB  0
3A5E:  CALL   13BA
3A62:  MOVLW  63
3A64:  MOVLB  1
3A66:  MOVWF  x00
3A68:  MOVLB  0
3A6A:  CALL   13BA
....................                 panel2_komut(SISTEM);  
3A6E:  MOVLW  35
3A70:  MOVLB  1
3A72:  MOVWF  x00
3A74:  MOVLB  0
3A76:  CALL   143C
3A7A:  MOVLW  63
3A7C:  MOVLB  1
3A7E:  MOVWF  x00
3A80:  MOVLB  0
3A82:  CALL   143C
....................                 bis_sec_sure_baslat=FALSE; 
3A86:  BCF    38.5
....................                 bis_sec_sure_bitti=FALSE; 
3A88:  BCF    38.4
....................                 oyun_basladi=TRUE; 
3A8A:  BSF    38.3
....................                // break; 
....................             } 
....................              
....................             if(o1_mod==SISTEM && o2_mod==SISTEM && jetonSay==2){ 
3A8C:  MOVF   3B,W
3A8E:  SUBLW  35
3A90:  BNZ   3AE0
3A92:  MOVF   3C,W
3A94:  SUBLW  35
3A96:  BNZ   3AE0
3A98:  MOVF   36,W
3A9A:  SUBLW  02
3A9C:  BNZ   3AE0
....................                 o1_mod=OYUNCU1; 
3A9E:  MOVLW  33
3AA0:  MOVWF  3B
....................                 o2_mod==OYUNCU2; 
3AA2:  MOVF   3C,W
3AA4:  SUBLW  34
3AA6:  BZ    3AAA
3AA8:  MOVLW  00
....................                  
....................                 panel1_komut(OYUNCU_MOD_SECIM_SONU);    
3AAA:  MOVLW  6D
3AAC:  MOVLB  1
3AAE:  MOVWF  x00
3AB0:  MOVLB  0
3AB2:  CALL   13BA
3AB6:  MOVLW  63
3AB8:  MOVLB  1
3ABA:  MOVWF  x00
3ABC:  MOVLB  0
3ABE:  CALL   13BA
....................                 panel2_komut(OYUNCU_MOD_SECIM_SONU);  
3AC2:  MOVLW  6D
3AC4:  MOVLB  1
3AC6:  MOVWF  x00
3AC8:  MOVLB  0
3ACA:  CALL   143C
3ACE:  MOVLW  63
3AD0:  MOVLB  1
3AD2:  MOVWF  x00
3AD4:  MOVLB  0
3AD6:  CALL   143C
....................                  
....................                 bis_sec_sure_baslat=FALSE; 
3ADA:  BCF    38.5
....................                 bis_sec_sure_bitti=FALSE; 
3ADC:  BCF    38.4
....................                 oyun_basladi=TRUE; 
3ADE:  BSF    38.3
....................                // break; 
....................             } 
....................  
....................             if(zmn_say1>=5) { 
3AE0:  MOVF   x99,W
3AE2:  SUBLW  04
3AE4:  BC    3AFE
....................                 panel1_komut(OYUNCU_MOD_SECIM_SONU);   
3AE6:  MOVLW  6D
3AE8:  MOVLB  1
3AEA:  MOVWF  x00
3AEC:  MOVLB  0
3AEE:  CALL   13BA
3AF2:  MOVLW  63
3AF4:  MOVLB  1
3AF6:  MOVWF  x00
3AF8:  MOVLB  0
3AFA:  CALL   13BA
....................             }  
....................  
....................             if(zmn_say2>=5) { 
3AFE:  MOVF   x9A,W
3B00:  SUBLW  04
3B02:  BC    3B1C
....................                 panel2_komut(OYUNCU_MOD_SECIM_SONU);   
3B04:  MOVLW  6D
3B06:  MOVLB  1
3B08:  MOVWF  x00
3B0A:  MOVLB  0
3B0C:  CALL   143C
3B10:  MOVLW  63
3B12:  MOVLB  1
3B14:  MOVWF  x00
3B16:  MOVLB  0
3B18:  CALL   143C
....................             } 
....................              
....................             if(o1_mod==OYUNCU1 || o2_mod==OYUNCU2){ 
3B1C:  MOVF   3B,W
3B1E:  SUBLW  33
3B20:  BZ    3B28
3B22:  MOVF   3C,W
3B24:  SUBLW  34
3B26:  BNZ   3B2A
....................                 oyun_basladi=TRUE;  
3B28:  BSF    38.3
....................             } 
....................              
....................             bis_sec_sure_baslat=FALSE; 
3B2A:  BCF    38.5
....................             bis_sec_sure_bitti=FALSE; 
3B2C:  BCF    38.4
....................             //break; 
....................        }//if(bis_sec_sure_bitti) 
....................         
....................        if( ((millis()-time_bis_sec>bisiklet_secme_suresi) && bis_sec_sure_baslat))// &&(zmn_say1>=5 || zmn_say2>=5))// && !oyun_basladi && (b1==1 || b2==1)) 
3B2E:  MOVF   x8B,W
3B30:  SUBWF  2A,W
3B32:  MOVWF  xAF
3B34:  MOVF   x8C,W
3B36:  SUBWFB 2B,W
3B38:  MOVWF  xB0
3B3A:  MOVF   x8D,W
3B3C:  SUBWFB 2C,W
3B3E:  MOVWF  xB1
3B40:  MOVF   x8E,W
3B42:  SUBWFB 2D,W
3B44:  MOVWF  xB2
3B46:  MOVF   xB2,F
3B48:  BNZ   3B5C
3B4A:  MOVF   xB1,F
3B4C:  BNZ   3B5C
3B4E:  MOVF   x98,W
3B50:  SUBWF  xB0,W
3B52:  BNC   3B62
3B54:  BNZ   3B5C
3B56:  MOVF   xAF,W
3B58:  SUBWF  x97,W
3B5A:  BC    3B62
3B5C:  BTFSS  38.5
3B5E:  BRA    3B62
....................        {   
....................            bis_sec_sure_bitti=TRUE; 
3B60:  BSF    38.4
....................        } 
....................         
....................        if(oyun_basladi){ 
3B62:  BTFSS  38.3
3B64:  BRA    3BBC
3B66:  CLRF   16
3B68:  BTFSC  FF2.6
3B6A:  BSF    16.6
3B6C:  BCF    FF2.6
3B6E:  BTFSC  FF2.7
3B70:  BSF    16.7
3B72:  BCF    FF2.7
....................            delay_ms(200); 
3B74:  MOVLW  C8
3B76:  MOVLB  1
3B78:  MOVWF  x27
3B7A:  MOVLB  0
3B7C:  CALL   0748
3B80:  BTFSC  16.6
3B82:  BSF    FF2.6
3B84:  BTFSC  16.7
3B86:  BSF    FF2.7
....................            panel1_komut(OYUNCU_MOD_SECIM_SONU);   
3B88:  MOVLW  6D
3B8A:  MOVLB  1
3B8C:  MOVWF  x00
3B8E:  MOVLB  0
3B90:  CALL   13BA
3B94:  MOVLW  63
3B96:  MOVLB  1
3B98:  MOVWF  x00
3B9A:  MOVLB  0
3B9C:  CALL   13BA
....................            panel2_komut(OYUNCU_MOD_SECIM_SONU);   
3BA0:  MOVLW  6D
3BA2:  MOVLB  1
3BA4:  MOVWF  x00
3BA6:  MOVLB  0
3BA8:  CALL   143C
3BAC:  MOVLW  63
3BAE:  MOVLB  1
3BB0:  MOVWF  x00
3BB2:  MOVLB  0
3BB4:  CALL   143C
....................            oyun_islemler(); 
3BB8:  GOTO   2678
....................        } 
3BBC:  GOTO   5AA6 (RETURN)
....................       
....................  } 
....................   
....................  void oyun_islemler(){ 
....................     fprintf(Panel1Serial,"01010101c");  //Kablodaki gurultu vb verileri atmak için preamp benzeri bilgi..... 
*
2678:  MOVLW  AC
267A:  MOVWF  FF6
267C:  MOVLW  06
267E:  MOVWF  FF7
2680:  CALL   141C
....................     fprintf(Panel2Serial,"01010101c");  //Kablodaki gurultu vb verileri atmak için  
2684:  MOVLW  B6
2686:  MOVWF  FF6
2688:  MOVLW  06
268A:  MOVWF  FF7
268C:  CALL   149E
....................      
....................     printf(lcd_putc,"\fOYUN ->");  
2690:  MOVLW  C0
2692:  MOVWF  FF6
2694:  MOVLW  06
2696:  MOVWF  FF7
2698:  CALL   0A06
....................     printf(lcd_putc,"\nm1:%c,m2:%c",o1_mod,o2_mod);  
269C:  MOVLW  CA
269E:  MOVWF  FF6
26A0:  MOVLW  06
26A2:  MOVWF  FF7
26A4:  MOVLW  04
26A6:  MOVLB  1
26A8:  MOVWF  x02
26AA:  MOVLB  0
26AC:  CALL   162E
26B0:  MOVFF  3B,10E
26B4:  CALL   0996
26B8:  MOVLW  D0
26BA:  MOVWF  FF6
26BC:  MOVLW  06
26BE:  MOVWF  FF7
26C0:  MOVLW  04
26C2:  MOVLB  1
26C4:  MOVWF  x02
26C6:  MOVLB  0
26C8:  CALL   162E
26CC:  MOVFF  3C,10E
26D0:  CALL   0996
.................... 	mp3_stop(); delay_ms(100); 
26D4:  CALL   1302
26D8:  CLRF   16
26DA:  BTFSC  FF2.6
26DC:  BSF    16.6
26DE:  BCF    FF2.6
26E0:  BTFSC  FF2.7
26E2:  BSF    16.7
26E4:  BCF    FF2.7
26E6:  MOVLW  64
26E8:  MOVLB  1
26EA:  MOVWF  x27
26EC:  MOVLB  0
26EE:  CALL   0748
26F2:  BTFSC  16.6
26F4:  BSF    FF2.6
26F6:  BTFSC  16.7
26F8:  BSF    FF2.7
.................... 	mp3_play(mp3_mars); 
26FA:  CLRF   xFF
26FC:  MOVLW  11
26FE:  MOVWF  xFE
2700:  CALL   1658
....................     delay_ms(1000); 
2704:  MOVLW  04
2706:  MOVWF  xFE
2708:  CLRF   16
270A:  BTFSC  FF2.6
270C:  BSF    16.6
270E:  BCF    FF2.6
2710:  BTFSC  FF2.7
2712:  BSF    16.7
2714:  BCF    FF2.7
2716:  MOVLW  FA
2718:  MOVLB  1
271A:  MOVWF  x27
271C:  MOVLB  0
271E:  CALL   0748
2722:  BTFSC  16.6
2724:  BSF    FF2.6
2726:  BTFSC  16.7
2728:  BSF    FF2.7
272A:  DECFSZ xFE,F
272C:  BRA    2708
....................      
....................     fprintf(Panel1Serial,"01010101c");  //Kablodaki gurultu vb verileri atmak için preamp benzeri bilgi..... 
272E:  MOVLW  D8
2730:  MOVWF  FF6
2732:  MOVLW  06
2734:  MOVWF  FF7
2736:  CALL   141C
....................     fprintf(Panel2Serial,"01010101c");  //Kablodaki gurultu vb verileri atmak için  
273A:  MOVLW  E2
273C:  MOVWF  FF6
273E:  MOVLW  06
2740:  MOVWF  FF7
2742:  CALL   149E
....................     delay_ms(300); 
2746:  MOVLW  02
2748:  MOVWF  xFE
274A:  CLRF   16
274C:  BTFSC  FF2.6
274E:  BSF    16.6
2750:  BCF    FF2.6
2752:  BTFSC  FF2.7
2754:  BSF    16.7
2756:  BCF    FF2.7
2758:  MOVLW  96
275A:  MOVLB  1
275C:  MOVWF  x27
275E:  MOVLB  0
2760:  CALL   0748
2764:  BTFSC  16.6
2766:  BSF    FF2.6
2768:  BTFSC  16.7
276A:  BSF    FF2.7
276C:  DECFSZ xFE,F
276E:  BRA    274A
....................      
....................     if(o2_mod==SISTEM ){analogWrite(M2_PWM, 250);v1=5;} 
2770:  MOVF   3C,W
2772:  SUBLW  35
2774:  BNZ   2786
2776:  MOVLW  FA
2778:  MOVWF  F67
277A:  CLRF   x6E
277C:  CLRF   x6D
277E:  MOVLW  20
2780:  MOVWF  x6C
2782:  MOVLW  81
2784:  MOVWF  x6B
....................     if(o1_mod==SISTEM ){analogWrite(M1_PWM, 250);v2=5;} 
2786:  MOVF   3B,W
2788:  SUBLW  35
278A:  BNZ   279C
278C:  MOVLW  FA
278E:  MOVWF  FBE
2790:  CLRF   x72
2792:  CLRF   x71
2794:  MOVLW  20
2796:  MOVWF  x70
2798:  MOVLW  81
279A:  MOVWF  x6F
....................      
....................     enable_interrupts(INT_EXT1); 
279C:  BSF    FF0.3
....................     enable_interrupts(INT_EXT2); 
279E:  BSF    FF0.4
....................      
....................     BYTE x_fill=0; 
....................     char buf_str[50],m1_var_yok=0,m2_var_yok=0; 
....................     //BOOLEAN akim_busy, panel_update_busy,oyun_zaman_busy; 
....................     unsigned int sistem_mod_hiz_deg_say=0; 
....................     unsigned long long time_tur_olc1=millis(); 
....................     unsigned long long time_tur_olc2=millis(); 
....................     unsigned long long time_veri_gonder=millis(); 
27A0:  CLRF   xAF
27A2:  CLRF   xE2
27A4:  CLRF   xE3
27A6:  CLRF   xE4
27A8:  MOVFF  2D,E8
27AC:  MOVFF  2C,E7
27B0:  MOVFF  2B,E6
27B4:  MOVFF  2A,E5
27B8:  MOVFF  2D,EC
27BC:  MOVFF  2C,EB
27C0:  MOVFF  2B,EA
27C4:  MOVFF  2A,E9
27C8:  MOVFF  2D,F0
27CC:  MOVFF  2C,EF
27D0:  MOVFF  2B,EE
27D4:  MOVFF  2A,ED
....................     time_oyun_sure_say = millis();                  //Oyununun süresini sayar. 
27D8:  MOVFF  2D,96
27DC:  MOVFF  2C,95
27E0:  MOVFF  2B,94
27E4:  MOVFF  2A,93
....................     unsigned long long time_oynanan_sure=millis(); 
27E8:  MOVFF  2D,F4
27EC:  MOVFF  2C,F3
27F0:  MOVFF  2B,F2
27F4:  MOVFF  2A,F1
....................      
....................     do{ 
....................         if(input(DF_BUSY_PIN)){ 
27F8:  BTFSS  F82.3
27FA:  BRA    282C
....................            mp3_stop(); 
27FC:  CALL   1302
2800:  CLRF   16
2802:  BTFSC  FF2.6
2804:  BSF    16.6
2806:  BCF    FF2.6
2808:  BTFSC  FF2.7
280A:  BSF    16.7
280C:  BCF    FF2.7
....................            delay_ms(100); 
280E:  MOVLW  64
2810:  MOVLB  1
2812:  MOVWF  x27
2814:  MOVLB  0
2816:  CALL   0748
281A:  BTFSC  16.6
281C:  BSF    FF2.6
281E:  BTFSC  16.7
2820:  BSF    FF2.7
....................            mp3_play(mp3_getlowve_araba); 
2822:  CLRF   xFF
2824:  MOVLW  12
2826:  MOVWF  xFE
2828:  CALL   1658
....................        } 
....................          
....................         //if (millis() - time_oynanan_sure >(unsigned long long)(time_oyun / (unsigned long long)(64))) 
....................         if (millis() - time_oynanan_sure >time_oyun/60)// 2^6  64 bölmek(time_oyun >> 6) 
282C:  MOVF   xF1,W
282E:  SUBWF  2A,W
2830:  MOVWF  xFE
2832:  MOVF   xF2,W
2834:  SUBWFB 2B,W
2836:  MOVWF  xFF
2838:  MOVF   xF3,W
283A:  SUBWFB 2C,W
283C:  MOVLB  1
283E:  MOVWF  x00
2840:  MOVLB  0
2842:  MOVF   xF4,W
2844:  SUBWFB 2D,W
2846:  MOVLB  1
2848:  MOVWF  x01
284A:  BCF    FD8.1
284C:  MOVFF  92,111
2850:  MOVFF  91,110
2854:  MOVFF  90,10F
2858:  MOVFF  8F,10E
285C:  CLRF   x15
285E:  CLRF   x14
2860:  CLRF   x13
2862:  MOVLW  3C
2864:  MOVWF  x12
2866:  MOVLB  0
2868:  CALL   0A26
286C:  MOVF   03,W
286E:  MOVLB  1
2870:  SUBWF  x01,W
2872:  BNC   28B8
2874:  BNZ   28A2
2876:  MOVF   02,W
2878:  SUBWF  x00,W
287A:  BNC   28B8
287C:  BNZ   28A2
287E:  MOVF   01,W
2880:  MOVLB  0
2882:  SUBWF  xFF,W
2884:  BTFSC  FD8.0
2886:  BRA    288C
2888:  MOVLB  1
288A:  BRA    28B8
288C:  BTFSC  FD8.2
288E:  BRA    2894
2890:  MOVLB  1
2892:  BRA    28A2
2894:  MOVF   xFE,W
2896:  SUBWF  00,W
2898:  BTFSS  FD8.0
289A:  BRA    28A0
289C:  MOVLB  1
289E:  BRA    28B8
28A0:  MOVLB  1
....................         { 
.................... //            disable_interrupts(INT_EXT1);       //HIZ1 
.................... //            disable_interrupts(INT_EXT2); 
....................              
....................             x_fill++; 
28A2:  MOVLB  0
28A4:  INCF   xAF,F
....................              
.................... //            fprintf(Panel1Serial,"Z,%u,c",x_fill); 
.................... //            delay_ms(50); 
.................... //            fprintf(Panel2Serial,"Z,%u,c",x_fill); 
.................... //            delay_ms(50); 
....................              
.................... 			time_oynanan_sure = millis(); 
28A6:  MOVFF  2D,F4
28AA:  MOVFF  2C,F3
28AE:  MOVFF  2B,F2
28B2:  MOVFF  2A,F1
28B6:  MOVLB  1
....................              
....................             //printf(lcd_putc,"\fsure:%Lu",((millis()-time_oyun_sure_say)));  
....................              
.................... //            enable_interrupts(INT_EXT1);       //HIZ1 
.................... //            enable_interrupts(INT_EXT2); 
....................         } 
....................          
....................         if ((millis() - dtime1)>3000) //no sens found for 1500ms 
28B8:  MOVF   5F,W
28BA:  SUBWF  2A,W
28BC:  MOVLB  0
28BE:  MOVWF  xFE
28C0:  MOVF   x60,W
28C2:  SUBWFB 2B,W
28C4:  MOVWF  xFF
28C6:  MOVF   x61,W
28C8:  SUBWFB 2C,W
28CA:  MOVLB  1
28CC:  MOVWF  x00
28CE:  MOVLB  0
28D0:  MOVF   x62,W
28D2:  SUBWFB 2D,W
28D4:  MOVLB  1
28D6:  MOVWF  x01
28D8:  MOVF   x01,F
28DA:  BNZ   28FA
28DC:  MOVF   x00,F
28DE:  BNZ   28FA
28E0:  MOVLB  0
28E2:  MOVF   xFF,W
28E4:  SUBLW  0A
28E6:  BC    2930
28E8:  XORLW  FF
28EA:  BTFSC  FD8.2
28EC:  BRA    28F2
28EE:  MOVLB  1
28F0:  BRA    28FA
28F2:  MOVF   xFE,W
28F4:  SUBLW  B8
28F6:  BC    2930
28F8:  MOVLB  1
.................... 		{ 
.................... 			rpm1 = v1 = 0; // make rpm and velocity as zero 
28FA:  MOVLB  0
28FC:  CLRF   x6E
28FE:  CLRF   x6D
2900:  CLRF   x6C
2902:  CLRF   x6B
2904:  MOVFF  6E,103
2908:  MOVFF  6D,102
290C:  MOVFF  6C,101
2910:  MOVFF  6B,100
2914:  CALL   182A
2918:  MOVFF  02,50
291C:  MOVFF  01,4F
.................... 			dtime1 = millis(); 
2920:  MOVFF  2D,62
2924:  MOVFF  2C,61
2928:  MOVFF  2B,60
292C:  MOVFF  2A,5F
.................... 		} 
....................         if ((millis() - dtime2)>3000) //no sens found for 1500ms 
2930:  MOVF   x63,W
2932:  SUBWF  2A,W
2934:  MOVWF  xFE
2936:  MOVF   x64,W
2938:  SUBWFB 2B,W
293A:  MOVWF  xFF
293C:  MOVF   x65,W
293E:  SUBWFB 2C,W
2940:  MOVLB  1
2942:  MOVWF  x00
2944:  MOVLB  0
2946:  MOVF   x66,W
2948:  SUBWFB 2D,W
294A:  MOVLB  1
294C:  MOVWF  x01
294E:  MOVF   x01,F
2950:  BNZ   2970
2952:  MOVF   x00,F
2954:  BNZ   2970
2956:  MOVLB  0
2958:  MOVF   xFF,W
295A:  SUBLW  0A
295C:  BC    29A6
295E:  XORLW  FF
2960:  BTFSC  FD8.2
2962:  BRA    2968
2964:  MOVLB  1
2966:  BRA    2970
2968:  MOVF   xFE,W
296A:  SUBLW  B8
296C:  BC    29A6
296E:  MOVLB  1
.................... 		{ 
.................... 			rpm2 = v2 = 0; // make rpm and velocity as zero 
2970:  MOVLB  0
2972:  CLRF   x72
2974:  CLRF   x71
2976:  CLRF   x70
2978:  CLRF   x6F
297A:  MOVFF  72,103
297E:  MOVFF  71,102
2982:  MOVFF  70,101
2986:  MOVFF  6F,100
298A:  CALL   182A
298E:  MOVFF  02,52
2992:  MOVFF  01,51
.................... 			dtime2 = millis(); 
2996:  MOVFF  2D,66
299A:  MOVFF  2C,65
299E:  MOVFF  2B,64
29A2:  MOVFF  2A,63
.................... 		} 
....................          
....................          if(!input(PIN_B5))// && o1_mod==OYUNCU1)      //TUR1 
29A6:  BSF    F93.5
29A8:  BTFSC  F81.5
29AA:  BRA    2A10
....................         { 
....................              time_tur_olc1=millis(); 
29AC:  MOVFF  2D,E8
29B0:  MOVFF  2C,E7
29B4:  MOVFF  2B,E6
29B8:  MOVFF  2A,E5
....................              do{ 
....................                  if(millis()- time_tur_olc1>350){ 
29BC:  MOVF   xE5,W
29BE:  SUBWF  2A,W
29C0:  MOVWF  xFE
29C2:  MOVF   xE6,W
29C4:  SUBWFB 2B,W
29C6:  MOVWF  xFF
29C8:  MOVF   xE7,W
29CA:  SUBWFB 2C,W
29CC:  MOVLB  1
29CE:  MOVWF  x00
29D0:  MOVLB  0
29D2:  MOVF   xE8,W
29D4:  SUBWFB 2D,W
29D6:  MOVLB  1
29D8:  MOVWF  x01
29DA:  MOVF   x01,F
29DC:  BNZ   29FC
29DE:  MOVF   x00,F
29E0:  BNZ   29FC
29E2:  MOVLB  0
29E4:  MOVF   xFF,W
29E6:  SUBLW  00
29E8:  BC    2A00
29EA:  XORLW  FF
29EC:  BTFSC  FD8.2
29EE:  BRA    29F4
29F0:  MOVLB  1
29F2:  BRA    29FC
29F4:  MOVF   xFE,W
29F6:  SUBLW  5E
29F8:  BC    2A00
29FA:  MOVLB  1
....................                      break; 
29FC:  BRA    2A08
29FE:  MOVLB  0
....................                  } 
....................                   
....................              }while(!input(PIN_B5)); 
2A00:  BSF    F93.5
2A02:  BTFSS  F81.5
2A04:  BRA    29BC
2A06:  MOVLB  1
....................              
....................              pist_tur1++; 
2A08:  MOVLB  0
2A0A:  INCF   x79,F
2A0C:  BTFSC  FD8.2
2A0E:  INCF   x7A,F
....................         } 
....................          
....................         if(!input(PIN_B4))// && o2_mod==OYUNCU2)      //TUR2 
2A10:  BSF    F93.4
2A12:  BTFSC  F81.4
2A14:  BRA    2A7A
....................         { 
....................             time_tur_olc2=millis(); 
2A16:  MOVFF  2D,EC
2A1A:  MOVFF  2C,EB
2A1E:  MOVFF  2B,EA
2A22:  MOVFF  2A,E9
....................             do{ 
....................                  if(millis()- time_tur_olc2>350){ 
2A26:  MOVF   xE9,W
2A28:  SUBWF  2A,W
2A2A:  MOVWF  xFE
2A2C:  MOVF   xEA,W
2A2E:  SUBWFB 2B,W
2A30:  MOVWF  xFF
2A32:  MOVF   xEB,W
2A34:  SUBWFB 2C,W
2A36:  MOVLB  1
2A38:  MOVWF  x00
2A3A:  MOVLB  0
2A3C:  MOVF   xEC,W
2A3E:  SUBWFB 2D,W
2A40:  MOVLB  1
2A42:  MOVWF  x01
2A44:  MOVF   x01,F
2A46:  BNZ   2A66
2A48:  MOVF   x00,F
2A4A:  BNZ   2A66
2A4C:  MOVLB  0
2A4E:  MOVF   xFF,W
2A50:  SUBLW  00
2A52:  BC    2A6A
2A54:  XORLW  FF
2A56:  BTFSC  FD8.2
2A58:  BRA    2A5E
2A5A:  MOVLB  1
2A5C:  BRA    2A66
2A5E:  MOVF   xFE,W
2A60:  SUBLW  5E
2A62:  BC    2A6A
2A64:  MOVLB  1
....................                      break; 
2A66:  BRA    2A72
2A68:  MOVLB  0
....................                  } 
....................                   
....................              }while(!input(PIN_B4)); 
2A6A:  BSF    F93.4
2A6C:  BTFSS  F81.4
2A6E:  BRA    2A26
2A70:  MOVLB  1
....................               
....................             pist_tur2++; 
2A72:  MOVLB  0
2A74:  INCF   x7B,F
2A76:  BTFSC  FD8.2
2A78:  INCF   x7C,F
....................         } 
....................  
....................         if (rotation1 >= 1 && o1_mod==OYUNCU1) 
2A7A:  MOVF   x73,W
2A7C:  SUBLW  00
2A7E:  BC    2A8A
2A80:  MOVF   3B,W
2A82:  SUBLW  33
2A84:  BNZ   2A8A
....................         { 
....................             o1_hiz_olcum(); 
2A86:  GOTO   19B4
....................         }  
....................         if (rotation2 >= 1 && o2_mod==OYUNCU2) 
2A8A:  MOVF   x74,W
2A8C:  SUBLW  00
2A8E:  BC    2A9A
2A90:  MOVF   3C,W
2A92:  SUBLW  34
2A94:  BNZ   2A9A
....................         { 
....................             o2_hiz_olcum(); 
2A96:  GOTO   1B5E
....................         } 
....................          
....................         m1_pwm_deger = (long)(map((long)(v1), 0, BISIKLET_MAX_HIZ, 0, pwm_max_deger)+100); 
2A9A:  MOVFF  6E,103
2A9E:  MOVFF  6D,102
2AA2:  MOVFF  6C,101
2AA6:  MOVFF  6B,100
2AAA:  CALL   182A
2AAE:  MOVFF  02,FF
2AB2:  MOVFF  01,FE
2AB6:  MOVFF  02,101
2ABA:  MOVFF  01,100
2ABE:  MOVLB  1
2AC0:  CLRF   x03
2AC2:  CLRF   x02
2AC4:  CLRF   x05
2AC6:  MOVLW  47
2AC8:  MOVWF  x04
2ACA:  CLRF   x07
2ACC:  CLRF   x06
2ACE:  MOVFF  46,109
2AD2:  MOVFF  45,108
2AD6:  MOVLB  0
2AD8:  CALL   1D08
2ADC:  MOVLW  64
2ADE:  ADDWF  01,W
2AE0:  MOVWF  x9D
2AE2:  MOVLW  00
2AE4:  ADDWFC 02,W
2AE6:  MOVWF  x9E
.................... 		m2_pwm_deger = (long)(map((long)(v2), 0, BISIKLET_MAX_HIZ, 0, pwm_max_deger)+100); 
2AE8:  MOVFF  72,103
2AEC:  MOVFF  71,102
2AF0:  MOVFF  70,101
2AF4:  MOVFF  6F,100
2AF8:  CALL   182A
2AFC:  MOVFF  02,FF
2B00:  MOVFF  01,FE
2B04:  MOVFF  02,101
2B08:  MOVFF  01,100
2B0C:  MOVLB  1
2B0E:  CLRF   x03
2B10:  CLRF   x02
2B12:  CLRF   x05
2B14:  MOVLW  47
2B16:  MOVWF  x04
2B18:  CLRF   x07
2B1A:  CLRF   x06
2B1C:  MOVFF  46,109
2B20:  MOVFF  45,108
2B24:  MOVLB  0
2B26:  CALL   1D08
2B2A:  MOVLW  64
2B2C:  ADDWF  01,W
2B2E:  MOVWF  x9F
2B30:  MOVLW  00
2B32:  ADDWFC 02,W
2B34:  MOVWF  xA0
....................          
....................         if (v1 == 0) m1_pwm_deger = 0; 
2B36:  MOVFF  6E,101
2B3A:  MOVFF  6D,100
2B3E:  MOVFF  6C,FF
2B42:  MOVFF  6B,FE
2B46:  MOVLB  1
2B48:  CLRF   x05
2B4A:  CLRF   x04
2B4C:  CLRF   x03
2B4E:  CLRF   x02
2B50:  MOVLB  0
2B52:  CALL   1D84
2B56:  BNZ   2B5C
2B58:  CLRF   x9E
2B5A:  CLRF   x9D
.................... 		if (v2 == 0) m2_pwm_deger = 0; 
2B5C:  MOVFF  72,101
2B60:  MOVFF  71,100
2B64:  MOVFF  70,FF
2B68:  MOVFF  6F,FE
2B6C:  MOVLB  1
2B6E:  CLRF   x05
2B70:  CLRF   x04
2B72:  CLRF   x03
2B74:  CLRF   x02
2B76:  MOVLB  0
2B78:  CALL   1D84
2B7C:  BNZ   2B82
2B7E:  CLRF   xA0
2B80:  CLRF   x9F
....................          
....................         if(o2_mod==SISTEM){ 
2B82:  MOVF   3C,W
2B84:  SUBLW  35
2B86:  BTFSS  FD8.2
2B88:  BRA    2CB2
....................              
....................             m2_pwm_deger=450+(rand()%5)*11; 
2B8A:  CALL   15BE
2B8E:  MOVFF  02,FF
2B92:  MOVFF  01,FE
2B96:  MOVFF  02,10F
2B9A:  MOVFF  01,10E
2B9E:  MOVLB  1
2BA0:  CLRF   x11
2BA2:  MOVLW  05
2BA4:  MOVWF  x10
2BA6:  MOVLB  0
2BA8:  CALL   1578
2BAC:  MOVFF  00,FE
2BB0:  MOVFF  03,FF
2BB4:  MOVFF  03,10F
2BB8:  MOVFF  00,10E
2BBC:  MOVLB  1
2BBE:  CLRF   x11
2BC0:  MOVLW  0B
2BC2:  MOVWF  x10
2BC4:  MOVLB  0
2BC6:  CALL   1866
2BCA:  MOVF   01,W
2BCC:  ADDLW  C2
2BCE:  MOVWF  x9F
2BD0:  MOVLW  01
2BD2:  ADDWFC 02,W
2BD4:  MOVWF  xA0
....................             v2= m2_pwm_deger/10; 
2BD6:  MOVFF  A0,10F
2BDA:  MOVFF  9F,10E
2BDE:  MOVLB  1
2BE0:  CLRF   x11
2BE2:  MOVLW  0A
2BE4:  MOVWF  x10
2BE6:  MOVLB  0
2BE8:  CALL   1578
2BEC:  MOVFF  02,101
2BF0:  MOVFF  01,100
2BF4:  MOVLB  0
2BF6:  CALL   1888
2BFA:  MOVFF  03,72
2BFE:  MOVFF  02,71
2C02:  MOVFF  01,70
2C06:  MOVFF  00,6F
....................              
....................             rps2=(v2/(tekerlek_yari_cap*0.37699f))/60.0f;   //hýza göre saniyedeki devir sayýsý 
2C0A:  MOVFF  72,105
2C0E:  MOVFF  71,104
2C12:  MOVFF  70,103
2C16:  MOVFF  6F,102
2C1A:  MOVLW  8C
2C1C:  MOVLB  1
2C1E:  MOVWF  x09
2C20:  MOVLW  B7
2C22:  MOVWF  x08
2C24:  MOVLW  2D
2C26:  MOVWF  x07
2C28:  MOVLW  7C
2C2A:  MOVWF  x06
2C2C:  MOVLB  0
2C2E:  CALL   1E26
2C32:  MOVFF  03,101
2C36:  MOVFF  02,100
2C3A:  MOVFF  01,FF
2C3E:  MOVFF  00,FE
2C42:  MOVFF  03,105
2C46:  MOVFF  02,104
2C4A:  MOVFF  01,103
2C4E:  MOVFF  00,102
2C52:  MOVLB  1
2C54:  CLRF   x09
2C56:  CLRF   x08
2C58:  MOVLW  70
2C5A:  MOVWF  x07
2C5C:  MOVLW  84
2C5E:  MOVWF  x06
2C60:  MOVLB  0
2C62:  CALL   1E26
2C66:  MOVFF  03,103
2C6A:  MOVFF  02,102
2C6E:  MOVFF  01,101
2C72:  MOVFF  00,100
2C76:  CALL   182A
2C7A:  MOVFF  02,56
2C7E:  MOVFF  01,55
....................              
....................             if(sistem_mod_hiz_deg_say>3){ 
2C82:  MOVF   xE4,W
2C84:  SUBLW  03
2C86:  BC    2CB0
....................                 
....................                 sistem_mod_hiz_deg_say=0; 
2C88:  CLRF   xE4
....................                 //printf(lcd_putc,"\npwm:%lu",m2_pwm_deger);  
....................                 analogWrite(M2_PWM, m2_pwm_deger); 
2C8A:  MOVFF  A0,02
2C8E:  MOVFF  9F,01
2C92:  RRCF   02,F
2C94:  RRCF   01,F
2C96:  RRCF   02,F
2C98:  RRCF   01,F
2C9A:  RRCF   02,F
2C9C:  MOVFF  01,F67
2CA0:  RRCF   02,F
2CA2:  RRCF   02,W
2CA4:  ANDLW  30
2CA6:  MOVWF  00
2CA8:  MOVF   F66,W
2CAA:  ANDLW  CF
2CAC:  IORWF  00,W
2CAE:  MOVWF  F66
....................             } 
....................              
....................         }else{ 
2CB0:  BRA    2CD8
....................             analogWrite(M2_PWM, m2_pwm_deger); 
2CB2:  MOVFF  A0,02
2CB6:  MOVFF  9F,01
2CBA:  RRCF   02,F
2CBC:  RRCF   01,F
2CBE:  RRCF   02,F
2CC0:  RRCF   01,F
2CC2:  RRCF   02,F
2CC4:  MOVFF  01,F67
2CC8:  RRCF   02,F
2CCA:  RRCF   02,W
2CCC:  ANDLW  30
2CCE:  MOVWF  00
2CD0:  MOVF   F66,W
2CD2:  ANDLW  CF
2CD4:  IORWF  00,W
2CD6:  MOVWF  F66
....................         } 
....................          
....................         if(o1_mod==SISTEM){ 
2CD8:  MOVF   3B,W
2CDA:  SUBLW  35
2CDC:  BTFSS  FD8.2
2CDE:  BRA    2E08
....................             m1_pwm_deger=450+(rand()%5)*11; 
2CE0:  CALL   15BE
2CE4:  MOVFF  02,FF
2CE8:  MOVFF  01,FE
2CEC:  MOVFF  02,10F
2CF0:  MOVFF  01,10E
2CF4:  MOVLB  1
2CF6:  CLRF   x11
2CF8:  MOVLW  05
2CFA:  MOVWF  x10
2CFC:  MOVLB  0
2CFE:  CALL   1578
2D02:  MOVFF  00,FE
2D06:  MOVFF  03,FF
2D0A:  MOVFF  03,10F
2D0E:  MOVFF  00,10E
2D12:  MOVLB  1
2D14:  CLRF   x11
2D16:  MOVLW  0B
2D18:  MOVWF  x10
2D1A:  MOVLB  0
2D1C:  CALL   1866
2D20:  MOVF   01,W
2D22:  ADDLW  C2
2D24:  MOVWF  x9D
2D26:  MOVLW  01
2D28:  ADDWFC 02,W
2D2A:  MOVWF  x9E
....................             v1= m1_pwm_deger/10; 
2D2C:  MOVFF  9E,10F
2D30:  MOVFF  9D,10E
2D34:  MOVLB  1
2D36:  CLRF   x11
2D38:  MOVLW  0A
2D3A:  MOVWF  x10
2D3C:  MOVLB  0
2D3E:  CALL   1578
2D42:  MOVFF  02,101
2D46:  MOVFF  01,100
2D4A:  MOVLB  0
2D4C:  CALL   1888
2D50:  MOVFF  03,6E
2D54:  MOVFF  02,6D
2D58:  MOVFF  01,6C
2D5C:  MOVFF  00,6B
....................              
....................             rps1=(v1/(tekerlek_yari_cap*0.37699f))/60.0f;   //hýza göre saniyedeki devir sayýsý 
2D60:  MOVFF  6E,105
2D64:  MOVFF  6D,104
2D68:  MOVFF  6C,103
2D6C:  MOVFF  6B,102
2D70:  MOVLW  8C
2D72:  MOVLB  1
2D74:  MOVWF  x09
2D76:  MOVLW  B7
2D78:  MOVWF  x08
2D7A:  MOVLW  2D
2D7C:  MOVWF  x07
2D7E:  MOVLW  7C
2D80:  MOVWF  x06
2D82:  MOVLB  0
2D84:  CALL   1E26
2D88:  MOVFF  03,101
2D8C:  MOVFF  02,100
2D90:  MOVFF  01,FF
2D94:  MOVFF  00,FE
2D98:  MOVFF  03,105
2D9C:  MOVFF  02,104
2DA0:  MOVFF  01,103
2DA4:  MOVFF  00,102
2DA8:  MOVLB  1
2DAA:  CLRF   x09
2DAC:  CLRF   x08
2DAE:  MOVLW  70
2DB0:  MOVWF  x07
2DB2:  MOVLW  84
2DB4:  MOVWF  x06
2DB6:  MOVLB  0
2DB8:  CALL   1E26
2DBC:  MOVFF  03,103
2DC0:  MOVFF  02,102
2DC4:  MOVFF  01,101
2DC8:  MOVFF  00,100
2DCC:  CALL   182A
2DD0:  MOVFF  02,54
2DD4:  MOVFF  01,53
....................              
....................             if(sistem_mod_hiz_deg_say>3){ 
2DD8:  MOVF   xE4,W
2DDA:  SUBLW  03
2DDC:  BC    2E06
....................                 
....................                 sistem_mod_hiz_deg_say=0; 
2DDE:  CLRF   xE4
....................                // printf(lcd_putc,"\npwm:%lu",m1_pwm_deger);  
....................                 analogWrite(M1_PWM, m1_pwm_deger); 
2DE0:  MOVFF  9E,02
2DE4:  MOVFF  9D,01
2DE8:  RRCF   02,F
2DEA:  RRCF   01,F
2DEC:  RRCF   02,F
2DEE:  RRCF   01,F
2DF0:  RRCF   02,F
2DF2:  MOVFF  01,FBE
2DF6:  RRCF   02,F
2DF8:  RRCF   02,W
2DFA:  ANDLW  30
2DFC:  MOVWF  00
2DFE:  MOVF   FBD,W
2E00:  ANDLW  CF
2E02:  IORWF  00,W
2E04:  MOVWF  FBD
....................             } 
....................              
....................         }else{ 
2E06:  BRA    2E2E
....................             analogWrite(M1_PWM, m1_pwm_deger);		//analogWrite(pin, value) 
2E08:  MOVFF  9E,02
2E0C:  MOVFF  9D,01
2E10:  RRCF   02,F
2E12:  RRCF   01,F
2E14:  RRCF   02,F
2E16:  RRCF   01,F
2E18:  RRCF   02,F
2E1A:  MOVFF  01,FBE
2E1E:  RRCF   02,F
2E20:  RRCF   02,W
2E22:  ANDLW  30
2E24:  MOVWF  00
2E26:  MOVF   FBD,W
2E28:  ANDLW  CF
2E2A:  IORWF  00,W
2E2C:  MOVWF  FBD
....................         } 
....................         o1_akim_olc(); 
2E2E:  CALL   1F84
....................         o2_akim_olc(); 
2E32:  CALL   1FE2
....................          
....................         if(v1>0 && akim_adc_deger1<1){ 
2E36:  MOVLB  1
2E38:  CLRF   x01
2E3A:  CLRF   x00
2E3C:  MOVLB  0
2E3E:  CLRF   xFF
2E40:  CLRF   xFE
2E42:  MOVFF  6E,105
2E46:  MOVFF  6D,104
2E4A:  MOVFF  6C,103
2E4E:  MOVFF  6B,102
2E52:  CALL   1D84
2E56:  BNC   2E66
2E58:  MOVF   4B,F
2E5A:  BNZ   2E66
2E5C:  MOVF   4C,F
2E5E:  BNZ   2E66
....................  
.................... //             if(millis()-time_akim_olc1>1500 ){ 
.................... //                 //panel1_komut(MOTOR_YOK); 
.................... //                 printf(lcd_putc,"\fM1 yok !!!");  
.................... //                 printf(lcd_putc,"\nI1:%Lu",akim_adc_deger1);  
.................... //                  
.................... //                 time_akim_olc1=millis(); 
.................... //             }  
....................              m1_var_yok=MOTOR_YOK; 
2E60:  MOVLW  51
2E62:  MOVWF  xE2
....................              
....................         }else  m1_var_yok=MOTOR_VAR; 
2E64:  BRA    2E6A
2E66:  MOVLW  71
2E68:  MOVWF  xE2
....................          
....................         if(v2>0 && akim_adc_deger2<1){ 
2E6A:  MOVLB  1
2E6C:  CLRF   x01
2E6E:  CLRF   x00
2E70:  MOVLB  0
2E72:  CLRF   xFF
2E74:  CLRF   xFE
2E76:  MOVFF  72,105
2E7A:  MOVFF  71,104
2E7E:  MOVFF  70,103
2E82:  MOVFF  6F,102
2E86:  CALL   1D84
2E8A:  BNC   2E9A
2E8C:  MOVF   4D,F
2E8E:  BNZ   2E9A
2E90:  MOVF   4E,F
2E92:  BNZ   2E9A
....................   
.................... //              if(millis()-time_akim_olc2>1500 ){ 
.................... //                   
.................... //                   //panel2_komut(MOTOR_YOK); 
.................... //                   printf(lcd_putc,"\fM2 yok !!!"); 
.................... //                   printf(lcd_putc,"\nI2:%Lu",akim_adc_deger2); 
.................... //                   time_akim_olc2=millis(); 
.................... //              } 
....................                m2_var_yok=MOTOR_YOK; 
2E94:  MOVLW  51
2E96:  MOVWF  xE3
....................                  
....................         } else  m2_var_yok=MOTOR_VAR; 
2E98:  BRA    2E9E
2E9A:  MOVLW  71
2E9C:  MOVWF  xE3
....................          
....................         if(akim_adc_deger1>200 || akim_adc_deger2>200)//1000mV/4.88mv=~205 motordan geçen 1Amper akým deðeridir. aþýrýakým korumasý. 
2E9E:  MOVF   4C,F
2EA0:  BNZ   2EB2
2EA2:  MOVF   4B,W
2EA4:  SUBLW  C8
2EA6:  BNC   2EB2
2EA8:  MOVF   4E,F
2EAA:  BNZ   2EB2
2EAC:  MOVF   4D,W
2EAE:  SUBLW  C8
2EB0:  BC    2F12
....................         { 
....................             analogWrite(M1_PWM, 0); 
2EB2:  CLRF   FBE
....................             analogWrite(M2_PWM, 0); 
2EB4:  CLRF   F67
....................             
....................             printf(lcd_putc,"\f! ASIRI AKIM !");  
2EB6:  MOVLW  EC
2EB8:  MOVWF  FF6
2EBA:  MOVLW  06
2EBC:  MOVWF  FF7
2EBE:  CALL   0A06
....................             printf(lcd_putc,"\n    << <> >>"); 
2EC2:  MOVLW  FC
2EC4:  MOVWF  FF6
2EC6:  MOVLW  06
2EC8:  MOVWF  FF7
2ECA:  CALL   0A06
....................              
....................             while(akim_adc_deger1< 25 && akim_adc_deger2<25){ 
2ECE:  MOVF   4C,F
2ED0:  BNZ   2F12
2ED2:  MOVF   4B,W
2ED4:  SUBLW  18
2ED6:  BNC   2F12
2ED8:  MOVF   4E,F
2EDA:  BNZ   2F12
2EDC:  MOVF   4D,W
2EDE:  SUBLW  18
2EE0:  BNC   2F12
....................                 analogWrite(M1_PWM, 0); 
2EE2:  CLRF   FBE
....................                 analogWrite(M2_PWM, 0); 
2EE4:  CLRF   F67
....................                 o1_akim_olc(); 
2EE6:  CALL   1F84
....................                 o2_akim_olc(); 
2EEA:  CALL   1FE2
2EEE:  CLRF   16
2EF0:  BTFSC  FF2.6
2EF2:  BSF    16.6
2EF4:  BCF    FF2.6
2EF6:  BTFSC  FF2.7
2EF8:  BSF    16.7
2EFA:  BCF    FF2.7
....................                // panel1_komut(MOTOR_YOK); 
....................                // panel2_komut(MOTOR_YOK); 
....................                 delay_ms(100); 
2EFC:  MOVLW  64
2EFE:  MOVLB  1
2F00:  MOVWF  x27
2F02:  MOVLB  0
2F04:  CALL   0748
2F08:  BTFSC  16.6
2F0A:  BSF    FF2.6
2F0C:  BTFSC  16.7
2F0E:  BSF    FF2.7
2F10:  BRA    2ECE
....................             } 
....................              
....................         } 
....................          
....................         if(yol1>yol2){ sira1=1; sira2=2;} 
2F12:  MOVFF  86,101
2F16:  MOVFF  85,100
2F1A:  MOVFF  84,FF
2F1E:  MOVFF  83,FE
2F22:  MOVFF  82,105
2F26:  MOVFF  81,104
2F2A:  MOVFF  80,103
2F2E:  MOVFF  7F,102
2F32:  CALL   1D84
2F36:  BNC   2F40
2F38:  MOVLW  01
2F3A:  MOVWF  x7D
2F3C:  MOVLW  02
2F3E:  MOVWF  x7E
....................         if(yol1<yol2){ sira1=2; sira2=1;} 
2F40:  MOVFF  82,101
2F44:  MOVFF  81,100
2F48:  MOVFF  80,FF
2F4C:  MOVFF  7F,FE
2F50:  MOVFF  86,105
2F54:  MOVFF  85,104
2F58:  MOVFF  84,103
2F5C:  MOVFF  83,102
2F60:  CALL   1D84
2F64:  BNC   2F6E
2F66:  MOVLW  02
2F68:  MOVWF  x7D
2F6A:  MOVLW  01
2F6C:  MOVWF  x7E
....................         if(yol1==yol2){ sira1=0; sira2=0;} 
2F6E:  MOVFF  82,101
2F72:  MOVFF  81,100
2F76:  MOVFF  80,FF
2F7A:  MOVFF  7F,FE
2F7E:  MOVFF  86,105
2F82:  MOVFF  85,104
2F86:  MOVFF  84,103
2F8A:  MOVFF  83,102
2F8E:  CALL   1D84
2F92:  BNZ   2F98
2F94:  CLRF   x7D
2F96:  CLRF   x7E
....................          
....................         if(millis()-time_veri_gonder>=1250){ 
2F98:  MOVF   xED,W
2F9A:  SUBWF  2A,W
2F9C:  MOVWF  xFE
2F9E:  MOVF   xEE,W
2FA0:  SUBWFB 2B,W
2FA2:  MOVWF  xFF
2FA4:  MOVF   xEF,W
2FA6:  SUBWFB 2C,W
2FA8:  MOVLB  1
2FAA:  MOVWF  x00
2FAC:  MOVLB  0
2FAE:  MOVF   xF0,W
2FB0:  SUBWFB 2D,W
2FB2:  MOVLB  1
2FB4:  MOVWF  x01
2FB6:  MOVF   x01,F
2FB8:  BNZ   2FDC
2FBA:  MOVF   x00,F
2FBC:  BNZ   2FDC
2FBE:  MOVLB  0
2FC0:  MOVF   xFF,W
2FC2:  SUBLW  03
2FC4:  BTFSC  FD8.0
2FC6:  BRA    33DC
2FC8:  XORLW  FF
2FCA:  BTFSC  FD8.2
2FCC:  BRA    2FD2
2FCE:  MOVLB  1
2FD0:  BRA    2FDC
2FD2:  MOVF   xFE,W
2FD4:  SUBLW  E1
2FD6:  BTFSC  FD8.0
2FD8:  BRA    33DC
2FDA:  MOVLB  1
....................              
....................             disable_interrupts(INT_EXT1);       //HIZ1 
2FDC:  BCF    FF0.3
....................             disable_interrupts(INT_EXT2); 
2FDE:  BCF    FF0.4
....................              
....................              if(o2_mod==SISTEM){ 
2FE0:  MOVF   3C,W
2FE2:  SUBLW  35
2FE4:  BNZ   3054
....................                 yol2+=rps2*(2*pi*tekerlek_yari_cap);  
2FE6:  MOVFF  56,101
2FEA:  MOVFF  55,100
2FEE:  MOVLB  0
2FF0:  CALL   1888
2FF4:  MOVFF  03,110
2FF8:  MOVFF  02,10F
2FFC:  MOVFF  01,10E
3000:  MOVFF  00,10D
3004:  MOVLW  AB
3006:  MOVLB  1
3008:  MOVWF  x14
300A:  MOVLW  F4
300C:  MOVWF  x13
300E:  MOVLW  34
3010:  MOVWF  x12
3012:  MOVLW  80
3014:  MOVWF  x11
3016:  MOVLB  0
3018:  CALL   18BE
301C:  BCF    FD8.1
301E:  MOVFF  86,101
3022:  MOVFF  85,100
3026:  MOVFF  84,FF
302A:  MOVFF  83,FE
302E:  MOVFF  03,105
3032:  MOVFF  02,104
3036:  MOVFF  01,103
303A:  MOVFF  00,102
303E:  CALL   2040
3042:  MOVFF  03,86
3046:  MOVFF  02,85
304A:  MOVFF  01,84
304E:  MOVFF  00,83
3052:  MOVLB  1
....................                // pist_tur2=(long)(yol2/8.51f); 
....................              } 
....................              if(o1_mod==SISTEM){ 
3054:  MOVF   3B,W
3056:  SUBLW  35
3058:  BNZ   30C8
....................                 yol1+=rps1*(2*pi*tekerlek_yari_cap);  
305A:  MOVFF  54,101
305E:  MOVFF  53,100
3062:  MOVLB  0
3064:  CALL   1888
3068:  MOVFF  03,110
306C:  MOVFF  02,10F
3070:  MOVFF  01,10E
3074:  MOVFF  00,10D
3078:  MOVLW  AB
307A:  MOVLB  1
307C:  MOVWF  x14
307E:  MOVLW  F4
3080:  MOVWF  x13
3082:  MOVLW  34
3084:  MOVWF  x12
3086:  MOVLW  80
3088:  MOVWF  x11
308A:  MOVLB  0
308C:  CALL   18BE
3090:  BCF    FD8.1
3092:  MOVFF  82,101
3096:  MOVFF  81,100
309A:  MOVFF  80,FF
309E:  MOVFF  7F,FE
30A2:  MOVFF  03,105
30A6:  MOVFF  02,104
30AA:  MOVFF  01,103
30AE:  MOVFF  00,102
30B2:  CALL   2040
30B6:  MOVFF  03,82
30BA:  MOVFF  02,81
30BE:  MOVFF  01,80
30C2:  MOVFF  00,7F
30C6:  MOVLB  1
....................                // pist_tur1=(long)(yol1/8.51f); 
....................              } 
....................            // v1=100; tekerlek_tur1=500;pist_tur1=250;sira1=1;yol1=525; 
....................                           // 1                            2        3            4           5        6     7        8 
....................             sprintf(buf_str,"O,%lu,%lu,%lu,%lu,%u,%u,%c,c",(long)v1,tekerlek_tur1,pist_tur1,(long)yol1,sira1,x_fill, m1_var_yok); 
30C8:  MOVFF  6E,103
30CC:  MOVFF  6D,102
30D0:  MOVFF  6C,101
30D4:  MOVFF  6B,100
30D8:  MOVLB  0
30DA:  CALL   182A
30DE:  MOVFF  02,FF
30E2:  MOVFF  01,FE
30E6:  MOVFF  82,103
30EA:  MOVFF  81,102
30EE:  MOVFF  80,101
30F2:  MOVFF  7F,100
30F6:  CALL   182A
30FA:  MOVFF  02,101
30FE:  MOVFF  01,100
3102:  CLRF   xAE
3104:  MOVLW  B0
3106:  MOVWF  xAD
3108:  MOVLW  4F
310A:  MOVLB  1
310C:  MOVWF  x0B
310E:  MOVLB  0
3110:  CALL   22BE
3114:  MOVLW  2C
3116:  MOVLB  1
3118:  MOVWF  x0B
311A:  MOVLB  0
311C:  CALL   22BE
3120:  MOVLW  10
3122:  MOVWF  FE9
3124:  MOVFF  FF,103
3128:  MOVFF  FE,102
312C:  CALL   22DE
3130:  MOVLW  2C
3132:  MOVLB  1
3134:  MOVWF  x0B
3136:  MOVLB  0
3138:  CALL   22BE
313C:  MOVLW  10
313E:  MOVWF  FE9
3140:  MOVFF  76,103
3144:  MOVFF  75,102
3148:  CALL   22DE
314C:  MOVLW  2C
314E:  MOVLB  1
3150:  MOVWF  x0B
3152:  MOVLB  0
3154:  CALL   22BE
3158:  MOVLW  10
315A:  MOVWF  FE9
315C:  MOVFF  7A,103
3160:  MOVFF  79,102
3164:  CALL   22DE
3168:  MOVLW  2C
316A:  MOVLB  1
316C:  MOVWF  x0B
316E:  MOVLB  0
3170:  CALL   22BE
3174:  MOVLW  10
3176:  MOVWF  FE9
3178:  MOVFF  101,103
317C:  MOVFF  100,102
3180:  CALL   22DE
3184:  MOVLW  2C
3186:  MOVLB  1
3188:  MOVWF  x0B
318A:  MOVLB  0
318C:  CALL   22BE
3190:  MOVFF  7D,102
3194:  MOVLW  1B
3196:  MOVLB  1
3198:  MOVWF  x03
319A:  MOVLB  0
319C:  CALL   23A2
31A0:  MOVLW  2C
31A2:  MOVLB  1
31A4:  MOVWF  x0B
31A6:  MOVLB  0
31A8:  CALL   22BE
31AC:  MOVFF  AF,102
31B0:  MOVLW  1B
31B2:  MOVLB  1
31B4:  MOVWF  x03
31B6:  MOVLB  0
31B8:  CALL   23A2
31BC:  MOVLW  2C
31BE:  MOVLB  1
31C0:  MOVWF  x0B
31C2:  MOVLB  0
31C4:  CALL   22BE
31C8:  MOVFF  E2,10B
31CC:  CALL   22BE
31D0:  MOVLW  2C
31D2:  MOVLB  1
31D4:  MOVWF  x0B
31D6:  MOVLB  0
31D8:  CALL   22BE
31DC:  MOVLW  63
31DE:  MOVLB  1
31E0:  MOVWF  x0B
31E2:  MOVLB  0
31E4:  CALL   22BE
....................             fprintf(Panel1Serial,"%s",buf_str); 
31E8:  CLRF   FEA
31EA:  MOVLW  B0
31EC:  MOVWF  FE9
31EE:  GOTO   2422
....................           //  delay_ms(100); 
....................             sprintf(buf_str,"O,%lu,%lu,%lu,%lu,%u,%u,%c,c",(long)v2,tekerlek_tur2,pist_tur2,(long)yol2,sira2,x_fill,m2_var_yok); 
31F2:  MOVFF  72,103
31F6:  MOVFF  71,102
31FA:  MOVFF  70,101
31FE:  MOVFF  6F,100
3202:  CALL   182A
3206:  MOVFF  02,FF
320A:  MOVFF  01,FE
320E:  MOVFF  86,103
3212:  MOVFF  85,102
3216:  MOVFF  84,101
321A:  MOVFF  83,100
321E:  CALL   182A
3222:  MOVFF  02,101
3226:  MOVFF  01,100
322A:  CLRF   xAE
322C:  MOVLW  B0
322E:  MOVWF  xAD
3230:  MOVLW  4F
3232:  MOVLB  1
3234:  MOVWF  x0B
3236:  MOVLB  0
3238:  CALL   22BE
323C:  MOVLW  2C
323E:  MOVLB  1
3240:  MOVWF  x0B
3242:  MOVLB  0
3244:  CALL   22BE
3248:  MOVLW  10
324A:  MOVWF  FE9
324C:  MOVFF  FF,103
3250:  MOVFF  FE,102
3254:  CALL   22DE
3258:  MOVLW  2C
325A:  MOVLB  1
325C:  MOVWF  x0B
325E:  MOVLB  0
3260:  CALL   22BE
3264:  MOVLW  10
3266:  MOVWF  FE9
3268:  MOVFF  78,103
326C:  MOVFF  77,102
3270:  CALL   22DE
3274:  MOVLW  2C
3276:  MOVLB  1
3278:  MOVWF  x0B
327A:  MOVLB  0
327C:  CALL   22BE
3280:  MOVLW  10
3282:  MOVWF  FE9
3284:  MOVFF  7C,103
3288:  MOVFF  7B,102
328C:  CALL   22DE
3290:  MOVLW  2C
3292:  MOVLB  1
3294:  MOVWF  x0B
3296:  MOVLB  0
3298:  CALL   22BE
329C:  MOVLW  10
329E:  MOVWF  FE9
32A0:  MOVFF  101,103
32A4:  MOVFF  100,102
32A8:  CALL   22DE
32AC:  MOVLW  2C
32AE:  MOVLB  1
32B0:  MOVWF  x0B
32B2:  MOVLB  0
32B4:  CALL   22BE
32B8:  MOVFF  7E,102
32BC:  MOVLW  1B
32BE:  MOVLB  1
32C0:  MOVWF  x03
32C2:  MOVLB  0
32C4:  CALL   23A2
32C8:  MOVLW  2C
32CA:  MOVLB  1
32CC:  MOVWF  x0B
32CE:  MOVLB  0
32D0:  CALL   22BE
32D4:  MOVFF  AF,102
32D8:  MOVLW  1B
32DA:  MOVLB  1
32DC:  MOVWF  x03
32DE:  MOVLB  0
32E0:  CALL   23A2
32E4:  MOVLW  2C
32E6:  MOVLB  1
32E8:  MOVWF  x0B
32EA:  MOVLB  0
32EC:  CALL   22BE
32F0:  MOVFF  E3,10B
32F4:  CALL   22BE
32F8:  MOVLW  2C
32FA:  MOVLB  1
32FC:  MOVWF  x0B
32FE:  MOVLB  0
3300:  CALL   22BE
3304:  MOVLW  63
3306:  MOVLB  1
3308:  MOVWF  x0B
330A:  MOVLB  0
330C:  CALL   22BE
....................             fprintf(Panel2Serial,"%s",buf_str); 
3310:  CLRF   FEA
3312:  MOVLW  B0
3314:  MOVWF  FE9
3316:  GOTO   244A
....................              
....................             sistem_mod_hiz_deg_say++; 
331A:  INCF   xE4,F
....................              
....................             printf(lcd_putc,"\fV1:%2.1f V2:%2.1f",v1,v2); 
331C:  MOVLW  0A
331E:  MOVWF  FF6
3320:  MOVLW  07
3322:  MOVWF  FF7
3324:  MOVLW  04
3326:  MOVLB  1
3328:  MOVWF  x02
332A:  MOVLB  0
332C:  CALL   162E
3330:  MOVLW  01
3332:  MOVWF  FE9
3334:  MOVFF  6E,101
3338:  MOVFF  6D,100
333C:  MOVFF  6C,FF
3340:  MOVFF  6B,FE
3344:  MOVLB  1
3346:  MOVWF  x02
3348:  MOVLB  0
334A:  CALL   24B4
334E:  MOVLW  13
3350:  MOVWF  FF6
3352:  MOVLW  07
3354:  MOVWF  FF7
3356:  MOVLW  04
3358:  MOVLB  1
335A:  MOVWF  x02
335C:  MOVLB  0
335E:  CALL   162E
3362:  MOVLW  01
3364:  MOVWF  FE9
3366:  MOVFF  72,101
336A:  MOVFF  71,100
336E:  MOVFF  70,FF
3372:  MOVFF  6F,FE
3376:  MOVLB  1
3378:  MOVWF  x02
337A:  MOVLB  0
337C:  CALL   24B4
....................            // printf(lcd_putc,"\nI1:%3lu I2:%3lu",akim_adc_deger1,akim_adc_deger2); 
....................             printf(lcd_putc,"\fsure:%Lu",((millis()-time_oyun_sure_say)));  
3380:  MOVF   x93,W
3382:  SUBWF  2A,W
3384:  MOVWF  xFE
3386:  MOVF   x94,W
3388:  SUBWFB 2B,W
338A:  MOVWF  xFF
338C:  MOVF   x95,W
338E:  SUBWFB 2C,W
3390:  MOVLB  1
3392:  MOVWF  x00
3394:  MOVLB  0
3396:  MOVF   x96,W
3398:  SUBWFB 2D,W
339A:  MOVLB  1
339C:  MOVWF  x01
339E:  MOVLW  1E
33A0:  MOVWF  FF6
33A2:  MOVLW  07
33A4:  MOVWF  FF7
33A6:  MOVLW  06
33A8:  MOVWF  x02
33AA:  MOVLB  0
33AC:  CALL   162E
33B0:  MOVLW  41
33B2:  MOVWF  FE9
33B4:  MOVFF  101,105
33B8:  MOVFF  100,104
33BC:  MOVFF  FF,103
33C0:  MOVFF  FE,102
33C4:  CALL   0ABA
....................              
....................             enable_interrupts(INT_EXT1);       //HIZ1 
33C8:  BSF    FF0.3
....................             enable_interrupts(INT_EXT2); 
33CA:  BSF    FF0.4
....................              
....................             //time_akim_olc1=millis(); 
....................             //time_akim_olc2=millis(); 
....................             time_veri_gonder=millis(); 
33CC:  MOVFF  2D,F0
33D0:  MOVFF  2C,EF
33D4:  MOVFF  2B,EE
33D8:  MOVFF  2A,ED
....................         } 
....................           
....................      }while((millis()-time_oyun_sure_say) < time_oyun); 
33DC:  MOVF   x93,W
33DE:  SUBWF  2A,W
33E0:  MOVWF  xFE
33E2:  MOVF   x94,W
33E4:  SUBWFB 2B,W
33E6:  MOVWF  xFF
33E8:  MOVF   x95,W
33EA:  SUBWFB 2C,W
33EC:  MOVLB  1
33EE:  MOVWF  x00
33F0:  MOVLB  0
33F2:  MOVF   x96,W
33F4:  SUBWFB 2D,W
33F6:  MOVLB  1
33F8:  MOVWF  x01
33FA:  MOVLB  0
33FC:  SUBWF  x92,W
33FE:  BNC   342C
3400:  BTFSS  FD8.2
3402:  GOTO   27F8
3406:  MOVLB  1
3408:  MOVF   x00,W
340A:  MOVLB  0
340C:  SUBWF  x91,W
340E:  BNC   342C
3410:  BTFSS  FD8.2
3412:  GOTO   27F8
3416:  MOVF   xFF,W
3418:  SUBWF  x90,W
341A:  BNC   342C
341C:  BTFSS  FD8.2
341E:  GOTO   27F8
3422:  MOVF   x8F,W
3424:  SUBWF  xFE,W
3426:  BTFSS  FD8.0
3428:  GOTO   27F8
....................       
....................      ////       Oyun BITTI          ///// 
....................   
....................      disable_interrupts(INT_EXT1);       //HIZ1 
342C:  BCF    FF0.3
....................      disable_interrupts(INT_EXT2); 
342E:  BCF    FF0.4
....................      disable_interrupts(INT_RB); 
3430:  CLRF   F62
....................       
....................      delay_ms(300); 
3432:  MOVLW  02
3434:  MOVWF  xFE
3436:  CLRF   16
3438:  BTFSC  FF2.6
343A:  BSF    16.6
343C:  BCF    FF2.6
343E:  BTFSC  FF2.7
3440:  BSF    16.7
3442:  BCF    FF2.7
3444:  MOVLW  96
3446:  MOVLB  1
3448:  MOVWF  x27
344A:  MOVLB  0
344C:  CALL   0748
3450:  BTFSC  16.6
3452:  BSF    FF2.6
3454:  BTFSC  16.7
3456:  BSF    FF2.7
3458:  DECFSZ xFE,F
345A:  BRA    3436
....................      panel1_komut(OYUN_BITTI); 
345C:  MOVLW  45
345E:  MOVLB  1
3460:  MOVWF  x00
3462:  MOVLB  0
3464:  CALL   13BA
3468:  MOVLW  63
346A:  MOVLB  1
346C:  MOVWF  x00
346E:  MOVLB  0
3470:  CALL   13BA
....................      delay_ms(300); 
3474:  MOVLW  02
3476:  MOVWF  xFE
3478:  CLRF   16
347A:  BTFSC  FF2.6
347C:  BSF    16.6
347E:  BCF    FF2.6
3480:  BTFSC  FF2.7
3482:  BSF    16.7
3484:  BCF    FF2.7
3486:  MOVLW  96
3488:  MOVLB  1
348A:  MOVWF  x27
348C:  MOVLB  0
348E:  CALL   0748
3492:  BTFSC  16.6
3494:  BSF    FF2.6
3496:  BTFSC  16.7
3498:  BSF    FF2.7
349A:  DECFSZ xFE,F
349C:  BRA    3478
....................      panel2_komut(OYUN_BITTI); 
349E:  MOVLW  45
34A0:  MOVLB  1
34A2:  MOVWF  x00
34A4:  MOVLB  0
34A6:  CALL   143C
34AA:  MOVLW  63
34AC:  MOVLB  1
34AE:  MOVWF  x00
34B0:  MOVLB  0
34B2:  CALL   143C
....................       
....................      mp3_stop(); delay_ms(100); 
34B6:  CALL   1302
34BA:  CLRF   16
34BC:  BTFSC  FF2.6
34BE:  BSF    16.6
34C0:  BCF    FF2.6
34C2:  BTFSC  FF2.7
34C4:  BSF    16.7
34C6:  BCF    FF2.7
34C8:  MOVLW  64
34CA:  MOVLB  1
34CC:  MOVWF  x27
34CE:  MOVLB  0
34D0:  CALL   0748
34D4:  BTFSC  16.6
34D6:  BSF    FF2.6
34D8:  BTFSC  16.7
34DA:  BSF    FF2.7
.................... 	 mp3_play(wav_oyunBitti); 
34DC:  CLRF   xFF
34DE:  MOVLW  06
34E0:  MOVWF  xFE
34E2:  CALL   1658
....................     // delay_ms(4000); 
....................       
....................    
....................      BOOLEAN m1_dur = FALSE, m2_dur = FALSE; 
.................... 	 unsigned long long time = millis(); 
.................... 	 unsigned long long time_m12_dur = millis(); 
34E6:  BCF    xF5.0
34E8:  BCF    xF5.1
34EA:  MOVFF  2D,F9
34EE:  MOVFF  2C,F8
34F2:  MOVFF  2B,F7
34F6:  MOVFF  2A,F6
34FA:  MOVFF  2D,FD
34FE:  MOVFF  2C,FC
3502:  MOVFF  2B,FB
3506:  MOVFF  2A,FA
.................... 	 m1_pwm_deger = m2_pwm_deger =pwm_max_deger;        //yoldan çýkmamasý için ayarlanan max deger. 
350A:  MOVFF  46,A0
350E:  MOVFF  45,9F
3512:  MOVFF  A0,9E
3516:  MOVFF  9F,9D
.................... 	 analogWrite(M1_PWM, m1_pwm_deger);		//analogWrite(pin, value) 
351A:  MOVFF  9E,02
351E:  MOVFF  9D,01
3522:  RRCF   02,F
3524:  RRCF   01,F
3526:  RRCF   02,F
3528:  RRCF   01,F
352A:  RRCF   02,F
352C:  MOVFF  01,FBE
3530:  RRCF   02,F
3532:  RRCF   02,W
3534:  ANDLW  30
3536:  MOVWF  00
3538:  MOVF   FBD,W
353A:  ANDLW  CF
353C:  IORWF  00,W
353E:  MOVWF  FBD
.................... 	 analogWrite(M2_PWM, m2_pwm_deger); 
3540:  MOVFF  A0,02
3544:  MOVFF  9F,01
3548:  RRCF   02,F
354A:  RRCF   01,F
354C:  RRCF   02,F
354E:  RRCF   01,F
3550:  RRCF   02,F
3552:  MOVFF  01,F67
3556:  RRCF   02,F
3558:  RRCF   02,W
355A:  ANDLW  30
355C:  MOVWF  00
355E:  MOVF   F66,W
3560:  ANDLW  CF
3562:  IORWF  00,W
3564:  MOVWF  F66
....................       
....................      do{ 
....................  
.................... 		if (!input(TUR1_SENS_PIN)){ 
3566:  BSF    F93.5
3568:  BTFSC  F81.5
356A:  BRA    3570
.................... 			analogWrite(M1_PWM, 0);		//analogWrite(pin, value) 
356C:  CLRF   FBE
.................... 			m1_dur = TRUE; 
356E:  BSF    xF5.0
.................... 		} 
.................... 		if (!input(TUR2_SENS_PIN)){ 
3570:  BSF    F93.4
3572:  BTFSC  F81.4
3574:  BRA    357A
.................... 			analogWrite(M2_PWM, 0); 
3576:  CLRF   F67
.................... 			m2_dur = TRUE; 
3578:  BSF    xF5.1
.................... 		} 
....................  
.................... 		if (millis() - time_m12_dur > 25000){ 
357A:  MOVF   xFA,W
357C:  SUBWF  2A,W
357E:  MOVWF  xFE
3580:  MOVF   xFB,W
3582:  SUBWFB 2B,W
3584:  MOVWF  xFF
3586:  MOVF   xFC,W
3588:  SUBWFB 2C,W
358A:  MOVLB  1
358C:  MOVWF  x00
358E:  MOVLB  0
3590:  MOVF   xFD,W
3592:  SUBWFB 2D,W
3594:  MOVLB  1
3596:  MOVWF  x01
3598:  MOVF   x01,F
359A:  BNZ   35BA
359C:  MOVF   x00,F
359E:  BNZ   35BA
35A0:  MOVLB  0
35A2:  MOVF   xFF,W
35A4:  SUBLW  60
35A6:  BC    35C2
35A8:  XORLW  FF
35AA:  BTFSC  FD8.2
35AC:  BRA    35B2
35AE:  MOVLB  1
35B0:  BRA    35BA
35B2:  MOVF   xFE,W
35B4:  SUBLW  A8
35B6:  BC    35C2
35B8:  MOVLB  1
.................... 			analogWrite(M1_PWM, 0); 
35BA:  CLRF   FBE
.................... 			analogWrite(M2_PWM, 0); 
35BC:  CLRF   F67
.................... 			break; 
35BE:  BRA    35D4
35C0:  MOVLB  0
.................... 		} 
.................... 		if (m1_dur && m2_dur) break; 
35C2:  BTFSS  xF5.0
35C4:  BRA    35D0
35C6:  BTFSS  xF5.1
35C8:  BRA    35D0
35CA:  MOVLB  1
35CC:  BRA    35D4
35CE:  MOVLB  0
....................  
....................     } while (1); 
35D0:  BRA    3566
35D2:  MOVLB  1
....................       
....................      mp3_stop(); delay_ms(100); 
35D4:  MOVLB  0
35D6:  CALL   1302
35DA:  CLRF   16
35DC:  BTFSC  FF2.6
35DE:  BSF    16.6
35E0:  BCF    FF2.6
35E2:  BTFSC  FF2.7
35E4:  BSF    16.7
35E6:  BCF    FF2.7
35E8:  MOVLW  64
35EA:  MOVLB  1
35EC:  MOVWF  x27
35EE:  MOVLB  0
35F0:  CALL   0748
35F4:  BTFSC  16.6
35F6:  BSF    FF2.6
35F8:  BTFSC  16.7
35FA:  BSF    FF2.7
.................... 	 mp3_play(wav_alkisSesi); 
35FC:  CLRF   xFF
35FE:  MOVLW  05
3600:  MOVWF  xFE
3602:  CALL   1658
.................... 	 delay_ms(3000); 
3606:  MOVLW  0C
3608:  MOVWF  xFE
360A:  CLRF   16
360C:  BTFSC  FF2.6
360E:  BSF    16.6
3610:  BCF    FF2.6
3612:  BTFSC  FF2.7
3614:  BSF    16.7
3616:  BCF    FF2.7
3618:  MOVLW  FA
361A:  MOVLB  1
361C:  MOVWF  x27
361E:  MOVLB  0
3620:  CALL   0748
3624:  BTFSC  16.6
3626:  BSF    FF2.6
3628:  BTFSC  16.7
362A:  BSF    FF2.7
362C:  DECFSZ xFE,F
362E:  BRA    360A
....................       
....................      panel1_komut(BOS_ANIM_EKRANI); 
3630:  MOVLW  4B
3632:  MOVLB  1
3634:  MOVWF  x00
3636:  MOVLB  0
3638:  CALL   13BA
363C:  MOVLW  63
363E:  MOVLB  1
3640:  MOVWF  x00
3642:  MOVLB  0
3644:  CALL   13BA
....................      panel2_komut(BOS_ANIM_EKRANI); 
3648:  MOVLW  4B
364A:  MOVLB  1
364C:  MOVWF  x00
364E:  MOVLB  0
3650:  CALL   143C
3654:  MOVLW  63
3656:  MOVLB  1
3658:  MOVWF  x00
365A:  MOVLB  0
365C:  CALL   143C
....................       
....................      b1=b2=0; 
3660:  BCF    38.2
3662:  BCF    38.1
....................      o1_mod_say=MOD_SECILMEDI; o2_mod_say=MOD_SECILMEDI;o1_mod=SISTEM; o2_mod=SISTEM; 
3664:  SETF   39
3666:  SETF   3A
3668:  MOVLW  35
366A:  MOVWF  3B
366C:  MOVWF  3C
....................      jetonAtildi=jetonSay=zmn_say1=zmn_say2=0; 
366E:  CLRF   x9A
3670:  MOVFF  9A,99
3674:  MOVFF  99,36
3678:  BCF    38.0
367A:  BTFSC  36.0
367C:  BSF    38.0
....................      oyun_basladi=FALSE; 
367E:  BCF    38.3
....................      tekerlek_tur1= tekerlek_tur2 = yol1 = yol2 = 0; 
3680:  CLRF   x86
3682:  CLRF   x85
3684:  CLRF   x84
3686:  CLRF   x83
3688:  MOVFF  86,82
368C:  MOVFF  85,81
3690:  MOVFF  84,80
3694:  MOVFF  83,7F
3698:  MOVFF  82,103
369C:  MOVFF  81,102
36A0:  MOVFF  80,101
36A4:  MOVFF  7F,100
36A8:  CALL   182A
36AC:  MOVFF  02,78
36B0:  MOVFF  01,77
36B4:  MOVFF  78,76
36B8:  MOVFF  77,75
....................      pist_tur1 = pist_tur2 = 0; 
36BC:  CLRF   x7C
36BE:  CLRF   x7B
36C0:  MOVFF  7C,7A
36C4:  MOVFF  7B,79
.................... 	 sira1=sira2=0; 
36C8:  CLRF   x7E
36CA:  MOVFF  7E,7D
....................      bis_sec_sure_bitti=FALSE; 
36CE:  BCF    38.4
....................       
....................     printf(lcd_putc,"\f    YOYUNCAK"); 
36D0:  MOVLW  28
36D2:  MOVWF  FF6
36D4:  MOVLW  07
36D6:  MOVWF  FF7
36D8:  CALL   0A06
....................     printf(lcd_putc,"\n HIZLI & PEDALLI"); 
36DC:  MOVLW  36
36DE:  MOVWF  FF6
36E0:  MOVLW  07
36E2:  MOVWF  FF7
36E4:  CALL   0A06
36E8:  GOTO   3BBC (RETURN)
....................  
....................  } 
....................   
....................   
....................  void o1_hiz_olcum(){ 
....................       
....................     tekerlek_tur1++; 
*
19B4:  INCF   x75,F
19B6:  BTFSC  FD8.2
19B8:  INCF   x76,F
....................     dtime1 = millis(); 
19BA:  MOVFF  2D,62
19BE:  MOVFF  2C,61
19C2:  MOVFF  2B,60
19C6:  MOVFF  2A,5F
....................     timetaken1 = (unsigned long)(millis() - pevtime1); //time in millisec for two rotations 
19CA:  MOVF   57,W
19CC:  SUBWF  2A,W
19CE:  MOVWF  00
19D0:  MOVF   58,W
19D2:  SUBWFB 2B,W
19D4:  MOVWF  01
19D6:  MOVF   59,W
19D8:  SUBWFB 2C,W
19DA:  MOVF   5A,W
19DC:  SUBWFB 2D,W
19DE:  MOVFF  01,68
19E2:  MOVFF  00,67
....................  
....................     if (timetaken1>0){ 
19E6:  MOVF   x67,F
19E8:  BNZ   19F0
19EA:  MOVF   x68,F
19EC:  BTFSC  FD8.2
19EE:  BRA    1B48
....................        //rps1 = (unsigned int16)(1000 /((unsigned int16) timetaken1));//*60; //calculate rps(rotate per second)=F(Hz) 
....................        rpm1 = (unsigned int16)(1000 /((unsigned int16) timetaken1))*60; 
19F0:  MOVLW  03
19F2:  MOVLB  1
19F4:  MOVWF  x0F
19F6:  MOVLW  E8
19F8:  MOVWF  x0E
19FA:  MOVFF  68,111
19FE:  MOVFF  67,110
1A02:  MOVLB  0
1A04:  RCALL  1578
1A06:  MOVFF  02,101
1A0A:  MOVFF  01,100
1A0E:  MOVFF  02,10F
1A12:  MOVFF  01,10E
1A16:  MOVLB  1
1A18:  CLRF   x11
1A1A:  MOVLW  3C
1A1C:  MOVWF  x10
1A1E:  MOVLB  0
1A20:  RCALL  1866
1A22:  MOVFF  02,50
1A26:  MOVFF  01,4F
....................         v1 = (float)(tekerlek_yari_cap * rpm1 * 0.37699f); //0.33 is the radius of the wheel in meter 
1A2A:  MOVFF  50,101
1A2E:  MOVFF  4F,100
1A32:  RCALL  1888
1A34:  MOVLW  66
1A36:  MOVLB  1
1A38:  MOVWF  x10
1A3A:  MOVWF  x0F
1A3C:  MOVWF  x0E
1A3E:  MOVLW  7D
1A40:  MOVWF  x0D
1A42:  MOVFF  03,114
1A46:  MOVFF  02,113
1A4A:  MOVFF  01,112
1A4E:  MOVFF  00,111
1A52:  MOVLB  0
1A54:  RCALL  18BE
1A56:  MOVFF  03,103
1A5A:  MOVFF  02,102
1A5E:  MOVFF  01,101
1A62:  MOVFF  00,100
1A66:  MOVFF  03,110
1A6A:  MOVFF  02,10F
1A6E:  MOVFF  01,10E
1A72:  MOVFF  00,10D
1A76:  MOVLW  D5
1A78:  MOVLB  1
1A7A:  MOVWF  x14
1A7C:  MOVLW  04
1A7E:  MOVWF  x13
1A80:  MOVLW  41
1A82:  MOVWF  x12
1A84:  MOVLW  7D
1A86:  MOVWF  x11
1A88:  MOVLB  0
1A8A:  RCALL  18BE
1A8C:  MOVFF  03,6E
1A90:  MOVFF  02,6D
1A94:  MOVFF  01,6C
1A98:  MOVFF  00,6B
....................         if(o1_mod_say==COCUK_MOD) v1=v1*2.0f; 
1A9C:  MOVF   39,W
1A9E:  SUBLW  02
1AA0:  BNZ   1AD2
1AA2:  MOVFF  6E,110
1AA6:  MOVFF  6D,10F
1AAA:  MOVFF  6C,10E
1AAE:  MOVFF  6B,10D
1AB2:  MOVLB  1
1AB4:  CLRF   x14
1AB6:  CLRF   x13
1AB8:  CLRF   x12
1ABA:  MOVLW  80
1ABC:  MOVWF  x11
1ABE:  MOVLB  0
1AC0:  RCALL  18BE
1AC2:  MOVFF  03,6E
1AC6:  MOVFF  02,6D
1ACA:  MOVFF  01,6C
1ACE:  MOVFF  00,6B
....................         if(o1_mod_say==BAYAN_MOD) v1=v1*1.5f; 
1AD2:  DECFSZ 39,W
1AD4:  BRA    1B08
1AD6:  MOVFF  6E,110
1ADA:  MOVFF  6D,10F
1ADE:  MOVFF  6C,10E
1AE2:  MOVFF  6B,10D
1AE6:  MOVLB  1
1AE8:  CLRF   x14
1AEA:  CLRF   x13
1AEC:  MOVLW  40
1AEE:  MOVWF  x12
1AF0:  MOVLW  7F
1AF2:  MOVWF  x11
1AF4:  MOVLB  0
1AF6:  RCALL  18BE
1AF8:  MOVFF  03,6E
1AFC:  MOVFF  02,6D
1B00:  MOVFF  01,6C
1B04:  MOVFF  00,6B
....................        // v1=(float)(2*pi*radius_of_wheel*3600)/((unsigned int16)timetaken1);//km/sa 
....................         //printf(lcd_putc,"\ft:%Lu",timetaken1); 
....................         yol1=tekerlek_tur1*(2*pi*tekerlek_yari_cap); 
1B08:  MOVFF  76,101
1B0C:  MOVFF  75,100
1B10:  RCALL  1888
1B12:  MOVFF  03,110
1B16:  MOVFF  02,10F
1B1A:  MOVFF  01,10E
1B1E:  MOVFF  00,10D
1B22:  MOVLW  AB
1B24:  MOVLB  1
1B26:  MOVWF  x14
1B28:  MOVLW  F4
1B2A:  MOVWF  x13
1B2C:  MOVLW  34
1B2E:  MOVWF  x12
1B30:  MOVLW  80
1B32:  MOVWF  x11
1B34:  MOVLB  0
1B36:  RCALL  18BE
1B38:  MOVFF  03,82
1B3C:  MOVFF  02,81
1B40:  MOVFF  01,80
1B44:  MOVFF  00,7F
....................     } 
....................     pevtime1 = millis(); 
1B48:  MOVFF  2D,5A
1B4C:  MOVFF  2C,59
1B50:  MOVFF  2B,58
1B54:  MOVFF  2A,57
....................     rotation1 = 0; 
1B58:  CLRF   x73
1B5A:  GOTO   2A8A (RETURN)
....................  } 
....................   
....................  void o2_hiz_olcum(){ 
....................       
....................     tekerlek_tur2++; 
1B5E:  INCF   x77,F
1B60:  BTFSC  FD8.2
1B62:  INCF   x78,F
....................     dtime2 = millis(); 
1B64:  MOVFF  2D,66
1B68:  MOVFF  2C,65
1B6C:  MOVFF  2B,64
1B70:  MOVFF  2A,63
....................     timetaken2 = (unsigned long)(millis() - pevtime2); //time in millisec for two rotations 
1B74:  MOVF   5B,W
1B76:  SUBWF  2A,W
1B78:  MOVWF  00
1B7A:  MOVF   5C,W
1B7C:  SUBWFB 2B,W
1B7E:  MOVWF  01
1B80:  MOVF   5D,W
1B82:  SUBWFB 2C,W
1B84:  MOVF   5E,W
1B86:  SUBWFB 2D,W
1B88:  MOVFF  01,6A
1B8C:  MOVFF  00,69
....................  
....................     if (timetaken2>0){ 
1B90:  MOVF   x69,F
1B92:  BNZ   1B9A
1B94:  MOVF   x6A,F
1B96:  BTFSC  FD8.2
1B98:  BRA    1CF2
....................       // rps2 = (unsigned int16)(1000 /((unsigned int16) timetaken2));//*60; //calculate rps(rotate per second)=F(Hz) 
....................        rpm2 = (unsigned int16)(1000 /((unsigned int16) timetaken2))*60; 
1B9A:  MOVLW  03
1B9C:  MOVLB  1
1B9E:  MOVWF  x0F
1BA0:  MOVLW  E8
1BA2:  MOVWF  x0E
1BA4:  MOVFF  6A,111
1BA8:  MOVFF  69,110
1BAC:  MOVLB  0
1BAE:  RCALL  1578
1BB0:  MOVFF  02,101
1BB4:  MOVFF  01,100
1BB8:  MOVFF  02,10F
1BBC:  MOVFF  01,10E
1BC0:  MOVLB  1
1BC2:  CLRF   x11
1BC4:  MOVLW  3C
1BC6:  MOVWF  x10
1BC8:  MOVLB  0
1BCA:  RCALL  1866
1BCC:  MOVFF  02,52
1BD0:  MOVFF  01,51
....................        v2= (float)(tekerlek_yari_cap * rpm2 * 0.37699f); //0.33 is the radius of the wheel in meter 
1BD4:  MOVFF  52,101
1BD8:  MOVFF  51,100
1BDC:  RCALL  1888
1BDE:  MOVLW  66
1BE0:  MOVLB  1
1BE2:  MOVWF  x10
1BE4:  MOVWF  x0F
1BE6:  MOVWF  x0E
1BE8:  MOVLW  7D
1BEA:  MOVWF  x0D
1BEC:  MOVFF  03,114
1BF0:  MOVFF  02,113
1BF4:  MOVFF  01,112
1BF8:  MOVFF  00,111
1BFC:  MOVLB  0
1BFE:  RCALL  18BE
1C00:  MOVFF  03,103
1C04:  MOVFF  02,102
1C08:  MOVFF  01,101
1C0C:  MOVFF  00,100
1C10:  MOVFF  03,110
1C14:  MOVFF  02,10F
1C18:  MOVFF  01,10E
1C1C:  MOVFF  00,10D
1C20:  MOVLW  D5
1C22:  MOVLB  1
1C24:  MOVWF  x14
1C26:  MOVLW  04
1C28:  MOVWF  x13
1C2A:  MOVLW  41
1C2C:  MOVWF  x12
1C2E:  MOVLW  7D
1C30:  MOVWF  x11
1C32:  MOVLB  0
1C34:  RCALL  18BE
1C36:  MOVFF  03,72
1C3A:  MOVFF  02,71
1C3E:  MOVFF  01,70
1C42:  MOVFF  00,6F
....................        if(o2_mod_say==COCUK_MOD) v2=v2*2.0f; 
1C46:  MOVF   3A,W
1C48:  SUBLW  02
1C4A:  BNZ   1C7C
1C4C:  MOVFF  72,110
1C50:  MOVFF  71,10F
1C54:  MOVFF  70,10E
1C58:  MOVFF  6F,10D
1C5C:  MOVLB  1
1C5E:  CLRF   x14
1C60:  CLRF   x13
1C62:  CLRF   x12
1C64:  MOVLW  80
1C66:  MOVWF  x11
1C68:  MOVLB  0
1C6A:  RCALL  18BE
1C6C:  MOVFF  03,72
1C70:  MOVFF  02,71
1C74:  MOVFF  01,70
1C78:  MOVFF  00,6F
....................        if(o2_mod_say==BAYAN_MOD) v2=v2*1.5f; 
1C7C:  DECFSZ 3A,W
1C7E:  BRA    1CB2
1C80:  MOVFF  72,110
1C84:  MOVFF  71,10F
1C88:  MOVFF  70,10E
1C8C:  MOVFF  6F,10D
1C90:  MOVLB  1
1C92:  CLRF   x14
1C94:  CLRF   x13
1C96:  MOVLW  40
1C98:  MOVWF  x12
1C9A:  MOVLW  7F
1C9C:  MOVWF  x11
1C9E:  MOVLB  0
1CA0:  RCALL  18BE
1CA2:  MOVFF  03,72
1CA6:  MOVFF  02,71
1CAA:  MOVFF  01,70
1CAE:  MOVFF  00,6F
....................        // v2=(float)(2*pi*radius_of_wheel*3600)/((unsigned int16)timetaken2);//km/sa 
....................         //printf(lcd_putc,"\ft:%f",v2); 
....................         yol2=tekerlek_tur2*(2*pi*tekerlek_yari_cap); 
1CB2:  MOVFF  78,101
1CB6:  MOVFF  77,100
1CBA:  RCALL  1888
1CBC:  MOVFF  03,110
1CC0:  MOVFF  02,10F
1CC4:  MOVFF  01,10E
1CC8:  MOVFF  00,10D
1CCC:  MOVLW  AB
1CCE:  MOVLB  1
1CD0:  MOVWF  x14
1CD2:  MOVLW  F4
1CD4:  MOVWF  x13
1CD6:  MOVLW  34
1CD8:  MOVWF  x12
1CDA:  MOVLW  80
1CDC:  MOVWF  x11
1CDE:  MOVLB  0
1CE0:  RCALL  18BE
1CE2:  MOVFF  03,86
1CE6:  MOVFF  02,85
1CEA:  MOVFF  01,84
1CEE:  MOVFF  00,83
....................     } 
....................     pevtime2 = millis(); 
1CF2:  MOVFF  2D,5E
1CF6:  MOVFF  2C,5D
1CFA:  MOVFF  2B,5C
1CFE:  MOVFF  2A,5B
....................     rotation2 = 0; 
1D02:  CLRF   x74
1D04:  GOTO   2A9A (RETURN)
....................  } 
....................   
....................  void o1_akim_olc(){ 
*
1F84:  CLRF   xFE
....................       int ornek=0; 
....................       set_adc_channel(ADC_KANAL_M1); 
1F86:  MOVLW  04
1F88:  MOVWF  01
1F8A:  MOVF   FC2,W
1F8C:  ANDLW  83
1F8E:  IORWF  01,W
1F90:  MOVWF  FC2
....................       delay_us(20); 
1F92:  MOVLW  34
1F94:  MOVWF  00
1F96:  DECFSZ 00,F
1F98:  BRA    1F96
1F9A:  BRA    1F9C
1F9C:  NOP   
....................        
....................       for(ornek=0;ornek<10;ornek++){ 
1F9E:  CLRF   xFE
1FA0:  MOVF   xFE,W
1FA2:  SUBLW  09
1FA4:  BNC   1FC2
....................            akim_adc_deger1+=read_adc(); 
1FA6:  BSF    FC2.1
1FA8:  BTFSC  FC2.1
1FAA:  BRA    1FA8
1FAC:  MOVF   FC3,W
1FAE:  ADDWF  4B,F
1FB0:  MOVF   FC4,W
1FB2:  ADDWFC 4C,F
....................            delay_us(25); 
1FB4:  MOVLW  42
1FB6:  MOVWF  00
1FB8:  DECFSZ 00,F
1FBA:  BRA    1FB8
1FBC:  NOP   
1FBE:  INCF   xFE,F
1FC0:  BRA    1FA0
....................        }   
....................        akim_adc_deger1=akim_adc_deger1/10;   
1FC2:  MOVFF  4C,10F
1FC6:  MOVFF  4B,10E
1FCA:  MOVLB  1
1FCC:  CLRF   x11
1FCE:  MOVLW  0A
1FD0:  MOVWF  x10
1FD2:  MOVLB  0
1FD4:  CALL   1578
1FD8:  MOVFF  02,4C
1FDC:  MOVFF  01,4B
1FE0:  RETURN 0
....................  } 
....................  void o2_akim_olc(){ 
1FE2:  CLRF   xFE
....................       int ornek=0; 
....................       set_adc_channel(ADC_KANAL_M2); 
1FE4:  MOVLW  00
1FE6:  MOVWF  01
1FE8:  MOVF   FC2,W
1FEA:  ANDLW  83
1FEC:  IORWF  01,W
1FEE:  MOVWF  FC2
....................       delay_us(20); 
1FF0:  MOVLW  34
1FF2:  MOVWF  00
1FF4:  DECFSZ 00,F
1FF6:  BRA    1FF4
1FF8:  BRA    1FFA
1FFA:  NOP   
....................        
....................       for(ornek=0;ornek<10;ornek++){ 
1FFC:  CLRF   xFE
1FFE:  MOVF   xFE,W
2000:  SUBLW  09
2002:  BNC   2020
....................            akim_adc_deger2+=read_adc(); 
2004:  BSF    FC2.1
2006:  BTFSC  FC2.1
2008:  BRA    2006
200A:  MOVF   FC3,W
200C:  ADDWF  4D,F
200E:  MOVF   FC4,W
2010:  ADDWFC 4E,F
....................            delay_us(25); 
2012:  MOVLW  42
2014:  MOVWF  00
2016:  DECFSZ 00,F
2018:  BRA    2016
201A:  NOP   
201C:  INCF   xFE,F
201E:  BRA    1FFE
....................        }   
....................        akim_adc_deger2=akim_adc_deger2/10;   
2020:  MOVFF  4E,10F
2024:  MOVFF  4D,10E
2028:  MOVLB  1
202A:  CLRF   x11
202C:  MOVLW  0A
202E:  MOVWF  x10
2030:  MOVLB  0
2032:  CALL   1578
2036:  MOVFF  02,4E
203A:  MOVFF  01,4D
203E:  RETURN 0
....................  } 
....................  /********************************Kesme Alt Program****************************/ 
.................... #INT_EXT HIGH //NOCLEAR //      //Set external interrupt on pin RB0  
.................... void ISR_RB0()  
.................... {  
....................     // printf(lcd_putc,"\fINT_EXT0-JTN1"); 
....................      jetonKontrol(JTN_PIN); 
*
0770:  BSF    F93.0
0772:  BTFSC  F81.0
0774:  BRA    078E
0776:  MOVLW  02
0778:  MOVLB  1
077A:  MOVWF  x26
077C:  MOVLW  FA
077E:  MOVWF  x27
0780:  MOVLB  0
0782:  RCALL  0748
0784:  MOVLB  1
0786:  DECFSZ x26,F
0788:  BRA    077C
078A:  INCF   37,F
078C:  MOVLB  0
078E:  MOVF   x9C,F
0790:  BZ    07A0
0792:  MOVF   x9C,W
0794:  SUBWF  37,W
0796:  BNC   07A0
0798:  BSF    38.0
079A:  CLRF   37
079C:  INCF   36,F
079E:  BRA    07A4
07A0:  BSF    38.0
07A2:  INCF   36,F
....................      clear_interrupt(INT_EXT); 
07A4:  BCF    FF2.1
.................... }  
....................  
07A6:  BCF    FF2.1
07A8:  GOTO   0116
.................... #INT_EXT1 NOCLEAR //HIGH      //HIZ1 
.................... void ISR_RB1()  
.................... {  
.................... //    if(!input(HIZ1_SENS_PIN)){ 
.................... //        printf(lcd_putc,"\fINT_EXT1-H1");  
.................... //        delay_ms(1500); 
.................... //    } 
....................     disable_interrupts(INT_EXT1); 
07AC:  BCF    FF0.3
....................     delay_ms(DELAY_OLCUM);// bekleyip ölçüm yapýlmalý. 
07AE:  MOVLW  0A
07B0:  MOVLB  1
07B2:  MOVWF  x27
07B4:  MOVLB  0
07B6:  RCALL  0748
....................                 // max saniyede 10 tur yani 10 Hz olursa 
....................     if(!input(HIZ1_SENS_PIN)) rotation1++; 
07B8:  BSF    F93.1
07BA:  BTFSC  F81.1
07BC:  BRA    07C0
07BE:  INCF   x73,F
....................      
....................     clear_interrupt(INT_EXT1); 
07C0:  BCF    FF0.0
....................     enable_interrupts(INT_EXT1); 
07C2:  BSF    FF0.3
....................     
.................... } 
07C4:  GOTO   0088
.................... #INT_EXT2 NOCLEAR   //HIGH      //HIZ2 
.................... void ISR_RB2()  
.................... {  
.................... //    if(!input(HIZ2_SENS_PIN)){ 
.................... //        printf(lcd_putc,"\fINT_EXT2-H2"); 
.................... //        delay_ms(1500); 
.................... //    } 
....................      
....................     disable_interrupts(INT_EXT2); 
07C8:  BCF    FF0.4
....................     delay_ms(DELAY_OLCUM);// bekleyip ölçüm yapýlmalý. 
07CA:  MOVLW  0A
07CC:  MOVLB  1
07CE:  MOVWF  x27
07D0:  MOVLB  0
07D2:  RCALL  0748
....................                 // max saniyede 10 tur yani 10 Hz olursa 
....................     if(!input(HIZ2_SENS_PIN)) rotation2++;  
07D4:  BSF    F93.2
07D6:  BTFSC  F81.2
07D8:  BRA    07DC
07DA:  INCF   x74,F
....................     clear_interrupt(INT_EXT2); 
07DC:  BCF    FF0.1
....................     enable_interrupts(INT_EXT2); 
07DE:  BSF    FF0.4
.................... } 
....................  
07E0:  GOTO   0088
.................... #INT_RB //NOCLEAR //Port B any change on B4-B7 
.................... void ISR_RB_Change()  
.................... {  
....................     delay_ms(10); 
07E4:  MOVLW  0A
07E6:  MOVLB  1
07E8:  MOVWF  x27
07EA:  MOVLB  0
07EC:  RCALL  0748
....................      
....................     if(!input(PIN_B4))      //TUR2 
07EE:  BSF    F93.4
07F0:  BTFSC  F81.4
07F2:  BRA    07FA
....................     { 
....................       pist_tur2++; 
07F4:  INCF   x7B,F
07F6:  BTFSC  FD8.2
07F8:  INCF   x7C,F
....................      // printf(lcd_putc,"\fB4_T2:%lu",pist_tur2); 
....................           //delay_ms(1500); 
....................         
....................     } 
....................     if(!input(PIN_B5))      //TUR1 
07FA:  BSF    F93.5
07FC:  BTFSC  F81.5
07FE:  BRA    0806
....................     { 
....................         pist_tur1++; 
0800:  INCF   x79,F
0802:  BTFSC  FD8.2
0804:  INCF   x7A,F
....................        // printf(lcd_putc,"\fB5-T1:%lu"pist_tur1); 
....................         //delay_ms(1500); 
....................          
....................     } 
....................     if(!input(PIN_B7)) 
0806:  BSF    F93.7
0808:  BTFSC  F81.7
080A:  BRA    080C
....................     { 
....................         //printf(lcd_putc,"\fB7-J2"); 
....................         //jetonKontrol(JTN2_PIN); 
....................     } 
....................       
....................     clear_interrupt(INT_RB); 
080C:  BCF    FF2.0
....................    
080E:  BCF    FF2.0
0810:  GOTO   0088
.................... } 
....................  
.................... long map(long x, long in_min, long in_max, long out_min, long out_max) 
.................... { 
....................  	    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; 
*
1D08:  MOVLB  1
1D0A:  MOVF   x02,W
1D0C:  SUBWF  x00,W
1D0E:  MOVWF  x0A
1D10:  MOVF   x03,W
1D12:  SUBWFB x01,W
1D14:  MOVWF  x0B
1D16:  MOVF   x06,W
1D18:  SUBWF  x08,W
1D1A:  MOVWF  00
1D1C:  MOVF   x07,W
1D1E:  SUBWFB x09,W
1D20:  MOVWF  03
1D22:  MOVFF  00,10C
1D26:  MOVWF  x0D
1D28:  MOVFF  10B,10F
1D2C:  MOVFF  10A,10E
1D30:  MOVWF  x11
1D32:  MOVFF  00,110
1D36:  MOVLB  0
1D38:  RCALL  1866
1D3A:  MOVFF  02,10B
1D3E:  MOVFF  01,10A
1D42:  MOVLB  1
1D44:  MOVF   x02,W
1D46:  SUBWF  x04,W
1D48:  MOVWF  00
1D4A:  MOVF   x03,W
1D4C:  SUBWFB x05,W
1D4E:  MOVWF  03
1D50:  MOVFF  00,10C
1D54:  MOVWF  x0D
1D56:  MOVFF  02,10F
1D5A:  MOVFF  01,10E
1D5E:  MOVWF  x11
1D60:  MOVFF  00,110
1D64:  MOVLB  0
1D66:  RCALL  1578
1D68:  MOVFF  02,10B
1D6C:  MOVFF  01,10A
1D70:  MOVLB  1
1D72:  MOVF   x06,W
1D74:  ADDWF  01,W
1D76:  MOVWF  01
1D78:  MOVF   x07,W
1D7A:  ADDWFC 02,W
1D7C:  MOVWF  03
1D7E:  MOVWF  02
1D80:  MOVLB  0
1D82:  RETURN 0
.................... } 
....................  

Configuration Fuses:
   Word  1: B800   INTRC_IO PLLEN PRIMARY_ON NOFCMEN IESO
   Word  2: 1E19   NOPUT NOBROWNOUT BORV19 WDT_SW WDT128
   Word  3: B500   CCP2C1 NOPBADEN CCP3B5 NOHFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C000   PROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
